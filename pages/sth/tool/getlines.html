<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell: getlines</title>
<link rel="stylesheet" type="text/css" href="../../../css/default.css" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../../index.html">Home</a>
    <a href="../../../about.html">About</a>
    <a href="../../../projects.html">Projects</a>
    <a href="../../../contact.html">Contact</a>
    <a href="../../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: getlines</h1>
<!-- BEGIN BODY -->
<div class="subtitle">
<h2>extract lines from stdin by index</h2>
This page is part of a series on <a href="../../../pages/sth/index.html">Software Tools in Haskell</a>.
</div>

<p>This program is not an example from <em>Software Tools</em>; I wrote it to test some functionality that will eventually go into the print program – namely, parsing sets of integers.</p>
<p><code>getlines</code> does one thing: it takes a set of integers as an argument, and extracts from <code>stdin</code> the lines whose indices (counting from 1) are in the given set. For instance,</p>
<pre><code>getlines &quot;6&quot;</code></pre>
<p>extracts the line at index 6. We can also specify ranges, like</p>
<pre><code>getlines &quot;1-5&quot;</code></pre>
<p>which extracts lines 1, 2, 3, 4, and 5, as well as skip counts, like</p>
<pre><code>getlines &quot;2+3&quot;</code></pre>
<p>which extracts every third line starting with the second (i.e. 2, 5, 8, and so on). We can give several rules separated by commas, and the indices specified will be extracted in order. So</p>
<pre><code>getlines &quot;7-9,1,2&quot;</code></pre>
<p>will extract lines 1, 2, 7, 8, and 9, in that order. We can give more than one integer set argument, and each will be considered in turn with the results concatenated. So</p>
<pre><code>getlines &quot;1,2&quot; &quot;1,2&quot; &quot;1,2&quot;</code></pre>
<p>extracts lines 1, 2, 1, 2, 1, and 2, in that order.</p>
<p>We define a data type for each kind of integer set: single integers, ranges, and skip counts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IntSet</span>
  <span class="fu">=</span> <span class="dt">Single</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Range</span>  <span class="dt">Int</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Skip</span>   <span class="dt">Int</span> <span class="dt">Int</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">inIntSet ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">IntSet</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
inIntSet k ms <span class="fu">=</span> or <span class="fu">$</span> map (inIntSet' k) ms
  <span class="kw">where</span>
<span class="ot">    inIntSet' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IntSet</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
    inIntSet' k (<span class="dt">Single</span> m)  <span class="fu">=</span> k <span class="fu">==</span> m
    inIntSet' k (<span class="dt">Range</span> a b) <span class="fu">=</span> (a <span class="fu">&lt;=</span> k) <span class="fu">&amp;&amp;</span> (k <span class="fu">&lt;=</span> b)
    inIntSet' k (<span class="dt">Skip</span> a b)  <span class="fu">=</span> (k <span class="fu">&gt;=</span> a) <span class="fu">&amp;&amp;</span> ((k<span class="fu">-</span>a)<span class="ot">`rem`</span>b <span class="fu">==</span> <span class="dv">0</span>)

<span class="ot">readIntSet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
readIntSet xs <span class="fu">=</span> <span class="kw">do</span>
  cs <span class="ot">&lt;-</span> readIntSet' xs
  return (\k <span class="ot">-&gt;</span> inIntSet k cs)

<span class="ot">readIntSet' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">IntSet</span>]
readIntSet' <span class="fu">=</span> sequence <span class="fu">.</span> map oneIntSeq <span class="fu">.</span> breakAt <span class="ch">','</span>
  <span class="kw">where</span>
<span class="ot">    oneIntSeq ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">IntSet</span>
    oneIntSeq <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Nothing</span>
    oneIntSeq xs <span class="fu">=</span> <span class="kw">case</span> readDecimalNat xs <span class="kw">of</span>
      <span class="dt">Just</span> k  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Single</span> k
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> map readDecimalNat <span class="fu">$</span> breakAt <span class="ch">'-'</span> xs <span class="kw">of</span>
        [<span class="dt">Just</span> a, <span class="dt">Just</span> b] <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Range</span> a b
        otherwise        <span class="ot">-&gt;</span> <span class="kw">case</span> map readDecimalNat <span class="fu">$</span> breakAt <span class="ch">'+'</span> xs <span class="kw">of</span>
          [<span class="dt">Just</span> a, <span class="dt">Just</span> b] <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Skip</span> a b
          otherwise        <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre></div>
<p>This code is in a separate library module which only exports one function: <code>readIntSet</code>. That function takes the string representation of a set and returns a function that detects whether a given integer is in the set specified. Compared to representing a set of integers as a set, this makes representing large ranges more efficient and makes representing infinite sets (like skip lists) possible.</p>
<p>Next we write a library function that extracts items from a list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getEltsByIndex ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
getEltsByIndex p xs <span class="fu">=</span> map snd <span class="fu">$</span> filter (p <span class="fu">.</span> fst) <span class="fu">$</span> zip [<span class="dv">1</span><span class="fu">..</span>] xs</code></pre></div>
<p>Finally, the main program is simple enough. We take one optional argument, <code>--asacc</code>, which interprets “lines” using the ASA carriage control format.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- getlines: extract lines from stdin by index</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">STH.Lib</span>
  (getEltsByIndex, reportErrorMsgs, readIntSet,
   putStrLns, getLines, readCCLines, renderCCLine,
   putCCLns)


<span class="kw">data</span> <span class="dt">Mode</span> <span class="fu">=</span> <span class="dt">Lines</span> <span class="fu">|</span> <span class="dt">ASACC</span>


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  <span class="co">-- interpret arguments</span>
  (mode,tests) <span class="ot">&lt;-</span> <span class="kw">do</span>
    <span class="kw">let</span>
      (flag,rest) <span class="fu">=</span> <span class="kw">case</span> args <span class="kw">of</span>
        (<span class="st">&quot;--asacc&quot;</span><span class="fu">:</span>zs) <span class="ot">-&gt;</span> (<span class="dt">ASACC</span>, zs)
        zs             <span class="ot">-&gt;</span> (<span class="dt">Lines</span>, zs)

    ps <span class="ot">&lt;-</span> <span class="kw">case</span> sequence <span class="fu">$</span> map readIntSet rest <span class="kw">of</span>
      <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return xs
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure

    return (flag,ps)

  <span class="kw">let</span> get xs p <span class="fu">=</span> getEltsByIndex p xs

  <span class="kw">case</span> mode <span class="kw">of</span>
    <span class="dt">Lines</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
      lines <span class="ot">&lt;-</span> fmap getLines getContents
      putStrLns <span class="fu">$</span> concatMap (get lines) tests
    <span class="dt">ASACC</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
      lines <span class="ot">&lt;-</span> fmap readCCLines getContents
      <span class="kw">case</span> lines <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> corrErr <span class="fu">&gt;&gt;</span> exitFailure
        <span class="dt">Just</span> zs <span class="ot">-&gt;</span> putCCLns <span class="fu">$</span> concatMap (get zs) tests

  exitSuccess


<span class="ot">argErr ::</span> <span class="dt">IO</span> ()
argErr <span class="fu">=</span> reportErrorMsgs
  [ <span class="st">&quot;usage:&quot;</span>
  , <span class="st">&quot;  getlines INTSET ... : extract lines from stdin at indices in RANGE (sorted)&quot;</span>
  , <span class="st">&quot;options:&quot;</span>
  , <span class="st">&quot;  --asacc : read as ASA carriage control lines&quot;</span>
  ]


<span class="ot">corrErr ::</span> <span class="dt">IO</span> ()
corrErr <span class="fu">=</span> reportErrorMsgs
  [ <span class="st">&quot;corrupt input&quot;</span> ]</code></pre></div>
<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
