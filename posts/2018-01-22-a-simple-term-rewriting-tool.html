<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - A simple term rewriting tool</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<link rel="icon" href="../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../pages/about.html">About</a>
    <a href="../pages/projects.html">Projects</a>
    <a href="../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>A simple term rewriting tool</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2018-01-23 by nbloomf
</div>


<div class="info tags">Tags: <a href="../tag/literate-haskell.html">literate-haskell</a></div>


<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/2018-01-22-a-simple-term-rewriting-tool.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">TermRewriting</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span> (nub, unfoldr)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (catMaybes)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Text.ParserCombinators.Parsec</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">System.Environment</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">System.IO</span></a></code></pre></div>
<p>Today we’ll build a tool that applies term-rewriting rules to expressions in a simplified form of mathematical notation.</p>
<p>My motivation for this comes from the <a href="../pages/amd.html">Arithmetic Made Difficult</a> series of posts on this site. There, I’m writing lots of equation-style proofs, and it would be nice to have a tool check that at least some of the steps in those proofs are carried out correctly. I won’t try to build a full-fledged proof checker – building a proof checker that uses a syntax readable by people is a Hard Problem. But a simple term rewriting tool can get us (made up number) 80% of the benefits with 1% of the effort. With this tool, we’ll be able to annotate equational proofs with “justification” information that is machine checked, but also compiles to human readable cross references (hyperlinks).</p>
<h2 id="grammar">Grammar</h2>
<p>To set the scope of the problem, we’ll focus on a subset of math notation that can be easily translated to something like lambda calculus. The basic ingredients are</p>
<ol type="1">
<li><em>constants</em>, or atomic expressions, that represent themselves;</li>
<li><em>variables</em>, that represent arbitrary subexpressions; and</li>
<li><em>application</em> of one expression to another.</li>
</ol>
<p>We can represent this little grammar with the following <code>Expr</code> type.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Con</span> <span class="dt">Token</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Token</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">String</span></a></code></pre></div>
<p>In keeping with <span class="math inline">\(\LaTeX\)</span> syntax, we will decree that constants consist of one or more letters prefixed by a <code>\</code>, such as</p>
<pre><code>\plus \times \cons</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">pCon ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">pCon <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  char <span class="ch">'\\'</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  token <span class="ot">&lt;-</span> many1 letter</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  return (<span class="dt">Con</span> token)</a></code></pre></div>
<p>We’ll decree that variables consist of one or more letters <em>not</em> prefixed by a <code>\</code>, such as</p>
<pre><code>a b foo munge</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">pVar ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">pVar <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  token <span class="ot">&lt;-</span> many1 letter</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  return (<span class="dt">Var</span> token)</a></code></pre></div>
<p>Application is a little trickier. Certainly an expression like <code>f(a)</code> means “the expression <code>f</code> applied to the expression <code>a</code>. The trouble is how to handle functions with more than one argument. We’ll do this by implicitly currying all functions. Remember that any function with signature</p>
<pre><code>f : (a,b) -&gt; c</code></pre>
<p>is equivalent to one with signature</p>
<pre><code>g : a -&gt; b -&gt; c</code></pre>
<p>where the function arrow is right associative. So we can interpret an expression like <code>f(a,b)</code> implicitly as <code>f(a)(b)</code>. In particular, we only need to support functions of one argument. But we also need to handle explicitly curried functions, like</p>
<pre><code>f(a)(b,c)</code></pre>
<p>and we also need to allow arguments to be fenced in either parentheses or braces.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">fenced ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">fenced p <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">      (between (char <span class="ch">'('</span>) (char <span class="ch">')'</span>) p)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">&lt;|&gt;</span> (between (char <span class="ch">'{'</span>) (char <span class="ch">'}'</span>) p)</a></code></pre></div>
<p>We’ll say that an “expression” is a constant or variable followed by zero or more fenced comma-delimited lists of subexpressions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">pLatexExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">pLatexExpr <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f <span class="ot">&lt;-</span> pCon <span class="fu">&lt;|&gt;</span> pVar</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  args <span class="ot">&lt;-</span> option [] <span class="fu">$</span> many1 <span class="fu">$</span> fenced <span class="fu">$</span> sepBy1 pLatexExpr (char <span class="ch">','</span>)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  return <span class="fu">$</span> foldl <span class="dt">App</span> f <span class="fu">$</span> concat args</a></code></pre></div>
<p>Nothing about the <code>Expr</code> type is specific to LaTeX, but (at least for now) this tool will be used specifically to parse and verify equations written in LaTeX.</p>
<p>While we’re at it, some parsing helpers:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">parseWith ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">parseWith loc p text <span class="fu">=</span> <span class="kw">case</span> runParser (p <span class="fu">&lt;*</span> eof) () loc text <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="dt">Left</span> (show err)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="dt">Right</span> x</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">parseWithIO ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">parseWithIO loc p text <span class="fu">=</span> <span class="kw">case</span> parseWith loc p text <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="dt">Left</span> msg <span class="ot">-&gt;</span> putStrLn (unwords [loc,text,msg]) <span class="fu">&gt;&gt;</span> exitFailure</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="dt">Right</span> a  <span class="ot">-&gt;</span> return a</a></code></pre></div>
<p>And here is an example.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">$&gt;</span> x <span class="ot">&lt;-</span> parseWithIO <span class="st">&quot;&quot;</span> pLatexExpr <span class="st">&quot;\\plus(a,\\times(b,c))&quot;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">$&gt;</span> putStrLn <span class="fu">$</span> show x</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;plus&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;times&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;c&quot;</span>))</a></code></pre></div>
<p>We’ll also make a function to pretty print <code>Expr</code>s as LaTeX.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">latex ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">latex (<span class="dt">Con</span> x) <span class="fu">=</span> <span class="ch">'\\'</span> <span class="fu">:</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">latex (<span class="dt">Var</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">latex (<span class="dt">App</span> x y) <span class="fu">=</span> concat</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  [ latex x, <span class="st">&quot;(&quot;</span>, latex y, <span class="st">&quot;)&quot;</span> ]</a></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">$&gt;</span> x <span class="ot">&lt;-</span> parseWithIO <span class="st">&quot;&quot;</span> pLatexExpr <span class="st">&quot;\\plus(a,\\times(b,c))&quot;</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="fu">$&gt;</span> putStrLn <span class="fu">$</span> latex x</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">\plus(a)(\times(b)(c))</a></code></pre></div>
<p>Note that the round trip generally takes a LaTeX statement to a different, but equivalent, statement. This is the price of simplicity, and doesn’t matter too much.</p>
<h2 id="substitutions">Substitutions</h2>
<p>A <em>substitution</em> is a mapping from variables to expressions, which we’ll represent using as a list of pairs.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Substitution</span> <span class="fu">=</span> [(<span class="dt">Token</span>, <span class="dt">Expr</span>)]</a></code></pre></div>
<p>Since lists are not actually maps, we need a helper function to decide whether a given list of token-expression pairs is well-defined. That is, a valid substitution shouldn’t have two pairs with the same token but different expressions.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">wellDefined ::</span> <span class="dt">Substitution</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">wellDefined [] <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">wellDefined ((x,a)<span class="fu">:</span>ps) <span class="fu">=</span> and</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  [ null (filter (\(y,b) <span class="ot">-&gt;</span> (x <span class="fu">==</span> y) <span class="fu">&amp;&amp;</span> (a <span class="fu">/=</span> b)) ps)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  , wellDefined ps</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  ]</a></code></pre></div>
<p>Now actually making a substitution is straightforward; we march down an <code>Expr</code>, and if we find a variable token replace it with its associated subexpression. We do the simplest thing by replacing <em>all</em> instances of the variable.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">substitute ::</span> <span class="dt">Substitution</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">substitute _ (<span class="dt">Con</span> a) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="dt">Con</span> a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">substitute es (<span class="dt">Var</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="kw">case</span> lookup x es <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="dt">Just</span> e  <span class="ot">-&gt;</span> e</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Var</span> x</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">substitute es (<span class="dt">App</span> a b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="dt">App</span> (substitute es a) (substitute es b)</a></code></pre></div>
<p>Next we can try to construct a substitution taking one expression to another, based at the root. Constants match only themselves, variables match anything, and applications match recursively.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">matches ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">matches pattern expr <span class="fu">=</span> match pattern expr <span class="fu">&gt;&gt;=</span> check</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    check ps <span class="fu">=</span> <span class="kw">if</span> wellDefined ps</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">      <span class="kw">then</span> <span class="dt">Just</span> (nub ps)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    match (<span class="dt">Con</span> a) (<span class="dt">Con</span> b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="kw">if</span> a <span class="fu">==</span> b <span class="kw">then</span> <span class="dt">Just</span> [] <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    match (<span class="dt">Con</span> _) _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    match (<span class="dt">Var</span> x) e <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">      <span class="dt">Just</span> [(x,e)]</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    match (<span class="dt">App</span> e1 e2) (<span class="dt">App</span> f1 f2) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15">      xs <span class="ot">&lt;-</span> match e1 f1</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">      ys <span class="ot">&lt;-</span> match e2 f2</a>
<a class="sourceLine" id="cb19-17" data-line-number="17">      return (xs <span class="fu">++</span> ys)</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">    match (<span class="dt">App</span> _ _) _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-19" data-line-number="19">      <span class="dt">Nothing</span></a></code></pre></div>
<p>More generally matches can occur anywhere in an expression, and we need to be able to unambiguously state where the match is. The <code>Path</code> type represents a series of directions for moving from the root of an expression to some interior node.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">H</span> <span class="fu">|</span> <span class="dt">L</span> <span class="dt">Path</span> <span class="fu">|</span> <span class="dt">R</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>And <code>matchesIn</code> constructs a list of all substitutions from one expression to another, along with paths to the root of each substitution.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">matchesIn ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [(<span class="dt">Path</span>, <span class="dt">Substitution</span>)]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">matchesIn pattern expr <span class="fu">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="dt">Con</span> a <span class="ot">-&gt;</span> <span class="kw">case</span> matches pattern expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    <span class="dt">Just</span> s  <span class="ot">-&gt;</span> [(<span class="dt">H</span>, s)]</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  <span class="dt">Var</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> matches pattern expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    <span class="dt">Just</span> s  <span class="ot">-&gt;</span> [(<span class="dt">H</span>, s)]</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  <span class="dt">App</span> x y <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">      mx <span class="fu">=</span> map (\(p,z) <span class="ot">-&gt;</span> (<span class="dt">L</span> p, z)) <span class="fu">$</span> matchesIn pattern x</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">      my <span class="fu">=</span> map (\(p,z) <span class="ot">-&gt;</span> (<span class="dt">R</span> p, z)) <span class="fu">$</span> matchesIn pattern y</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    <span class="kw">case</span> matches pattern expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> mx <span class="fu">++</span> my</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">      <span class="dt">Just</span> s  <span class="ot">-&gt;</span> (<span class="dt">H</span>,s) <span class="fu">:</span> mx <span class="fu">++</span> my</a></code></pre></div>
<p>Given a <code>Path</code>, we can (attempt to) transform the subexpression it points to.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">transform ::</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">transform f <span class="dt">H</span> expr <span class="fu">=</span> <span class="dt">Just</span> (f expr)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">transform f (<span class="dt">L</span> path) (<span class="dt">App</span> expr w) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  q <span class="ot">&lt;-</span> transform f path expr</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="dt">Just</span> (<span class="dt">App</span> q w)</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">transform f (<span class="dt">R</span> path) (<span class="dt">App</span> w expr) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  q <span class="ot">&lt;-</span> transform f path expr</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="dt">Just</span> (<span class="dt">App</span> w q)</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">transform _ _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>As a special case, <code>rewrite</code> replaces the subexpression at a given location.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">rewrite ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">rewrite p <span class="fu">=</span> transform (const p)</a></code></pre></div>
<p>Substituting application expressions, where we want to match the arguments, is a little different.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">funMatch ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">funMatch (<span class="dt">Con</span> a) (<span class="dt">Con</span> b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="kw">if</span> a <span class="fu">==</span> b <span class="kw">then</span> return [] <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">funMatch (<span class="dt">Var</span> x) (<span class="dt">Var</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="kw">if</span> x <span class="fu">==</span> y <span class="kw">then</span> return [] <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">funMatch (<span class="dt">App</span> e (<span class="dt">Var</span> x)) (<span class="dt">App</span> f g) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  fmap ((x,g)<span class="fu">:</span>) <span class="fu">$</span> funMatch e f</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">funMatch _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="ot">funSub ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">funSub _ _ (<span class="dt">Con</span> a) <span class="fu">=</span> return (<span class="dt">Con</span> a)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">funSub _ _ (<span class="dt">Var</span> x) <span class="fu">=</span> return (<span class="dt">Var</span> x)</a>
<a class="sourceLine" id="cb24-13" data-line-number="13">funSub repl func (<span class="dt">App</span> f x) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14">  y <span class="ot">&lt;-</span> funSub repl func x</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">  g <span class="ot">&lt;-</span> funSub repl func f</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">  <span class="kw">case</span> funMatch func (<span class="dt">App</span> g y) <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-17" data-line-number="17">    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">App</span> g y</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    <span class="dt">Just</span> sub <span class="ot">-&gt;</span> <span class="kw">if</span> wellDefined sub</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">      <span class="kw">then</span> return <span class="fu">$</span> substitute sub repl</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">      <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<h2 id="rewrite-rules">Rewrite Rules</h2>
<p>A <em>rewrite rule</em> is a pair of expressions that we interpret as being “equal” for all possible substitutions.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Rule</span> <span class="fu">=</span> (<span class="dt">Expr</span>, <span class="dt">Expr</span>)</a></code></pre></div>
<p>In our latexy syntax, we’ll say a rewrite rule is two expressions, separated by an equals sign, and separated by spaces.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">pRule ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Rule</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">pRule p <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  a <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  spaces</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  char <span class="ch">'='</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">  spaces</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  b <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  return (a,b)</a></code></pre></div>
<p>To apply a rewrite rule to an expression, we find all matches of the left hand side in the expression, substitute these into the right hand side, and then rewrite the expression.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">applyRule ::</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">applyRule (lhs,rhs) x <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  catMaybes <span class="fu">$</span> map applyMatch <span class="fu">$</span> matchesIn lhs x</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    applyMatch (path,sub) <span class="fu">=</span> rewrite (substitute sub rhs) path x</a></code></pre></div>
<p>To <em>validate</em> a rule application – to check that <code>a = b</code> maps <code>e</code> to <code>f</code> – we apply the rule to <code>e</code> and see if <code>f</code> is among the resuls.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">validate ::</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">validate rule input output <span class="fu">=</span> elem output (applyRule rule input)</a></code></pre></div>
<p>Most of the rewrite rules and expressions we’ll deal with are <em>symmetric</em>; we don’t mind reversing the order of the expressions in the rewrite rule, and the roles of the input and output expressions. For this case we’ll use a separate validation function.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">validateSymmetric ::</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">validateSymmetric (lhs,rhs) e f <span class="fu">=</span> or</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  [ validate (lhs,rhs) e f</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">  , validate (rhs,lhs) e f</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">  , validate (lhs,rhs) f e</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  , validate (rhs,lhs) f e</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">  ]</a></code></pre></div>
<h2 id="interface">Interface</h2>
<p>Remember: this tool is specifically intended for use with the <a href="../pages/amd.html">Arithmetic Made Difficult</a> posts, which include a few thousand lines worth of equational proofs. Those posts need two kinds of support.</p>
<ol type="1">
<li>We’d like to statically check the equalities in our equational proofs. Some equalities are annotated with a cross reference to the theorem that justifies them. Some <code>sed</code> magic can turn these into rewrite rules, which we can use to verify that the left hand side of an equality rewrites to the right hand side. Verifying one equality at a time, rather than an entire proof, makes it possible to build up static checks incrementally.</li>
<li>We’d also like to statically check variable substitutions. This is similar to scenario 1, except instead of rewriting a single (complex) subexpression, in this case we only care about replacing all instances of a variable with some expression and validating the result.</li>
<li>If an equality <em>doesn’t</em> have a cross referenced annotation, it’d be nice if our tool could also give suggestions for valid cross references based on a dictionary of rewrite rules. Bonus points if it also builds an edit script for inserting the annotation (hint, it will).</li>
</ol>
<p>These requirements suggest that the tool needs three modes, which we’ll call <em>verify</em> mode, <em>substitute</em> mode, and <em>suggest</em> mode, respectively.</p>
<p>We’ll keep this really simple. In verify mode, the tool expects its input on <code>stdin</code>, one rewrite check per line, in the form</p>
<pre><code>location TAB rulelhs = rulerhs TAB from-expr TAB to-expr</code></pre>
<p>Where <code>location</code> is some information about where the check comes from (for reporting problems). So we’ll need to split a line on tabs:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">unTab ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">unTab <span class="fu">=</span> unfoldr getCell</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    getCell [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    getCell xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">        (cell, z) <span class="fu">=</span> span (<span class="fu">/=</span> <span class="ch">'\t'</span>) xs</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">        rest <span class="fu">=</span> <span class="kw">if</span> null z <span class="kw">then</span> [] <span class="kw">else</span> tail z</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">        <span class="dt">Just</span> (cell, rest)</a></code></pre></div>
<p>And we’ll need to process one untabbed line. We’re assuming that the rewrite rules are symmetric; given <code>x = y</code> and two expressions <code>e</code> and <code>f</code>, any substitution taking either <code>e</code> to <code>f</code> or <code>f</code> to <code>e</code> is considered valid. This is ok for the equation chains we want to use this on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">processVerify ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">processVerify [loc,r,a,b] <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  rule <span class="ot">&lt;-</span> parseWithIO loc (pRule pLatexExpr) r</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  e <span class="ot">&lt;-</span> parseWithIO loc pLatexExpr a</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  f <span class="ot">&lt;-</span> parseWithIO loc pLatexExpr b</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  <span class="kw">if</span> validateSymmetric rule e f</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="kw">then</span> return ()</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">    <span class="kw">else</span> putStrLn <span class="fu">$</span> unwords [loc,<span class="st">&quot;invalid!&quot;</span>,r,<span class="st">&quot;::&quot;</span>,a,<span class="st">&quot;--&gt;&quot;</span>,b]</a>
<a class="sourceLine" id="cb32-9" data-line-number="9">processVerify xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">  putStrLn <span class="fu">$</span> unwords (<span class="st">&quot;unrecognized input format:&quot;</span> <span class="fu">:</span> xs)</a></code></pre></div>
<p>In substitute mode, we’ll accept input in the same format as for verify mode, with an extra check on the form of the rewrite rule.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">processSubstitute ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">processSubstitute [loc,r,a,b] <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  (lhs,rhs) <span class="ot">&lt;-</span> parseWithIO loc (pRule pLatexExpr) r</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  e <span class="ot">&lt;-</span> parseWithIO loc pLatexExpr a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">  f <span class="ot">&lt;-</span> parseWithIO loc pLatexExpr b</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">  <span class="kw">case</span> lhs <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    <span class="dt">Var</span> x <span class="ot">-&gt;</span> <span class="kw">if</span> (f <span class="fu">==</span> substitute [(x,rhs)] e) <span class="fu">||</span> (e <span class="fu">==</span> substitute [(x,rhs)] f)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">      <span class="kw">then</span> return ()</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">      <span class="kw">else</span> putStrLn <span class="fu">$</span> unwords [loc,<span class="st">&quot;invalid!&quot;</span>,r,<span class="st">&quot;::&quot;</span>,a,<span class="st">&quot;--&gt;&quot;</span>,b]</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">    <span class="dt">App</span> _ _ <span class="ot">-&gt;</span> <span class="kw">if</span> (<span class="dt">Just</span> f <span class="fu">==</span> funSub rhs lhs e) <span class="fu">||</span> (<span class="dt">Just</span> e <span class="fu">==</span> funSub rhs lhs e)</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">      <span class="kw">then</span> return ()</a>
<a class="sourceLine" id="cb33-12" data-line-number="12">      <span class="kw">else</span> putStrLn <span class="fu">$</span> unwords [loc,<span class="st">&quot;invalid!&quot;</span>,r,<span class="st">&quot;::&quot;</span>,a,<span class="st">&quot;--&gt;&quot;</span>,b]</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">    _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14">      putStrLn <span class="fu">$</span> unwords [loc,<span class="st">&quot;rewrite rule must be of the form 'var = expr':&quot;</span>,r]</a>
<a class="sourceLine" id="cb33-15" data-line-number="15">processSubstitute xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-16" data-line-number="16">  putStrLn <span class="fu">$</span> unwords (<span class="st">&quot;unrecognized input:&quot;</span> <span class="fu">:</span> xs)</a></code></pre></div>
<p>In suggest mode, we’ll assume that a dictionary of named rewrite rules is kept in some external file consisting of lines of the form</p>
<pre><code>name TAB rulelhs = rulerhs</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">parseNamedRule ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">String</span>,(<span class="dt">Expr</span>,<span class="dt">Expr</span>))</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">parseNamedRule [name,r] <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  (x,y) <span class="ot">&lt;-</span> parseWithIO <span class="st">&quot;-&quot;</span> (pRule pLatexExpr) r</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  return (name,(x,y))</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">parseNamedRule xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">  putStrLn <span class="fu">$</span> unwords (<span class="st">&quot;unrecognized input:&quot;</span><span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  exitFailure</a></code></pre></div>
<p>We’ll also allow comment lines in the dictionary; these start with a <code>#</code> character and are ignored.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">comment ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">comment (<span class="ch">'#'</span><span class="fu">:</span>_) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">comment _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>We also assume backslashes are escaped in the dictionary because reasons.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unesc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">unesc (<span class="ch">'\\'</span><span class="fu">:</span><span class="ch">'\\'</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="ch">'\\'</span> <span class="fu">:</span> unesc xs</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">unesc (c<span class="fu">:</span>cs) <span class="fu">=</span> c <span class="fu">:</span> unesc cs</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">unesc [] <span class="fu">=</span> []</a></code></pre></div>
<p>It will be more useful if in suggest mode, we ignore parse errors. Suggestion mode marches down the rules in the dictionary, and if it finds one, emits a <code>sed</code> command to insert an annotation. This part is completely ad-hoc.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="ot">processSuggest ::</span> [(<span class="dt">String</span>,(<span class="dt">Expr</span>,<span class="dt">Expr</span>))] <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">processSuggest ((name,(x,y))<span class="fu">:</span>rs) [loc,line,a,b] <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">  lhs <span class="ot">&lt;-</span> <span class="kw">case</span> parseWith loc pLatexExpr a <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="dt">Left</span> _ <span class="ot">-&gt;</span> return (<span class="dt">Con</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="dt">Right</span> w <span class="ot">-&gt;</span> return w</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  rhs <span class="ot">&lt;-</span> <span class="kw">case</span> parseWith loc pLatexExpr b <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="dt">Left</span> _ <span class="ot">-&gt;</span> return (<span class="dt">Con</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">    <span class="dt">Right</span> w <span class="ot">-&gt;</span> return w</a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="kw">if</span> validateSymmetric (x,y) lhs rhs</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">    <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">        [ <span class="st">&quot;sed -i ''&quot;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">        , <span class="st">&quot;'&quot;</span><span class="fu">++</span>line<span class="fu">++</span><span class="st">&quot;s/^ &amp; = &amp; / \\&amp;     \\\\href{&quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;}~   = \\&amp; /'&quot;</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        , loc</a>
<a class="sourceLine" id="cb38-15" data-line-number="15">        ]</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">      <span class="kw">else</span> processSuggest rs [loc,line,a,b]</a>
<a class="sourceLine" id="cb38-17" data-line-number="17">processSuggest [] [_,_,_,_] <span class="fu">=</span> return ()</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">processSuggest _ xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb38-19" data-line-number="19">  putStrLn <span class="fu">$</span> unwords xs</a></code></pre></div>
<p>And <code>main</code>. In a departure from the unix philosophy, in verify mode we’ll report the number of checks made.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-5" data-line-number="5">    [<span class="st">&quot;--verify&quot;</span>] <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">      checks <span class="ot">&lt;-</span> fmap (map unTab <span class="fu">.</span> lines) getContents</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">      mapM_ processVerify checks</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">      hPutStrLn stderr <span class="fu">$</span> unwords [show <span class="fu">$</span> length checks, <span class="st">&quot;checks completed&quot;</span>]</a>
<a class="sourceLine" id="cb39-9" data-line-number="9"></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    [<span class="st">&quot;--substitute&quot;</span>] <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">      checks <span class="ot">&lt;-</span> fmap (map unTab <span class="fu">.</span> lines) getContents</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">      mapM_ processSubstitute checks</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">      hPutStrLn stderr <span class="fu">$</span> unwords [show <span class="fu">$</span> length checks, <span class="st">&quot;checks completed&quot;</span>]</a>
<a class="sourceLine" id="cb39-14" data-line-number="14"></a>
<a class="sourceLine" id="cb39-15" data-line-number="15">    [<span class="st">&quot;--suggest&quot;</span>, path] <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-16" data-line-number="16">      rules <span class="ot">&lt;-</span> (fmap (map unTab <span class="fu">.</span> filter (not <span class="fu">.</span> comment) <span class="fu">.</span> lines <span class="fu">.</span> unesc) <span class="fu">$</span> readFile path)</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">        <span class="fu">&gt;&gt;=</span> mapM parseNamedRule</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">      checks <span class="ot">&lt;-</span> fmap (map unTab <span class="fu">.</span> lines) getContents</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">      putStrLn <span class="st">&quot;#!/bin/bash&quot;</span></a>
<a class="sourceLine" id="cb39-20" data-line-number="20">      mapM_ (processSuggest rules) checks</a>
<a class="sourceLine" id="cb39-21" data-line-number="21"></a>
<a class="sourceLine" id="cb39-22" data-line-number="22">    _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">      putStrLn <span class="fu">$</span> unlines</a>
<a class="sourceLine" id="cb39-24" data-line-number="24">        [ <span class="st">&quot;usage:&quot;</span></a>
<a class="sourceLine" id="cb39-25" data-line-number="25">        , <span class="st">&quot;  --verify       : validate rewrites on stdin&quot;</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26">        , <span class="st">&quot;  --substitute   : validate substitutions on stdin&quot;</span></a>
<a class="sourceLine" id="cb39-27" data-line-number="27">        , <span class="st">&quot;  --suggest PATH : suggest rewrite rules from PATH on stdin&quot;</span></a>
<a class="sourceLine" id="cb39-28" data-line-number="28">        ]</a></code></pre></div>
<h1 id="testing">Testing</h1>
<p>The parts of this tool are complicated enough that I’ll feel better having some tests.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ot">test_main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">test_main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">  parseSuccessTests</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">  parseFailureTests</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">  substituteTests</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">  validationTests</a></code></pre></div>
<p>Parsing tests helpers:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="ot">testParseSuccess ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">testParseSuccess k (str,expr) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">  putStrLn <span class="fu">$</span> <span class="st">&quot;\nsuccess test &quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">  putStrLn str</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">  <span class="kw">case</span> parseWith <span class="st">&quot;&quot;</span> pLatexExpr str <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    <span class="dt">Left</span> msg <span class="ot">-&gt;</span> putStrLn msg <span class="fu">&gt;&gt;</span> exitFailure</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">    <span class="dt">Right</span> ex <span class="ot">-&gt;</span> <span class="kw">if</span> ex <span class="fu">==</span> expr</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">      <span class="kw">then</span> putStrLn <span class="st">&quot;ok&quot;</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">      <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-10" data-line-number="10">        putStrLn <span class="fu">$</span> unlines</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">          [ <span class="st">&quot;parse error:&quot;</span></a>
<a class="sourceLine" id="cb41-12" data-line-number="12">          , str</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">          , <span class="st">&quot;expected: &quot;</span> <span class="fu">++</span> show expr</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">          , <span class="st">&quot;actual:   &quot;</span> <span class="fu">++</span> show ex</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">          ]</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">        exitFailure</a>
<a class="sourceLine" id="cb41-17" data-line-number="17"></a>
<a class="sourceLine" id="cb41-18" data-line-number="18"><span class="ot">testParseFailure ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb41-19" data-line-number="19">testParseFailure k str <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-20" data-line-number="20">  putStrLn <span class="fu">$</span> <span class="st">&quot;\nfailure test &quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb41-21" data-line-number="21">  putStrLn str</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">  <span class="kw">case</span> parseWith <span class="st">&quot;&quot;</span> pLatexExpr str <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-23" data-line-number="23">    <span class="dt">Right</span> ex <span class="ot">-&gt;</span> putStrLn (show ex) <span class="fu">&gt;&gt;</span> exitFailure</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">    <span class="dt">Left</span> _   <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;ok&quot;</span></a></code></pre></div>
<p>Parsing test cases:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">parseSuccessTests ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">parseSuccessTests <span class="fu">=</span> sequence_ <span class="fu">$</span> zipWith testParseSuccess [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  [ (<span class="st">&quot;f&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;f&quot;</span>)</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">  , (<span class="st">&quot;\\f&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;f&quot;</span>)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">  , (<span class="st">&quot;f(x)&quot;</span>, <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-6" data-line-number="6">  , (<span class="st">&quot;\\f(x)&quot;</span>, <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">  , (<span class="st">&quot;f(\\x)&quot;</span>, <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-8" data-line-number="8">  , (<span class="st">&quot;\\f(\\x)&quot;</span>, <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-9" data-line-number="9">  , (<span class="st">&quot;f{x}&quot;</span>, <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-10" data-line-number="10">  , (<span class="st">&quot;\\f{x}&quot;</span>, <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-11" data-line-number="11">  , (<span class="st">&quot;f{\\x}&quot;</span>, <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-12" data-line-number="12">  , (<span class="st">&quot;\\f{\\x}&quot;</span>, <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb42-13" data-line-number="13">  , (<span class="st">&quot;f(x,y)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb42-14" data-line-number="14">  , (<span class="st">&quot;\\f(x,y)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb42-15" data-line-number="15">  , (<span class="st">&quot;f(x)(y)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb42-16" data-line-number="16">  , (<span class="st">&quot;f{x}(y)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">  , (<span class="st">&quot;f(x,y)(z)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>))</a>
<a class="sourceLine" id="cb42-18" data-line-number="18">  , (<span class="st">&quot;f(x)(y,z)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>))</a>
<a class="sourceLine" id="cb42-19" data-line-number="19">  , (<span class="st">&quot;f{x,y}(z)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>))</a>
<a class="sourceLine" id="cb42-20" data-line-number="20">  , (<span class="st">&quot;f{x}(y,z)&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>))</a>
<a class="sourceLine" id="cb42-21" data-line-number="21">  , (<span class="st">&quot;f(x)(g(y))&quot;</span>, <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)))</a>
<a class="sourceLine" id="cb42-22" data-line-number="22">  ]</a>
<a class="sourceLine" id="cb42-23" data-line-number="23"></a>
<a class="sourceLine" id="cb42-24" data-line-number="24"><span class="ot">parseFailureTests ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb42-25" data-line-number="25">parseFailureTests <span class="fu">=</span> sequence_ <span class="fu">$</span> zipWith testParseFailure [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb42-26" data-line-number="26">  [ <span class="st">&quot;#&quot;</span></a>
<a class="sourceLine" id="cb42-27" data-line-number="27">  , <span class="st">&quot;f(x&quot;</span></a>
<a class="sourceLine" id="cb42-28" data-line-number="28">  , <span class="st">&quot;f(x}&quot;</span></a>
<a class="sourceLine" id="cb42-29" data-line-number="29">  , <span class="st">&quot;\\fx)&quot;</span></a>
<a class="sourceLine" id="cb42-30" data-line-number="30">  , <span class="st">&quot;\\f(x,)&quot;</span></a>
<a class="sourceLine" id="cb42-31" data-line-number="31">  , <span class="st">&quot;\\f(,x)&quot;</span></a>
<a class="sourceLine" id="cb42-32" data-line-number="32">  ]</a></code></pre></div>
<p>Substitution test helper:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">testSubstitution ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Substitution</span>, <span class="dt">Expr</span>, <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">testSubstitution k (sub,e1,e2) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">  putStrLn <span class="fu">$</span> <span class="st">&quot;\nsubstitution test &quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">  putStrLn <span class="fu">$</span> show sub</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">  putStrLn <span class="fu">$</span> latex e1</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">  <span class="kw">if</span> e2 <span class="fu">==</span> substitute sub e1</a>
<a class="sourceLine" id="cb43-7" data-line-number="7">    <span class="kw">then</span> putStrLn <span class="st">&quot;ok&quot;</span></a>
<a class="sourceLine" id="cb43-8" data-line-number="8">    <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9">      putStrLn <span class="fu">$</span> unlines</a>
<a class="sourceLine" id="cb43-10" data-line-number="10">        [ <span class="st">&quot;substitution error:&quot;</span></a>
<a class="sourceLine" id="cb43-11" data-line-number="11">        , <span class="st">&quot;expected: &quot;</span> <span class="fu">++</span> show e2</a>
<a class="sourceLine" id="cb43-12" data-line-number="12">        , <span class="st">&quot;actual:   &quot;</span> <span class="fu">++</span> show (substitute sub e1)</a>
<a class="sourceLine" id="cb43-13" data-line-number="13">        ]</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">      exitFailure</a></code></pre></div>
<p>Substitution test cases:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">substituteTests ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">substituteTests <span class="fu">=</span> sequence_ <span class="fu">$</span> zipWith testSubstitution [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  [ ([], <span class="dt">Con</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">  , ([(<span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;b&quot;</span>)], <span class="dt">Var</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">  , ([(<span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;b&quot;</span>)], <span class="dt">Con</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">  , ([(<span class="st">&quot;a&quot;</span>, <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))], <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>), <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">  , ([(<span class="st">&quot;a&quot;</span>, <span class="dt">Con</span> <span class="st">&quot;x&quot;</span>)], <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>), <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">  , ([(<span class="st">&quot;x&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)], <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>), <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">  , ([(<span class="st">&quot;x&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)], <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>), <span class="dt">App</span> (<span class="dt">Con</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">  ]</a></code></pre></div>
<p>Validation test helper:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="ot">testValidate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Rule</span>, <span class="dt">Expr</span>, <span class="dt">Expr</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb45-2" data-line-number="2">testValidate k (rule,e1,e2,result) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">  putStrLn <span class="fu">$</span> <span class="st">&quot;\nvalidation test &quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">  putStrLn <span class="fu">$</span> show rule</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">  putStrLn <span class="fu">$</span> latex e1</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">  putStrLn <span class="fu">$</span> latex e2</a>
<a class="sourceLine" id="cb45-7" data-line-number="7">  <span class="kw">if</span> result <span class="fu">==</span> validate rule e1 e2</a>
<a class="sourceLine" id="cb45-8" data-line-number="8">    <span class="kw">then</span> putStrLn <span class="st">&quot;ok&quot;</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9">    <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-10" data-line-number="10">      putStrLn <span class="st">&quot;validation error!&quot;</span></a>
<a class="sourceLine" id="cb45-11" data-line-number="11">      exitFailure</a></code></pre></div>
<p>Validation test cases:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">validationTests ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">validationTests <span class="fu">=</span> sequence_ <span class="fu">$</span> zipWith testValidate [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  [</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">  ]</a></code></pre></div>


<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
