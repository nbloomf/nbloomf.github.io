<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Balancing Parentheses</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<link rel="icon" href="../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../pages/about.html">About</a>
    <a href="../pages/projects.html">Projects</a>
    <a href="../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Balancing Parentheses</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2018-01-16 by nbloomf
</div>


<div class="info tags">Tags: <a href="../tag/literate-haskell.html">literate-haskell</a></div>


<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/2018-01-16-balancing-parentheses.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">BalanceDelimiters</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Tuple</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">System.Exit</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">System.Environment</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">System.Console.GetOpt</span></a></code></pre></div>
<p>Let’s make a tool to find unbalanced parentheses.</p>
<p>What does it mean for the parentheses in a string to be balanced? We could come up with a recursive definition, like</p>
<ol type="1">
<li>If <span class="math inline">\(u\)</span> does not contain either <code>'('</code> or <code>')'</code>, then <span class="math inline">\(u\)</span> is balanced;</li>
<li>If <span class="math inline">\(u\)</span> is balanced, then <span class="math inline">\((u)\)</span> is balanced; and</li>
<li>If <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are balanced, then <span class="math inline">\(uv\)</span> is balanced.</li>
</ol>
<p>We can use these rules to construct balanced strings one step at a time. For example,</p>
<ul>
<li><code>&quot;a&quot;</code> is balanced (rule 1)</li>
<li><code>&quot;&quot;</code> is balanced (rule 1)</li>
<li><code>&quot;()&quot;</code> is balanced (rule 2, <span class="math inline">\(u = \texttt{&quot;&quot;}\)</span>)</li>
<li><code>&quot;a()&quot;</code> is balanced (rule 3, <span class="math inline">\(u = \texttt{&quot;a&quot;}\)</span> and <span class="math inline">\(v = \texttt{&quot;()&quot;}\)</span>)</li>
<li><code>&quot;(a())&quot;</code> is balanced (rule 2, <span class="math inline">\(u = \texttt{&quot;a()&quot;}\)</span>)</li>
<li>…</li>
</ul>
<p>But what if we want to <em>detect</em> balanced strings? We can do that with a stack. Consume the first character (or “token”) of the string; if it is an open parenthesis, push it onto the stack; if it is a closing parenthesis try to pop a previously pushed opening parenthesis off of the stack (if we can’t, there’s a closing paren with no opening paren); if it is neither, throw it away. Recurse on the remainder of the string until it is empty. If the stack is not empty at the end, there is an opening paren with no closing paren.</p>
<p>The pattern here matches a fold over the input string, taken as a list of tokens. We generalize the process of consuming a single character slightly as <code>checkToken1</code>; this map takes (1) a pair represening the opening and closing tokens, (2) a stack, and (3) a single token, and returns an updated stack. The return type is a <code>Maybe</code> to account for the failure case where we attempt to pop an empty stack.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">checkToken1 ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a,a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">checkToken1 (open,close) stack token <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">if</span> token <span class="fu">==</span> open</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="kw">then</span> <span class="dt">Just</span> (open<span class="fu">:</span>stack)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="kw">else</span> <span class="kw">if</span> token <span class="fu">==</span> close</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="kw">then</span> <span class="kw">case</span> stack <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        (w<span class="fu">:</span>ws) <span class="ot">-&gt;</span> <span class="kw">if</span> open <span class="fu">==</span> w <span class="kw">then</span> <span class="dt">Just</span> ws <span class="kw">else</span> <span class="dt">Just</span> stack</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      <span class="kw">else</span> <span class="dt">Just</span> stack</a></code></pre></div>
<p>Wrapping <code>checkToken1</code> in a monadic fold, with an empty stack as the base value, we can balance strings.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">balance1 ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (a,a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">balance1 ds <span class="fu">=</span> foldM (checkToken1 ds) []</a></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">$&gt;</span> balance1 (<span class="ch">'('</span>,<span class="ch">')'</span>) <span class="st">&quot;hello world&quot;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dt">Just</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">$&gt;</span> balance1 (<span class="ch">'('</span>,<span class="ch">')'</span>) <span class="st">&quot;hello w(orld&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dt">Just</span> <span class="st">&quot;(&quot;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">$&gt;</span> balance1 (<span class="ch">'('</span>,<span class="ch">')'</span>) <span class="st">&quot;hello w(or)ld&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dt">Just</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="fu">$&gt;</span> balance1 (<span class="ch">'('</span>,<span class="ch">')'</span>) <span class="st">&quot;hello w(or)l)d&quot;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="fu">$&gt;</span> balance1 (<span class="ch">'('</span>,<span class="ch">')'</span>) <span class="st">&quot;hell(o w(or)l)d&quot;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="dt">Just</span> <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>Note the two different failure cases. <code>Nothing</code> means we have an unbalanced closing paren, and <code>Just (_:_)</code> means we have an unbalanced opening paren.</p>
<p>Neat!</p>
<p>But can we do better? This program has some weaknesses that make it less than ideal for my needs.</p>
<ol type="1">
<li>It can only handle one set of delimiters. In practice, text will have delimiters of several kinds, which can be nested inside each other. For instance, we’d like <code>&quot;(){}&quot;</code> to be balanced, as well as <code>&quot;({})&quot;</code>, but not <code>&quot;({)}&quot;</code>.</li>
<li>It can only handle delimiters consisting of a single character, at least, not without tokenizing the input string first.</li>
<li>It can only tell us whether an unbalanced delimiter exists; it doesn’t tell us where it is.</li>
</ol>
<p>It won’t take much to beef up <code>balance1</code> to handle these issues.</p>
<p>First, let’s deal with the problem of specifying locations in text. I can think of two basic scenarios: (1) we have a single line of text and want to specify the column number of a single character, and (2) we have several lines of text and want to specify the line and column numbers of a single character.</p>
<p>In the first case, we want to turn a <code>[a]</code> into something like <code>[(a,Int)]</code>. The standard <code>zip</code> can handle this.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">num ::</span> [a] <span class="ot">-&gt;</span> [(a,<span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">num xs <span class="fu">=</span> zip xs [<span class="dv">1</span><span class="fu">..</span>]</a></code></pre></div>
<p>Thinking of <code>[a]</code> as a list of graphemes, <code>num</code> just attaches each grapheme to its index in the list.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">$&gt;</span> num <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">[(<span class="ch">'h'</span>,<span class="dv">1</span>),(<span class="ch">'e'</span>,<span class="dv">2</span>),(<span class="ch">'l'</span>,<span class="dv">3</span>),(<span class="ch">'l'</span>,<span class="dv">4</span>),(<span class="ch">'o'</span>,<span class="dv">5</span>)]</a></code></pre></div>
<p>In the second case, we want to turn a <code>[[a]]</code> into something like <code>[(a,(Int,Int))]</code>. This is a little more complicated (but not much).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">lineCol ::</span> [[a]] <span class="ot">-&gt;</span> [(a,(<span class="dt">Int</span>,<span class="dt">Int</span>))]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">lineCol xss <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  concatMap (\(xs,i) <span class="ot">-&gt;</span> map (\(x,j) <span class="ot">-&gt;</span> (x,(i,j))) xs) <span class="fu">$</span> num (map num xss)</a></code></pre></div>
<p>for example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">$&gt;</span> lineCol [<span class="st">&quot;hello&quot;</span>,<span class="st">&quot;world&quot;</span>]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[(<span class="ch">'h'</span>,(<span class="dv">1</span>,<span class="dv">1</span>)),(<span class="ch">'e'</span>,(<span class="dv">1</span>,<span class="dv">2</span>)),(<span class="ch">'l'</span>,(<span class="dv">1</span>,<span class="dv">3</span>)),(<span class="ch">'l'</span>,(<span class="dv">1</span>,<span class="dv">4</span>)),(<span class="ch">'o'</span>,(<span class="dv">1</span>,<span class="dv">5</span>))</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">,(<span class="ch">'w'</span>,(<span class="dv">2</span>,<span class="dv">1</span>)),(<span class="ch">'o'</span>,(<span class="dv">2</span>,<span class="dv">2</span>)),(<span class="ch">'r'</span>,(<span class="dv">2</span>,<span class="dv">3</span>)),(<span class="ch">'l'</span>,(<span class="dv">2</span>,<span class="dv">4</span>)),(<span class="ch">'d'</span>,(<span class="dv">2</span>,<span class="dv">5</span>))]</a></code></pre></div>
<p>In general, we’d like to balance a string against a set of pairs of delimiting <em>substrings</em>. To do this with a strategy like <code>balance1</code> we’ll need to tokenize the input stream. In this simplified model, our delimiting substrings are tokens, as are any single characters that are not at the head of a delimiting substring. For example, if we’re balancing the delimiters <code>(</code>, <code>)</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>, then the string</p>
<pre><code>(hey&lt;&lt;woo&gt;)</code></pre>
<p>should tokenize as</p>
<pre><code>'(' 'h' 'e' 'y' '&lt;&lt;' 'w' 'o' 'o' '&gt;' ')'</code></pre>
<p>The usual way to do this is to check, for each delimiter, whether it is a prefix of the input stream, and if so, strip it away. Note that our input stream comes equipped with location data, so it will have type <code>[(a,t)]</code> for some location type <code>t</code>, while the delimiter tokens each have type <code>[a]</code>. The <code>stripPrefixMap</code> function will detect and remove prefix tokens. Note the return type; <code>Nothing</code> means the given token was not a prefix, and <code>Just bs</code> returns the remainder of the input after the token is removed.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">stripPrefixMap ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [b]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">stripPrefixMap f x y <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  [] <span class="ot">-&gt;</span> <span class="dt">Just</span> y</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  (a<span class="fu">:</span>as) <span class="ot">-&gt;</span> <span class="kw">case</span> y <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    (b<span class="fu">:</span>bs) <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">==</span> (f b)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">      <span class="kw">then</span> stripPrefixMap f as bs</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">      <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Next, <code>stripToken</code> takes a list of tokens and an input stream, and returns either a pair consisting of the first token (and the location of its first grapheme) and the remainder of the input stream, or nothing if the input stream is empty.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">stripToken ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [(a,t)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (([a],t), [(a,t)])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">stripToken tokens stream <span class="fu">=</span> <span class="kw">case</span> stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  ((x,u)<span class="fu">:</span>zs) <span class="ot">-&gt;</span> <span class="kw">case</span> tokens <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    [] <span class="ot">-&gt;</span> <span class="dt">Just</span> (([x],u), zs)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    (t<span class="fu">:</span>ts) <span class="ot">-&gt;</span> <span class="kw">case</span> stripPrefixMap fst t stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> stripToken ts stream</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">      <span class="dt">Just</span> ws <span class="ot">-&gt;</span> <span class="dt">Just</span> ((t,u), ws)</a></code></pre></div>
<p>Finally, <code>stripToken</code> has the appropriate type so that <code>tokenize</code> is an <code>unfoldr</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">tokenize ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [(a,t)] <span class="ot">-&gt;</span> [([a],t)]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">tokenize ts <span class="fu">=</span> unfoldr (stripToken ts)</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">$&gt;</span> tokenize [<span class="st">&quot;(&quot;</span>,<span class="st">&quot;)&quot;</span>] (num <span class="st">&quot;hi(woo)&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">[(<span class="st">&quot;h&quot;</span>,<span class="dv">1</span>),(<span class="st">&quot;i&quot;</span>,<span class="dv">2</span>),(<span class="st">&quot;(&quot;</span>,<span class="dv">3</span>),(<span class="st">&quot;w&quot;</span>,<span class="dv">4</span>),(<span class="st">&quot;o&quot;</span>,<span class="dv">5</span>),(<span class="st">&quot;o&quot;</span>,<span class="dv">6</span>),(<span class="st">&quot;)&quot;</span>,<span class="dv">7</span>)]</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="fu">$&gt;</span> tokenize [<span class="st">&quot;&lt;&lt;&quot;</span>,<span class="st">&quot;&amp;&amp;&quot;</span>] (num <span class="st">&quot;&lt;hi&amp;&amp;k&lt;&lt;&quot;</span>)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">[(<span class="st">&quot;&lt;&quot;</span>,<span class="dv">1</span>),(<span class="st">&quot;h&quot;</span>,<span class="dv">2</span>),(<span class="st">&quot;i&quot;</span>,<span class="dv">3</span>),(<span class="st">&quot;&amp;&amp;&quot;</span>,<span class="dv">4</span>),(<span class="st">&quot;k&quot;</span>,<span class="dv">6</span>),(<span class="st">&quot;&lt;&lt;&quot;</span>,<span class="dv">7</span>)]</a></code></pre></div>
<p>Now the old <code>checkToken1</code> only nees a couple of adaptations to work on multiple delimiters. The failure cases are a little more complicated; now we can have a close with no open, an open with no close, or a close with a mismatched open.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">checkToken ::</span> (<span class="dt">Eq</span> a)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">=&gt;</span> [(a,a)]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">-&gt;</span> [(a,t)]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">-&gt;</span> (a,t)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Either</span> (a,t) ((a,t),(a,t))) [(a,t)]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">checkToken ds z (x,t) <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">case</span> lookup x ds <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="dt">Just</span> y <span class="ot">-&gt;</span> <span class="dt">Right</span> ((x,t)<span class="fu">:</span>z) <span class="co">-- opening delimiter found</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> lookup x (map swap ds) <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">      <span class="dt">Just</span> y <span class="ot">-&gt;</span> <span class="kw">case</span> z <span class="kw">of</span> <span class="co">-- closing delimiter found</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">        [] <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="dt">Left</span> (x,t)) <span class="co">-- close with no open</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">        ((w,u)<span class="fu">:</span>ws) <span class="ot">-&gt;</span> <span class="kw">if</span> w <span class="fu">==</span> y</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">          <span class="kw">then</span> <span class="dt">Right</span> ws</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">          <span class="kw">else</span> <span class="dt">Left</span> (<span class="dt">Right</span> ((x,t),(w,u))) <span class="co">-- close with mismatched open</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> z</a></code></pre></div>
<p>The shape of <code>checkToken</code> is right for <code>foldM</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">balance ::</span> (<span class="dt">Eq</span> a)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="ot">=&gt;</span> [(a,a)]</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="ot">-&gt;</span> [(a,t)]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Either</span> (a,t) ((a,t),(a,t))) [(a,t)]</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">balance ds <span class="fu">=</span> foldM (checkToken ds) []</a></code></pre></div>
<p>And a helper to turn our list of paired delimiters into a list of tokens:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">flat ::</span> [(a,a)] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">flat [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">flat ((a,b)<span class="fu">:</span>xs) <span class="fu">=</span> a<span class="fu">:</span>b<span class="fu">:</span>(flat xs)</a></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="fu">$&gt;</span> <span class="kw">let</span> ds <span class="fu">=</span> [(<span class="st">&quot;(&quot;</span>,<span class="st">&quot;)&quot;</span>),(<span class="st">&quot;&lt;&lt;&quot;</span>,<span class="st">&quot;&gt;&gt;&quot;</span>)]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="dt">Right</span> []</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;hello(&quot;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="dt">Right</span> [(<span class="st">&quot;(&quot;</span>,<span class="dv">6</span>)]</a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;hel)lo&quot;</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="dt">Left</span> (<span class="dt">Left</span> (<span class="st">&quot;)&quot;</span>,<span class="dv">4</span>))</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;h(e)llo&quot;</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"><span class="dt">Right</span> []</a>
<a class="sourceLine" id="cb18-10" data-line-number="10"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;h&lt;&lt;ello&quot;</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="dt">Right</span> [(<span class="st">&quot;&lt;&lt;&quot;</span>,<span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="fu">$&gt;</span> balance ds <span class="fu">$</span> tokenize (flat ds) <span class="fu">$</span> num <span class="st">&quot;h&lt;&lt;el)lo&quot;</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="dt">Left</span> (<span class="dt">Right</span> ((<span class="st">&quot;)&quot;</span>,<span class="dv">6</span>),(<span class="st">&quot;&lt;&lt;&quot;</span>,<span class="dv">2</span>)))</a></code></pre></div>
<p>Again, note the three different failure cases. We’ll wrap this behind a function.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">balanceDelimiters ::</span> (<span class="dt">Eq</span> a)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="ot">=&gt;</span> [([a],[a])]  <span class="co">-- paired delimiters</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="ot">-&gt;</span> [(a,t)]      <span class="co">-- stream of graphemes with location data</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Either</span> ([a],t) (([a],t),([a],t))) [([a],t)]</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">balanceDelimiters ds <span class="fu">=</span> balance ds <span class="fu">.</span> tokenize (flat ds)</a></code></pre></div>
<p>Now to wire this function into the shell. Before we can do this, two questions need answers.</p>
<ol type="1">
<li>Should we balance the entire input, or balance each line separately? We’ll use a flag to toggle this, with “entire input” as the default.</li>
<li>What delimiters should we balance? We’ll use an optional parameter to set this, with a reasonable default.</li>
</ol>
<p>We’ll use a type to represent these options.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Flags</span> <span class="fu">=</span> <span class="dt">Flags</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  {<span class="ot"> lineMode  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  ,<span class="ot"> delimiter ::</span> [(<span class="dt">String</span>,<span class="dt">String</span>)]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  } <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="ot">defaultFlags ::</span> <span class="dt">Flags</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">defaultFlags <span class="fu">=</span> <span class="dt">Flags</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  { lineMode  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  , delimiter <span class="fu">=</span> [(<span class="st">&quot;(&quot;</span>,<span class="st">&quot;)&quot;</span>),(<span class="st">&quot;{&quot;</span>,<span class="st">&quot;}&quot;</span>),(<span class="st">&quot;[&quot;</span>,<span class="st">&quot;]&quot;</span>)]</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  }</a></code></pre></div>
<p>We’ll use the <code>GetOpt</code> library to handle parsing command line options.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">options ::</span> [<span class="dt">OptDescr</span> (<span class="dt">Flags</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Flags</span>)]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">options <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  [ <span class="dt">Option</span> [<span class="ch">'l'</span>] [<span class="st">&quot;lines&quot;</span>]</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">      (<span class="dt">NoArg</span> (\opts <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> opts { lineMode <span class="fu">=</span> <span class="dt">True</span> }))</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      <span class="st">&quot;balance each input line separately&quot;</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  , <span class="dt">Option</span> [<span class="ch">'d'</span>] [<span class="st">&quot;delimiters&quot;</span>]</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">      (<span class="dt">ReqArg</span> readDelimiters <span class="st">&quot;STR&quot;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="st">&quot;delimiter pairs, as a space-delimited string&quot;</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">  ]</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">    readDelimiters str opts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">      ds <span class="ot">&lt;-</span> readPairs (words str)</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">      return <span class="fu">$</span> opts { delimiter <span class="fu">=</span> ds }</a>
<a class="sourceLine" id="cb21-15" data-line-number="15"></a>
<a class="sourceLine" id="cb21-16" data-line-number="16"><span class="ot">    readPairs ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [(<span class="dt">String</span>,<span class="dt">String</span>)]</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">    readPairs z <span class="fu">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">      [] <span class="ot">-&gt;</span> <span class="dt">Just</span> []</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">      [_] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-20" data-line-number="20">      (x<span class="fu">:</span>y<span class="fu">:</span>xs) <span class="ot">-&gt;</span> fmap ((x,y)<span class="fu">:</span>) <span class="fu">$</span> readPairs xs</a></code></pre></div>
<p>Some helpers for error messages.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">putLoc ::</span> (<span class="dt">Show</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">putLoc path line col <span class="fu">=</span> concat</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  [path, <span class="st">&quot;:&quot;</span>, show line, <span class="st">&quot;:&quot;</span>, show col]</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">quote ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">quote str <span class="fu">=</span> <span class="st">&quot;'&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;'&quot;</span></a></code></pre></div>
<p>Now <code>balanceFile</code> handles checking entire files…</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">balanceFile ::</span> FilePath <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">balanceFile path ds text <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">case</span> balanceDelimiters ds (fileLoc text) <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Left</span> (<span class="dt">Left</span> (d,(i,j))) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        [ putLoc path i j, <span class="st">&quot;unbalanced closing delimiter&quot;</span>, quote d ]</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> (lines text)<span class="fu">!!</span>i</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    <span class="dt">Left</span> (<span class="dt">Right</span> ((d,(i,j)),(e,(h,k)))) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        [ putLoc path i j, <span class="st">&quot;closing delimiter&quot;</span>, quote d</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">        , <span class="st">&quot;does not match opening&quot;</span>, quote e, <span class="st">&quot;at&quot;</span>, show h <span class="fu">++</span> <span class="st">&quot;:&quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">        ]</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> (lines text)<span class="fu">!!</span>i</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="dt">Right</span> ((d,(i,j))<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        [ putLoc path i j, <span class="st">&quot;unbalanced opening delimiter&quot;</span>, quote d ]</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> (lines text)<span class="fu">!!</span>i</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">    <span class="dt">Right</span> [] <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    err (i,j) <span class="fu">=</span> <span class="st">&quot;line &quot;</span> <span class="fu">++</span> show i <span class="fu">++</span> <span class="st">&quot; column &quot;</span> <span class="fu">++</span> show j</a></code></pre></div>
<p>(<code>fileLoc</code> is an improvement over <code>lineCol</code> that won’t allow matches of multi-character delimiters across newlines.)</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">fileLoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">Char</span>,(<span class="dt">Int</span>,<span class="dt">Int</span>))]</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">fileLoc str <span class="fu">=</span> unfoldr next (str,(<span class="dv">1</span>,<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4"><span class="ot">    next ::</span> ([<span class="dt">Char</span>],(<span class="dt">Int</span>,<span class="dt">Int</span>))</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ((<span class="dt">Char</span>,(<span class="dt">Int</span>,<span class="dt">Int</span>)), ([<span class="dt">Char</span>],(<span class="dt">Int</span>,<span class="dt">Int</span>)))</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    next (str,(row,col)) <span class="fu">=</span> <span class="kw">case</span> str <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">      [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">      (c<span class="fu">:</span>cs) <span class="ot">-&gt;</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="ch">'\n'</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">        <span class="kw">then</span> <span class="dt">Just</span> ((c,(row,col)),(cs,(row<span class="fu">+</span><span class="dv">1</span>,<span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">        <span class="kw">else</span> <span class="dt">Just</span> ((c,(row,col)),(cs,(row,col<span class="fu">+</span><span class="dv">1</span>)))</a></code></pre></div>
<p>…and <code>balanceLines</code> handles checking each line separately.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">balanceLines ::</span> FilePath <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)] <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">balanceLines path ds <span class="fu">=</span> sequence_ <span class="fu">.</span> zipWith (balanceLine path ds) [<span class="dv">1</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">balanceLine ::</span> FilePath <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">balanceLine path ds k text <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  <span class="kw">case</span> balanceDelimiters ds (num text) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    <span class="dt">Left</span> (<span class="dt">Left</span> (d,t)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        [ putLoc path k t, <span class="st">&quot;unbalanced closing delimiter&quot;</span>, quote d ]</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> text</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    <span class="dt">Left</span> (<span class="dt">Right</span> ((d,t),(e,u))) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb25-13" data-line-number="13">        [ putLoc path k t, <span class="st">&quot;closing delimiter&quot;</span>, quote d</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">        , <span class="st">&quot;does not match opening&quot;</span>, quote e, <span class="st">&quot;at column&quot;</span>, show u</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        ]</a>
<a class="sourceLine" id="cb25-16" data-line-number="16">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> text</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">    <span class="dt">Right</span> ((d,t)<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      putStrLn <span class="fu">$</span> unwords</a>
<a class="sourceLine" id="cb25-19" data-line-number="19">        [ putLoc path k t, <span class="st">&quot;unbalanced opening delimiter&quot;</span>, quote d ]</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">      putStrLn <span class="fu">$</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span> <span class="fu">++</span> text</a>
<a class="sourceLine" id="cb25-21" data-line-number="21">    <span class="dt">Right</span> [] <span class="ot">-&gt;</span> return ()</a></code></pre></div>
<p>Now <code>main</code> is straightforward enough; we read the command line arguments and call either <code>balanceFile</code> or <code>balanceLines</code>, depending.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    argErr <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">      putStr <span class="fu">$</span> usageInfo <span class="st">&quot;options&quot;</span> options</a>
<a class="sourceLine" id="cb26-8" data-line-number="8"></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">  <span class="co">-- read command line arguments</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">  (flag, filenames) <span class="ot">&lt;-</span> <span class="kw">case</span> getOpt <span class="dt">Permute</span> options args <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11">      (opts, rest, []) <span class="ot">-&gt;</span> <span class="kw">case</span> foldl (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Just</span> defaultFlags) opts <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure</a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        <span class="dt">Just</span> fs <span class="ot">-&gt;</span> return (fs, rest)</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">      otherwise <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure</a>
<a class="sourceLine" id="cb26-15" data-line-number="15"></a>
<a class="sourceLine" id="cb26-16" data-line-number="16">  <span class="kw">let</span> ds <span class="fu">=</span> delimiter flag</a>
<a class="sourceLine" id="cb26-17" data-line-number="17"></a>
<a class="sourceLine" id="cb26-18" data-line-number="18">  <span class="kw">case</span> (lineMode flag, filenames) <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-19" data-line-number="19">    <span class="co">-- use stdin</span></a>
<a class="sourceLine" id="cb26-20" data-line-number="20">    (<span class="dt">False</span>, []) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-21" data-line-number="21">      getContents <span class="fu">&gt;&gt;=</span> balanceFile <span class="st">&quot;stdin&quot;</span> ds</a>
<a class="sourceLine" id="cb26-22" data-line-number="22"></a>
<a class="sourceLine" id="cb26-23" data-line-number="23">    (<span class="dt">False</span>, _) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-24" data-line-number="24">      <span class="kw">let</span> process name <span class="fu">=</span> readFile name <span class="fu">&gt;&gt;=</span> balanceFile name ds</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">      sequence_ <span class="fu">$</span> map process filenames</a>
<a class="sourceLine" id="cb26-26" data-line-number="26"></a>
<a class="sourceLine" id="cb26-27" data-line-number="27">    (<span class="dt">True</span>, []) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-28" data-line-number="28">      (fmap lines getContents) <span class="fu">&gt;&gt;=</span> balanceLines <span class="st">&quot;stdin&quot;</span> ds</a>
<a class="sourceLine" id="cb26-29" data-line-number="29"></a>
<a class="sourceLine" id="cb26-30" data-line-number="30">    (<span class="dt">True</span>, _) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-31" data-line-number="31">      <span class="kw">let</span> process name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-32" data-line-number="32">            (fmap lines <span class="fu">$</span> readFile name) <span class="fu">&gt;&gt;=</span> balanceLines name ds</a>
<a class="sourceLine" id="cb26-33" data-line-number="33">      sequence_ <span class="fu">$</span> map process filenames</a>
<a class="sourceLine" id="cb26-34" data-line-number="34"></a>
<a class="sourceLine" id="cb26-35" data-line-number="35">  return ()</a></code></pre></div>


<!-- END CONTENT -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
