<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell: compress, expand, crypt</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../about.html">About</a>
    <a href="../contact.html">Contact</a>
    <a href="../archive.html">Posts</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: compress, expand, crypt</h1>
<!-- BEGIN BODY -->
<div class="info">
Posted on 2016-03-02 by nbloomf
</div>

<!-- LaTeX Macros -->
<div class="invisible">
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\primrec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)

\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{t}}\)
\(\newcommand{\bfalse}{\mathsf{f}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathsf{and}}\)
\(\newcommand{\bor}{\mathsf{or}}\)
</div>
<!-- End LaTeX Macros -->

<p>This post is part of the <a href="../posts/2016-02-10-software-tools-in-haskell.html">Software Tools in Haskell</a> series.</p>
<p><a name="compress"></a></p>
<h2 id="compress-compress-stdin-run-length-encoding"><code>compress</code>: compress stdin (run length encoding)</h2>
<p>In a list of characters, a <em>run</em> is a sublist of characters which are all the same. For example, the list</p>
<pre><code>bookkeeper</code></pre>
<p>has three runs, each of two characters. If a list contains many long runs, it can be losslessly compressed using a technique called <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run length encoding</a>. With such a scheme, instead of storing a literal run like <code>aaaaaaa</code> we store the repeated character and the number of times it repeats. Kernighan and Plauger do this by breaking a sequence of characters into two kinds of sublists: <em>runs</em>, sublists of repeated characters (longer than some threshold length), and <em>chunks</em>, sublists containing no runs. The run length encoding scheme in <em>Software Tools</em> then transforms a stream of characters into blocks of the form</p>
<pre><code>(symbol denoting repeat)
(character to be repeated)
(repeat count)</code></pre>
<p>and</p>
<pre><code>(chunk count)
(list of that many characters)</code></pre>
<p>Where (symbol denoting repeat) is a special character, which we will call the <strong>sigil</strong>. Let’s tweak this scheme just slightly. As K&amp;P point out, no compression scheme can perform well on all input (in fact every compression scheme must make some inputs <em>bigger</em>). But we are wise to consider “how bad it gets when it gets bad”. How bad does this scheme get? The worst possible input for a run length encoding scheme is one with no runs at all, since there are no opportunities for compression. But notice what happens in this case; the entire input is a “chunk”, and so must be encoded with its count. The amount of space required to store an arbitrarily large integer, regardless of the scheme required, is proportional to its number of digits. (We can make that proportion smaller by choosing a larger base, but only to a point.) That means an input stream of length <span class="math inline">\(n\)</span> with no runs will require about <span class="math inline">\(\log(n)\)</span> characters just to store the chunk count, for a “compressed” file size of about <span class="math inline">\(n + \log(n)\)</span>. Not great!</p>
<p>What if, instead of keeping track of both chunk sizes and repeat counts, we only keep track of repeat counts and reuse the sigil to also denote the <em>end</em> of the repeat count. This way, an encoded stream looks like a stream of</p>
<pre><code>(sigil)
(character to be repeated)
(repeat count)
(sigil)</code></pre>
<p>and</p>
<pre><code>(characters not including the sigil)</code></pre>
<p>Of course now we also need to provide a way to encode literal instances of the sigil. What is the simplest way to do this? All characters <em>other than</em> the sigil are interpreted literally, unless we want to introduce another escape character. We can’t use a single sigil, since that means “start a new encoded run”. And we cannot use two sigils, because that means “start a new encoded run of sigils”. But three copies of the sigil character in a row does not mean anything, if we remember not to use the sigil character to encode numbers. So we interpret the string</p>
<pre><code>(sigil)(sigil)(sigil)</code></pre>
<p>to mean a literally encoded sigil. (Note that it is then more space efficient to encode two or more literal sigils as a run. (Two literal sigils is 6 characters in this scheme, but only 4 as a run.))</p>
<p>What is the worst case now? Well, an input stream with no runs <em>and no sigils</em> – a chunk – will be encoded as is with no overhead. An input stream with no runs and including sigils will require two extra characters for each sigil. In the worst case, a stream of <span class="math inline">\(n\)</span> characters will require about <span class="math inline">\(2n\)</span> characters for the sigils, for a “compressed” size of about <span class="math inline">\(3n\)</span>. Really not great!</p>
<p>On the face of it the second scheme is much worse, in the worst case, than the first. But which is worse on realistic data? If we plan to use <code>compress</code> on textual data we can choose the sigil to be a rarely used character. ASCII includes several control characters, like <code>\BEL</code>, which do not appear in text. Note that if our input does not have any literal sigils, then the second scheme can never compress its input to a larger size as long as we only compress runs of at least 5 characters (as the only way this happens is by encoding literal sigils). On the other hand, the first scheme adds overhead proportional to <span class="math inline">\(\log(n)\)</span> for every chunk of length <span class="math inline">\(n\)</span> – so unless our input includes long runs, or lots of short runs, the size may not decrease much and can easily increase.</p>
<p>The main program is basic; <code>compress</code> is a character-oriented filter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-compress: compress stdin (run length encoding)</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">SoftwareTools.Lib</span> (exitSuccess)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.IO</span> (charFilter)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.Text</span> (rlEncode)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  charFilter (rlEncode <span class="ch">'\BEL'</span> <span class="dv">5</span>)
  exitSuccess</code></pre></div>
<p>The actual run length encoding is a little complicated. We define an internal representation for run length encoded data.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">RLE</span> a
  <span class="fu">=</span> <span class="dt">Chunk</span>   [a]
  <span class="fu">|</span> <span class="dt">Repeat</span>  <span class="dt">Int</span> a
  <span class="fu">|</span> <span class="dt">Literal</span> <span class="dt">Int</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>Doing this is not strictly necessary, but introducing a type for run length encoded data makes it easier to decompose algorithms (algebraic data types are a big win here). Now <code>rlEncode</code> works in two phases: first it reads a stream of characters into the internal representation of RLEs, and then it serializes that representation as a string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rlEncode ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
rlEncode sig k <span class="fu">=</span> showRLE sig <span class="fu">.</span> runLengthEncode sig k
  <span class="kw">where</span>
<span class="ot">    showRLE ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">RLE</span> <span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
    showRLE sig <span class="fu">=</span> concatMap write
      <span class="kw">where</span>
<span class="ot">        write ::</span> <span class="dt">RLE</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
        write (<span class="dt">Repeat</span> k x) <span class="fu">=</span> concat
          [[sig], [x], showBase86Nat k, [sig]]
        write (<span class="dt">Chunk</span> xs) <span class="fu">=</span> xs
        write (<span class="dt">Literal</span> <span class="dv">1</span>) <span class="fu">=</span> [sig,sig,sig]
        write (<span class="dt">Literal</span> k) <span class="fu">=</span> concat <span class="fu">$</span>
          [[sig], [sig], showBase86Nat k, [sig]]

<span class="ot">    runLengthEncode ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [<span class="dt">RLE</span> a]
    runLengthEncode sig t <span class="fu">=</span> unfoldr (getFirst t) <span class="fu">.</span> getRuns
      <span class="kw">where</span>
        getFirst _ [] <span class="fu">=</span> <span class="dt">Nothing</span>
        getFirst t ((x,k)<span class="fu">:</span>xs)
          <span class="fu">|</span> t <span class="fu">&lt;=</span> k    <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Repeat</span> k x, xs)
          <span class="fu">|</span> x <span class="fu">==</span> sig  <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Literal</span> k, xs)
          <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">let</span> (ys,zs) <span class="fu">=</span> split ((x,k)<span class="fu">:</span>xs)
                        <span class="kw">in</span> <span class="dt">Just</span> (<span class="dt">Chunk</span> <span class="fu">$</span> fromRuns ys, zs)
              <span class="kw">where</span>
                split <span class="fu">=</span> span (\(z,h) <span class="ot">-&gt;</span> t <span class="fu">&gt;</span> h <span class="fu">&amp;&amp;</span> z <span class="fu">/=</span> sig)</code></pre></div>
<p>We use two library functions to work with run-encoded lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getRuns ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [(a, <span class="dt">Int</span>)]
getRuns <span class="fu">=</span> unfoldr firstRun
  <span class="kw">where</span>
<span class="ot">    firstRun ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ((a, <span class="dt">Int</span>), [a])
    firstRun []     <span class="fu">=</span> <span class="dt">Nothing</span>
    firstRun (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">let</span> (as,bs) <span class="fu">=</span> span (<span class="fu">==</span> x) xs <span class="kw">in</span>
      <span class="dt">Just</span> ((x, <span class="dv">1</span> <span class="fu">+</span> count as), bs)

<span class="ot">fromRuns ::</span> [(a, <span class="dt">Int</span>)] <span class="ot">-&gt;</span> [a]
fromRuns <span class="fu">=</span> concatMap (\(x,k) <span class="ot">-&gt;</span> replicate k x)</code></pre></div>
<p>Repeat counts are encoded in base 86 for space efficiency. (Counts up to 85 need only one character, counts up to 7395 need at most two, and up to 636055 need at most three.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">digitsToBase ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
digitsToBase b k
  <span class="fu">|</span> b <span class="fu">&lt;=</span> <span class="dv">1</span> <span class="fu">||</span> k <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> []
  <span class="fu">|</span> otherwise <span class="fu">=</span> reverse <span class="fu">$</span> foo k
      <span class="kw">where</span>
        foo t
          <span class="fu">|</span> t <span class="fu">&lt;</span> b <span class="fu">=</span> [t]
          <span class="fu">|</span> otherwise <span class="fu">=</span> (t<span class="ot">`rem`</span>b) <span class="fu">:</span> (foo (t<span class="ot">`quot`</span>b))


<span class="ot">showBase86Nat ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showBase86Nat k
  <span class="fu">|</span> k <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="st">&quot;&quot;</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> sequence <span class="fu">$</span> map intToChar <span class="fu">$</span> digitsToBase <span class="dv">86</span> k <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;showBase86Nat&quot;</span>
      <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x
      
  <span class="kw">where</span>
<span class="ot">    intToChar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Char</span>
    intToChar x <span class="fu">=</span> lookup x <span class="fu">$</span> map swap
      [ (<span class="ch">'0'</span>,<span class="dv">0</span>),  (<span class="ch">'1'</span>,<span class="dv">1</span>),  (<span class="ch">'2'</span>,<span class="dv">2</span>),  (<span class="ch">'3'</span>,<span class="dv">3</span>),  (<span class="ch">'4'</span>,<span class="dv">4</span>)
      , (<span class="ch">'5'</span>,<span class="dv">5</span>),  (<span class="ch">'6'</span>,<span class="dv">6</span>),  (<span class="ch">'7'</span>,<span class="dv">7</span>),  (<span class="ch">'8'</span>,<span class="dv">8</span>),  (<span class="ch">'9'</span>,<span class="dv">9</span>)
      , (<span class="ch">'a'</span>,<span class="dv">10</span>), (<span class="ch">'b'</span>,<span class="dv">11</span>), (<span class="ch">'c'</span>,<span class="dv">12</span>), (<span class="ch">'d'</span>,<span class="dv">13</span>), (<span class="ch">'e'</span>,<span class="dv">14</span>)
      , (<span class="ch">'f'</span>,<span class="dv">15</span>), (<span class="ch">'g'</span>,<span class="dv">16</span>), (<span class="ch">'h'</span>,<span class="dv">17</span>), (<span class="ch">'i'</span>,<span class="dv">18</span>), (<span class="ch">'j'</span>,<span class="dv">19</span>)
      , (<span class="ch">'k'</span>,<span class="dv">20</span>), (<span class="ch">'l'</span>,<span class="dv">21</span>), (<span class="ch">'m'</span>,<span class="dv">22</span>), (<span class="ch">'n'</span>,<span class="dv">23</span>), (<span class="ch">'o'</span>,<span class="dv">24</span>)
      , (<span class="ch">'p'</span>,<span class="dv">25</span>), (<span class="ch">'q'</span>,<span class="dv">26</span>), (<span class="ch">'r'</span>,<span class="dv">27</span>), (<span class="ch">'s'</span>,<span class="dv">28</span>), (<span class="ch">'t'</span>,<span class="dv">29</span>)
      , (<span class="ch">'u'</span>,<span class="dv">30</span>), (<span class="ch">'v'</span>,<span class="dv">31</span>), (<span class="ch">'w'</span>,<span class="dv">32</span>), (<span class="ch">'x'</span>,<span class="dv">33</span>), (<span class="ch">'y'</span>,<span class="dv">34</span>)
      , (<span class="ch">'z'</span>,<span class="dv">35</span>), (<span class="ch">'A'</span>,<span class="dv">36</span>), (<span class="ch">'B'</span>,<span class="dv">37</span>), (<span class="ch">'C'</span>,<span class="dv">38</span>), (<span class="ch">'D'</span>,<span class="dv">39</span>)
      , (<span class="ch">'E'</span>,<span class="dv">40</span>), (<span class="ch">'F'</span>,<span class="dv">41</span>), (<span class="ch">'G'</span>,<span class="dv">42</span>), (<span class="ch">'H'</span>,<span class="dv">43</span>), (<span class="ch">'I'</span>,<span class="dv">44</span>)
      , (<span class="ch">'J'</span>,<span class="dv">45</span>), (<span class="ch">'K'</span>,<span class="dv">46</span>), (<span class="ch">'L'</span>,<span class="dv">47</span>), (<span class="ch">'M'</span>,<span class="dv">48</span>), (<span class="ch">'N'</span>,<span class="dv">49</span>)
      , (<span class="ch">'O'</span>,<span class="dv">50</span>), (<span class="ch">'P'</span>,<span class="dv">51</span>), (<span class="ch">'Q'</span>,<span class="dv">52</span>), (<span class="ch">'R'</span>,<span class="dv">53</span>), (<span class="ch">'S'</span>,<span class="dv">54</span>)
      , (<span class="ch">'T'</span>,<span class="dv">55</span>), (<span class="ch">'U'</span>,<span class="dv">56</span>), (<span class="ch">'V'</span>,<span class="dv">57</span>), (<span class="ch">'W'</span>,<span class="dv">58</span>), (<span class="ch">'X'</span>,<span class="dv">59</span>)
      , (<span class="ch">'Y'</span>,<span class="dv">60</span>), (<span class="ch">'Z'</span>,<span class="dv">61</span>), (<span class="ch">'?'</span>,<span class="dv">62</span>), (<span class="ch">'!'</span>,<span class="dv">63</span>), (<span class="ch">'#'</span>,<span class="dv">64</span>)
      , (<span class="ch">'&amp;'</span>,<span class="dv">65</span>), (<span class="ch">'@'</span>,<span class="dv">66</span>), (<span class="ch">'$'</span>,<span class="dv">67</span>), (<span class="ch">'='</span>,<span class="dv">68</span>), (<span class="ch">'+'</span>,<span class="dv">69</span>)
      , (<span class="ch">'-'</span>,<span class="dv">70</span>), (<span class="ch">'~'</span>,<span class="dv">71</span>), (<span class="ch">'&lt;'</span>,<span class="dv">72</span>), (<span class="ch">'&gt;'</span>,<span class="dv">73</span>), (<span class="ch">'['</span>,<span class="dv">74</span>)
      , (<span class="ch">']'</span>,<span class="dv">75</span>), (<span class="ch">'('</span>,<span class="dv">76</span>), (<span class="ch">')'</span>,<span class="dv">77</span>), (<span class="ch">'{'</span>,<span class="dv">78</span>), (<span class="ch">'}'</span>,<span class="dv">79</span>)
      , (<span class="ch">'|'</span>,<span class="dv">80</span>), (<span class="ch">'/'</span>,<span class="dv">81</span>), (<span class="ch">'*'</span>,<span class="dv">82</span>), (<span class="ch">'^'</span>,<span class="dv">83</span>), (<span class="ch">':'</span>,<span class="dv">84</span>)
      , (<span class="ch">';'</span>,<span class="dv">85</span>)
      ]

    swap (x,y) <span class="fu">=</span> (y,x)</code></pre></div>
<p>It will be difficult to test <code>compress</code> until we’ve also written…</p>
<p><a name="expand"></a></p>
<h2 id="expand-uncompress-stdin-run-length-encoding"><code>expand</code>: uncompress stdin (run length encoding)</h2>
<p>The companion to <code>compress</code> is <code>expand</code>. It reads a string of characters that was run length encoded by <code>compress</code> and uncompresses it. This program has an error condition; the input may not be valid. This can happen for a few reasons; if a repeat count is incorrectly encoded (i.e. includes invalid digits or does not terminate in a sigil), or if the file ends in the middle of a repeat encoding.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-expand: uncompress stdin (run length encoding)</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">SoftwareTools.Lib</span>
  (exitSuccess, exitFailure)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.IO</span> (charFilter)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.Text</span> (rlDecode)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.Error</span> (reportErrorMsgs)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  xs <span class="ot">&lt;-</span> getContents

  ys <span class="ot">&lt;-</span> <span class="kw">case</span> rlDecode <span class="ch">'\BEL'</span> xs <span class="kw">of</span>
          <span class="dt">Just</span> zs <span class="ot">-&gt;</span> return zs
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> reportErrorMsgs
                       [ <span class="st">&quot;corrupt input&quot;</span>
                       ] <span class="fu">&gt;&gt;</span> exitFailure

  putStr ys
  exitSuccess</code></pre></div>
<p><code>rlDecode</code> does all the work:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rlDecode ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
rlDecode sig <span class="fu">=</span> fmap (runLengthDecode sig) <span class="fu">.</span> readRLE sig
  <span class="kw">where</span>
<span class="ot">    runLengthDecode ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">RLE</span> a] <span class="ot">-&gt;</span> [a]
    runLengthDecode sig <span class="fu">=</span> concatMap decodeRLE
      <span class="kw">where</span>
        decodeRLE (<span class="dt">Chunk</span>  xs)  <span class="fu">=</span> xs
        decodeRLE (<span class="dt">Repeat</span> k x) <span class="fu">=</span> replicate k x
        decodeRLE (<span class="dt">Literal</span> k)  <span class="fu">=</span> replicate k sig

<span class="ot">    readRLE ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">RLE</span> <span class="dt">Char</span>]
    readRLE sig <span class="fu">=</span> unfoldrMaybe readFirstRLE
      <span class="kw">where</span>
<span class="ot">        readFirstRLE ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">RLE</span> <span class="dt">Char</span>, <span class="dt">String</span>))
        readFirstRLE <span class="st">&quot;&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Nothing</span>
        readFirstRLE [x] <span class="fu">=</span>
          <span class="kw">if</span> x <span class="fu">==</span> sig <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Chunk</span> [x], <span class="st">&quot;&quot;</span>))
        readFirstRLE [x,y] <span class="fu">=</span>
          <span class="kw">if</span> x <span class="fu">==</span> sig <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Chunk</span> [x], [y]))
        readFirstRLE (x<span class="fu">:</span>y<span class="fu">:</span>z<span class="fu">:</span>xs)
          <span class="fu">|</span> x <span class="fu">==</span> sig <span class="fu">&amp;&amp;</span> y <span class="fu">==</span> sig <span class="fu">&amp;&amp;</span> z <span class="fu">==</span> sig
              <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Literal</span> <span class="dv">1</span>, xs))
          <span class="fu">|</span> x <span class="fu">==</span> sig <span class="fu">&amp;&amp;</span> y <span class="fu">==</span> sig <span class="fu">&amp;&amp;</span> z <span class="fu">/=</span> sig
              <span class="fu">=</span> <span class="kw">do</span>
                  <span class="kw">let</span> (as,bs) <span class="fu">=</span> span (<span class="fu">/=</span> sig) (z<span class="fu">:</span>xs)
                  k <span class="ot">&lt;-</span> readBase86Nat as
                  <span class="kw">case</span> bs <span class="kw">of</span>
                    <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Repeat</span> k y, <span class="st">&quot;&quot;</span>))
                    (_<span class="fu">:</span>cs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Repeat</span> k y, cs))
          <span class="fu">|</span> x <span class="fu">==</span> sig <span class="fu">&amp;&amp;</span> y <span class="fu">/=</span> sig
              <span class="fu">=</span> <span class="kw">do</span>
                  <span class="kw">let</span> (as,bs) <span class="fu">=</span> span (<span class="fu">/=</span> sig) (z<span class="fu">:</span>xs)
                  k <span class="ot">&lt;-</span> readBase86Nat as
                  <span class="kw">case</span> bs <span class="kw">of</span>
                    <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Repeat</span> k y, <span class="st">&quot;&quot;</span>))
                    (_<span class="fu">:</span>cs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Repeat</span> k y, cs))
          <span class="fu">|</span> otherwise
              <span class="fu">=</span> <span class="kw">do</span>
                  <span class="kw">let</span> (as,bs) <span class="fu">=</span> span (<span class="fu">/=</span> sig) (x<span class="fu">:</span>y<span class="fu">:</span>z<span class="fu">:</span>xs)
                  <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Chunk</span> as, bs))</code></pre></div>
<p>One big improvement we could make to <code>expand</code> is to try to handle invalid input more gracefully; we could output the partially expanded text, for instance, or tell the user exactly where the error occurs. The first idea would not be too difficult. (Write the output to stderr.) The second idea, though, while possibly useful, would make the implementation much more complicated. (We’d have to keep track of the position of each character in the original source.) Doable, but until the need is demonstrated I’d prefer to keep the implementation simple.</p>
<p><a name="crypt"></a></p>
<h2 id="crypt-xor-stdin-with-a-list-of-keys"><code>crypt</code>: xor stdin with a list of keys</h2>
<p>This program performs very simple encryption by xor-ing stdin with a list of keys, supplied by the user at the command line.</p>
<p>At the bit level, <code>a xor b</code> is 0 if <code>a</code> and <code>b</code> are equal and is <code>1</code> otherwise. Two lists of bits are <code>xor</code>ed entrywise, with the shorter list padded with <span class="math inline">\(0\)</span>s. We can think of <code>xor</code> as an operation on natural numbers by converting to and from base 2, and finally we can think of <code>xor</code> as an operation on <em>characters</em> by converting to and from natural numbers (a.k.a. code points). Then to <code>xor</code> two strings we <code>xor</code> characterwise.</p>
<p>We will implement these operations bare-handed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bit</span>
  <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">One</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">intToBits ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
intToBits k <span class="fu">=</span> <span class="kw">case</span> getBits k <span class="kw">of</span>
  [] <span class="ot">-&gt;</span> [<span class="dt">Zero</span>]
  bs <span class="ot">-&gt;</span> bs
  <span class="kw">where</span>
    getBits t
      <span class="fu">|</span> t <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> []
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> even t <span class="kw">of</span>
          <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Zero</span> <span class="fu">:</span> (getBits <span class="fu">$</span> t<span class="ot">`quot`</span><span class="dv">2</span>)
          <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">One</span>  <span class="fu">:</span> (getBits <span class="fu">$</span> (t<span class="fu">-</span><span class="dv">1</span>)<span class="ot">`quot`</span><span class="dv">2</span>)

<span class="ot">bitToInt ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> <span class="dt">Bit</span> <span class="ot">-&gt;</span> n
bitToInt <span class="dt">Zero</span> <span class="fu">=</span> <span class="dv">0</span>
bitToInt <span class="dt">One</span>  <span class="fu">=</span> <span class="dv">1</span>

<span class="ot">bitsToInt ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> n
bitsToInt <span class="fu">=</span> sum <span class="fu">.</span> zipWith (<span class="fu">*</span>) [<span class="dv">2</span><span class="fu">^</span>t <span class="fu">|</span> t <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>]] <span class="fu">.</span> map bitToInt

<span class="ot">bitXOR ::</span> <span class="dt">Bit</span> <span class="ot">-&gt;</span> <span class="dt">Bit</span> <span class="ot">-&gt;</span> <span class="dt">Bit</span>
bitXOR <span class="dt">Zero</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span>
bitXOR <span class="dt">Zero</span> <span class="dt">One</span>  <span class="fu">=</span> <span class="dt">One</span>
bitXOR <span class="dt">One</span>  <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">One</span>
bitXOR <span class="dt">One</span>  <span class="dt">One</span>  <span class="fu">=</span> <span class="dt">Zero</span>

<span class="ot">bitsXOR ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
bitsXOR [] ys <span class="fu">=</span> ys
bitsXOR xs [] <span class="fu">=</span> xs
bitsXOR (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys)
  <span class="fu">=</span> (bitXOR x y) <span class="fu">:</span> bitsXOR xs ys

<span class="ot">intXOR ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> n
intXOR a b <span class="fu">=</span> bitsToInt <span class="fu">$</span> bitsXOR (intToBits a) (intToBits b)</code></pre></div>
<p>When we <code>xor</code> two strings together, one is called the <em>plaintext</em> and the other is called the <em>key</em>. If the key is shorter than the plaintext we simply repeat it from the beginning as many times as needed. The result is a new string, the <em>ciphertext</em>, which will generally not be recognizable. However, we can recover the plaintext by repeating the <code>xor</code> operation with the same key.</p>
<p>This method of encrytion has several interesting properties. (I am hesitant to call these unequivocal “pros” or “cons”, since every encryption scheme involves tradeoffs.)</p>
<ul>
<li>Extremely simple to implement.</li>
<li>Is a symmetric cipher; in fact, exactly the same key is used for encryption and decryption.</li>
<li>If the key is short compared to the text, is vulnerable to statistical attacks. (Beyond the usual brute-force attacks that come with short keys.)</li>
<li>Can be used to implement a <a href="https://www.wikipedia.org/wiki/One-time_pad">one-time pad</a>, which to my knowledge is the only provably secure encryption scheme. (To do this, the key must be the same length as the plaintext.)</li>
<li>Can only be used on character encodings of size <span class="math inline">\(2^n\)</span> (which unicode is), which preferably have a canonical mapping to the integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^n - 1\)</span> (which unicode does).</li>
<li>When used on a large alphabet, most significant bits can play an important role. For instance, if we are encrypting a text which consists only of ASCII (the first 128 characters of unicode) and use a key consisting of characters with a bit higher than the 7th set, then these high bits will never be <code>xor</code>ed away. I haven’t thought about this in depth, but I suspect this opens up a new class of statistical attacks.</li>
<li>Related to the previous property, practical text does not use the full range of unicode – more likely it is restricted to the characters used in a particular language. This may open a class of attacks.</li>
<li>When used with ASCII or unicode, generally the ciphertext will include control characters. This can make it inconvenient to use text-oriented tools on encrypted text. We could fix this with a different mapping from characters to numbers, but doing so would probably weaken the encryption even further by reducing the alphabet size.</li>
</ul>
<p>Here’s the main program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-crypt: xor stdin with a list of keys</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">SoftwareTools.Lib</span> (getArgs, exitSuccess)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.IO</span> (charFilter)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.Text</span>
  (toCodePoint, fromCodePoint, backslashUnEscape)
<span class="kw">import </span><span class="dt">SoftwareTools.Lib.Bit</span> (intXOR)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  keys <span class="ot">&lt;-</span> getArgs
  charFilter (cryptKeys (map backslashUnEscape keys))
  exitSuccess


<span class="ot">cryptKeys ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
cryptKeys []     str <span class="fu">=</span> str
cryptKeys (k<span class="fu">:</span>ks) str <span class="fu">=</span> cryptKeys ks (crypt k str)

<span class="ot">crypt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
crypt <span class="st">&quot;&quot;</span>  str  <span class="fu">=</span> str
crypt key str <span class="fu">=</span> zipWith xorChar str (concat <span class="fu">$</span> repeat key)
  <span class="kw">where</span>
<span class="ot">    xorChar ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    xorChar x y
      <span class="fu">=</span> fromCodePoint <span class="fu">$</span> intXOR (toCodePoint x) (toCodePoint y)</code></pre></div>
<p>Some notes: <code>toCodePoint</code> and <code>fromCodePoint</code> are synonyms for standard library functions which (surprise!) convert characters to and from their unicode code points.</p>
<p>We definitely want the user to specify an encryption key from the command line. But generally, the user can specify many (or no!) command line arguments. What should we do if that happens?</p>
<ul>
<li>If the user does not specify a key, then the simplest thing to do is return the plaintext unchanged. We could return an error, but it is feasible that some future user would prefer that “no key” be treated the same as “empty key”. Moreover, the recursive definition of <code>cryptKeys</code> is much cleaner with this decision.</li>
<li>We could just silently ignore any arguments after the first, but then the presence of extra arguments likely signifies that the user misunderstands how to use the program.</li>
<li>We could simply concatenate the arguments together as a single larget key.</li>
<li>We could interpret the command line arguments as a <em>list</em> of keys, and use all of them, one at a time.</li>
</ul>
<p>Concatenating the arguments to a single key would be fine. But interpreting the arguments as multiple keys, to be used independently, has a nice side effect. It provides a simple (if not maximally secure) way for the user to increase the effective size of the key. As K&amp;P note, if we <code>xor</code> encrypt a given file twice with two different keys, of lengths <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, then this is equivalent to <code>xor</code>ing once with a single key of length <span class="math inline">\(\mathrm{lcm}(m,n)\)</span>. For instance,</p>
<pre><code>crypt &quot;foo&quot; &quot;quuux&quot;</code></pre>
<p>with two keys of length 3 and 5, is equivalent to running <code>crypt</code> with a key of length 15. Saying</p>
<pre><code>crypt &quot;foo&quot; &quot;quuux&quot; &quot;mungely&quot;</code></pre>
<p>is just like using a key of length 105.</p>
<p>The keys are also run through <code>backslashUnEscape</code> by default, meaning that any C or ASCII style escape codes are interpreted. This is the Right Thing because we want the user to have easy access to the widest possible range of keys. It is not necessary to clutter the interface by making this functionality optional with an extra command line argument.</p>
<p>I can think of one important possible improvement to <code>crypt</code>: it would be nice if we could specify the keys as files as well as arguments. For instance, an invocation like</p>
<pre><code>crypt &quot;foo&quot; &quot;quuux&quot; --keyfiles key1.txt key2.txt</code></pre>
<p>would treat the contents of <code>key1.txt</code> and <code>key2.txt</code> as keys, just like <code>foo</code> and <code>quuux</code>. We generally do not want to leave encryption keys lying around in files. But this would make it easier to use very large keys, for instance to implement a one-time pad. That’s an idea for another day.</p>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
