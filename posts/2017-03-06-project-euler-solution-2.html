<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Project Euler Solution #2: Even Fibonacci Numbers</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<link rel="icon" href="../icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../about.html">About</a>
    <a href="../projects.html">Projects</a>
    <a href="../contact.html">Contact</a>
    <a href="../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Project Euler Solution #2: Even Fibonacci Numbers</h1>
<!-- BEGIN BODY -->
<div class="info">
<strong>Spoiler alert!</strong> This page is part of a series on solutions to <a href="https://projecteuler.net/">Project Euler</a> problems. If you prefer to solve problems yourself, do not read on!
</div>

<div class="info">
Posted on 2017-03-06 by nbloomf
</div>


<div class="info tags">Tags: <a href="../tag/project-euler.html">project-euler</a></div>


<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/2017-03-06-project-euler-solution-2.lhs">the source</a> into GHCi and play along.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Ratio</span></code></pre></div>
<p><a href="https://projecteuler.net/problem=2">Problem 2</a> from Project Euler:</p>
<div class="problem">
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: <span class="math display">\[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots\]</span></p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
</div>
<p>Let’s start with the obvious thing: take the Fibonacci numbers under four million, filter for the evens, and sum. We’ll use the definition of the sequence from the problem statement, indexed from 1 like so: <span class="math display">\[F(1) = 1, F(2) = 1, F(n+2) = F(n) + F(n+1).\]</span> We’ll translate this to an unfold like so.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> fibs ::</span> [<span class="dt">Integer</span>]
<span class="fu">&gt;</span> fibs <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> fibs' <span class="dv">1</span> <span class="dv">1</span>
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span>     fibs' a b <span class="fu">=</span> <span class="kw">let</span> c <span class="fu">=</span> (a<span class="fu">+</span>) <span class="fu">$!</span> b <span class="kw">in</span> c <span class="fu">:</span> fibs' b c
<span class="fu">&gt;</span>
<span class="fu">&gt;</span><span class="ot"> pe2' ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> pe2' n <span class="fu">=</span> sum <span class="fu">$</span> filter even <span class="fu">$</span> takeWhile (<span class="fu">&lt;</span> n) fibs</code></pre></div>
<p>Note that strictness annotation (<code>$!</code>) in the definition of <code>fibs</code>; it’s needed to force the evaluation of each successive number, so we don’t end up with a bunch of unevaluated additions.</p>
<p>We can verify that <code>pe2' 89 == 44</code> as expected. Then our answer is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$&gt;</span> pe2' <span class="dv">4000000</span>
<span class="dv">4613732</span></code></pre></div>
<p>And done.</p>
<p>But wait! Anything worth doing is worth overdoing, so let’s try something less obvious.</p>
<p>I think it will be pretty hard to squeeze much more performance out of <code>pe2'</code>. The Fibonacci numbers grow reasonably quickly, getting a new digit every 5 terms or so. Why is that? The first Fibonacci number with a given number of digits (always?) has leading digit 1, and the one after that has leading digit 1 or 2, so at that point (after moving the decimal point) it looks like we’re starting a new Fibonacci sequence with initial terms <span class="math inline">\(1 + \varepsilon\)</span> and <span class="math inline">\(1 + \delta\)</span>, which reaches 10 after at most six terms. This means that computing <code>pe2' (10*n)</code> requires looking at only 5 or 6 more terms in <code>fibs</code> than <code>pe2' n</code> does. And computing the next term in <code>fibs</code> is cheap.</p>
<p>Let’s look at the first several <span class="math inline">\(F(n)\)</span> again, this time highlighting the even terms: <span class="math display">\[1, 1, \fbox{2}, 3, 5, \fbox{8}, 13, 21, \fbox{34}, 55, 89, \fbox{134}, \ldots\]</span> And what’s this then – there’s a pattern! It appears that every third <span class="math inline">\(F(n)\)</span> is even, and no others. But does this pattern always hold? Indeed it does; to see why, unpack the recursive definition of <span class="math inline">\(F\)</span> on <span class="math inline">\(F(n+3)\)</span>. This gives the congruence <span class="math display">\[F(n+3) = F(n) + 2F(n+1) \equiv F(n) \pmod{2}.\]</span> So the parity pattern of <span class="math inline">\(F(n)\)</span> repeats every third term, and because <span class="math inline">\(F(1)\)</span> and <span class="math inline">\(F(2)\)</span> are odd while <span class="math inline">\(F(3)\)</span> is even, this explains the pattern. That means we don’t really need to check the parity of our Fibonacci numbers; it’s enough to simply throw out all but every third term.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> pe2'' ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> pe2'' n <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">&lt;</span> n) <span class="fu">$</span> take3rd fibs
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span>     take3rd (_<span class="fu">:</span>_<span class="fu">:</span>a<span class="fu">:</span>as) <span class="fu">=</span> a <span class="fu">:</span> take3rd as</code></pre></div>
<p>But the observation that <span class="math inline">\(F(n)\)</span> is even precisely when <span class="math inline">\(n = 3k\)</span> leads to another idea; what we really want is <span class="math display">\[\sum_{k=1}^t F(3k)\]</span> where <span class="math inline">\(t\)</span> is the <em>index</em> of the largest Fibonacci number less than <span class="math inline">\(N = 4,000,000\)</span>. This is interesting because there is a closed form formula for <span class="math inline">\(F(n)\)</span> known as <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">Binet’s formula</a>: <span class="math display">\[F(n) = \frac{1}{\sqrt{5}}(\varphi^n - \overline{\varphi}^n),\]</span> where <span class="math inline">\(\varphi = (1+\sqrt{5})/2\)</span> is the largest real solution of <span class="math inline">\(x^2 - x - 1 = 0\)</span> and <span class="math inline">\(\overline{\varphi} = (1-\sqrt{5})/2\)</span> is its quadratic conjugate.</p>
<p>But now:</p>
<p><span class="math display">\[\begin{eqnarray*}
\sum_{k=1}^t F(3k) &amp; = &amp; \sum_{k=1}^t \frac{1}{\sqrt{5}}\left( \varphi^{3k} - \overline{\varphi}^{3k} \right) \\
 &amp; = &amp; \frac{1}{\sqrt{5}} \left( \sum_{k=0}^{t-1} (\varphi^3)^{k+1} - \sum_{k=0}^{t-1} (\overline{\varphi}^3)^{k+1} \right) \\
 &amp; = &amp; \frac{1}{\sqrt{5}} \left( \varphi^3 \sum_{k=0}^{t-1} (\varphi^3)^k - \overline{\varphi}^3 \sum_{k=0}^{t-1} (\overline{\varphi}^3)^k \right) \\
 &amp; = &amp; \frac{1}{\sqrt{5}} \left( \varphi^3 \frac{\varphi^{3t} - 1}{\varphi^3 - 1} - \overline{\varphi}^3 \frac{\overline{\varphi}^{3t} - 1}{\overline{\varphi}^3 - 1} \right) \\
 &amp; = &amp; \frac{1}{2\sqrt{5}} \left( \varphi^{3t+2} - \overline{\varphi}^{3t+2} - \varphi^2 + \overline{\varphi}^2 \right) \\
 &amp; = &amp; \frac{1}{2}\left( \frac{1}{\sqrt{5}}\left( \varphi^{3t+2} - \overline{\varphi}^{3t+2} \right) - \frac{1}{\sqrt{5}}\left( \varphi^2 - \overline{\varphi}^2 \right) \right) \\
 &amp; = &amp; \frac{F(3t+2) - 1}{2}
\end{eqnarray*}\]</span></p>
<p>That is, the sum of the first <span class="math inline">\(t\)</span> even Fibonacci numbers is essentially the <span class="math inline">\((3t+2)\)</span>th Fibonacci number. The only obstacle to applying this to our current problem is that it’s not obvious how to take an upper bound <span class="math inline">\(N\)</span> and find the <em>index</em> of the largest even Fibonacci number less than <span class="math inline">\(N\)</span>.</p>
<p>Here’s a quick and dirty way to find the largest index of a Fibonacci number below <span class="math inline">\(N\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> maxfibidx' ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> maxfibidx' n <span class="fu">=</span>
<span class="fu">&gt;</span>   fst <span class="fu">$</span>
<span class="fu">&gt;</span>   head <span class="fu">$</span>
<span class="fu">&gt;</span>   dropWhile (\(_,m) <span class="ot">-&gt;</span> m <span class="fu">&lt;</span> n ) <span class="fu">$</span>
<span class="fu">&gt;</span>   zip [<span class="dv">1</span><span class="fu">..</span>] (tail fibs)</code></pre></div>
<p>But this doesn’t really improve on our naive implementation of <code>pe2'</code>, since it still requires generating all the Fibonacci numbers up to <span class="math inline">\(n\)</span>. Here’s a better idea. <span class="math inline">\(F\)</span> is a monotone increasing function on the natural numbers, and we wish to find the largest <span class="math inline">\(m\)</span> such that <span class="math inline">\(F(m) &lt; N\)</span>. We can find this <span class="math inline">\(m\)</span> using a binary search.</p>
<p>First, we find integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> such that <span class="math inline">\(F(a) &lt; N \leq F(b)\)</span>; this can be done by looking at <span class="math inline">\(m = 2^i\)</span> for increasing <span class="math inline">\(i\)</span>.</p>
<p>Then, once such <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are found, we tighten the interval <span class="math inline">\((a,b)\)</span> bounding a root of <span class="math inline">\(F(x) - N\)</span> by bisection. The <code>binarysearch</code> function does this, taking a function <span class="math inline">\(G\)</span> as a parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span> <span class="co">-- g is nondecreasing on positive integers</span>
<span class="fu">&gt;</span> <span class="co">-- g(1) &lt; n</span>
<span class="fu">&gt;</span> <span class="co">-- returns the largest t such that g(t) &lt; n</span>
<span class="fu">&gt;</span><span class="ot"> binarysearch ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> binarysearch g n <span class="fu">=</span> refine init
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="co">-- find powers of 2 that bound a root of g(x) - n</span>
<span class="fu">&gt;</span>     k <span class="fu">=</span>
<span class="fu">&gt;</span>       fst <span class="fu">$</span>
<span class="fu">&gt;</span>       head <span class="fu">$</span>
<span class="fu">&gt;</span>       dropWhile ((<span class="fu">&lt;</span> n) <span class="fu">.</span> snd) <span class="fu">$</span>
<span class="fu">&gt;</span>       map (\k <span class="ot">-&gt;</span> (k, g <span class="fu">$</span> <span class="dv">2</span><span class="fu">^</span>k)) [<span class="dv">1</span><span class="fu">..</span>]
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>     <span class="co">-- this interval contains a root of g(x) - n</span>
<span class="fu">&gt;</span>     init <span class="fu">=</span> (<span class="dv">2</span><span class="fu">^</span>(k<span class="fu">-</span><span class="dv">1</span>), <span class="dv">2</span><span class="fu">^</span>k)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>     <span class="co">-- bisect a root-containing interval</span>
<span class="fu">&gt;</span>     refine (a,b)
<span class="fu">&gt;</span>       <span class="fu">|</span> b<span class="fu">-</span>a <span class="fu">&lt;=</span> <span class="dv">1</span> <span class="fu">=</span> a
<span class="fu">&gt;</span>       <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">let</span> m <span class="fu">=</span> (a<span class="fu">+</span>b)<span class="ot">`quot`</span><span class="dv">2</span> <span class="kw">in</span>
<span class="fu">&gt;</span>           <span class="kw">case</span> compare (g m) n <span class="kw">of</span>
<span class="fu">&gt;</span>             <span class="dt">EQ</span> <span class="ot">-&gt;</span> m<span class="fu">-</span><span class="dv">1</span>
<span class="fu">&gt;</span>             <span class="dt">LT</span> <span class="ot">-&gt;</span> refine (m,b)
<span class="fu">&gt;</span>             <span class="dt">GT</span> <span class="ot">-&gt;</span> refine (a,m)</code></pre></div>
<p>With an implementation of Binet’s formula, we’d be nearly there. But in order to do exact arithmetic on quadratic numbers of the form <span class="math inline">\(p + q\sqrt{5}\)</span> – as required by Binet – we need the following type and instances.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Root5</span> <span class="fu">=</span> <span class="dt">Root5</span> <span class="dt">Rational</span> <span class="dt">Rational</span>
<span class="fu">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> phi   <span class="fu">=</span> <span class="dt">Root5</span> (<span class="dv">1</span><span class="fu">%</span><span class="dv">2</span>) (<span class="dv">1</span><span class="fu">%</span><span class="dv">2</span>)
<span class="fu">&gt;</span> sqrt5 <span class="fu">=</span> <span class="dt">Root5</span>  <span class="dv">0</span>     <span class="dv">1</span>
<span class="fu">&gt;</span>
<span class="fu">&gt;</span> <span class="co">-- quadratic conjugate</span>
<span class="fu">&gt;</span><span class="ot"> conj ::</span> <span class="dt">Root5</span> <span class="ot">-&gt;</span> <span class="dt">Root5</span>
<span class="fu">&gt;</span> conj (<span class="dt">Root5</span> a b) <span class="fu">=</span> <span class="dt">Root5</span> a (negate b)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> <span class="co">-- rational part</span>
<span class="fu">&gt;</span><span class="ot"> ratpart ::</span> <span class="dt">Root5</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span>
<span class="fu">&gt;</span> ratpart (<span class="dt">Root5</span> p _) <span class="fu">=</span> p
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Root5</span> <span class="kw">where</span>
<span class="fu">&gt;</span>   fromInteger k <span class="fu">=</span> <span class="dt">Root5</span> (k<span class="fu">%</span><span class="dv">1</span>) <span class="dv">0</span>
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>   (<span class="dt">Root5</span> a1 b1) <span class="fu">+</span> (<span class="dt">Root5</span> a2 b2) <span class="fu">=</span>
<span class="fu">&gt;</span>     <span class="dt">Root5</span> (a1 <span class="fu">+</span> a2) (b1 <span class="fu">+</span> b2)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>   (<span class="dt">Root5</span> a1 b1) <span class="fu">*</span> (<span class="dt">Root5</span> a2 b2) <span class="fu">=</span>
<span class="fu">&gt;</span>     <span class="dt">Root5</span> (a1<span class="fu">*</span>a2 <span class="fu">+</span> <span class="dv">5</span><span class="fu">*</span>b1<span class="fu">*</span>b2) (a1<span class="fu">*</span>b2 <span class="fu">+</span> a2<span class="fu">*</span>b1)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>   negate (<span class="dt">Root5</span> a b) <span class="fu">=</span>
<span class="fu">&gt;</span>     <span class="dt">Root5</span> (negate a) (negate b)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>   abs <span class="fu">=</span> undefined; signum <span class="fu">=</span> undefined
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Fractional</span> <span class="dt">Root5</span> <span class="kw">where</span>
<span class="fu">&gt;</span>   fromRational q <span class="fu">=</span> <span class="dt">Root5</span> q <span class="dv">0</span>
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span>   recip (<span class="dt">Root5</span> <span class="dv">0</span> <span class="dv">0</span>) <span class="fu">=</span> undefined
<span class="fu">&gt;</span>   recip (<span class="dt">Root5</span> a b) <span class="fu">=</span> <span class="dt">Root5</span> (a<span class="fu">/</span>d) (<span class="fu">-</span>b<span class="fu">/</span>d)
<span class="fu">&gt;</span>     <span class="kw">where</span> d <span class="fu">=</span> a<span class="fu">*</span>a <span class="fu">-</span> <span class="dv">5</span><span class="fu">*</span>b<span class="fu">*</span>b</code></pre></div>
<p>Then, first of all, we can implement and test Binet’s formula.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span> <span class="co">-- directly compute F(n)</span>
<span class="fu">&gt;</span><span class="ot"> binet ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> binet n <span class="fu">=</span> numerator <span class="fu">$</span> ratpart <span class="fu">$</span>
<span class="fu">&gt;</span>   (phi<span class="fu">^</span>n <span class="fu">-</span> (conj phi)<span class="fu">^</span>n) <span class="fu">/</span> sqrt5
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> <span class="co">-- binet k == fibs !! (k-1)</span>
<span class="fu">&gt;</span><span class="ot"> test_binet ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">&gt;</span> test_binet n <span class="fu">=</span> and <span class="fu">$</span> zipWith (<span class="fu">==</span>) fibs <span class="fu">$</span> map binet [<span class="dv">1</span><span class="fu">..</span>n]</code></pre></div>
<p>We can now implement <code>maxfibidx</code> using binary search.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> maxfibidx ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> maxfibidx n <span class="fu">=</span> binarysearch binet n</code></pre></div>
<p>And finally, an alternative implementation of <code>pe2'</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> pe2''' ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> pe2''' n <span class="fu">=</span> ((binet <span class="fu">$</span> <span class="dv">3</span><span class="fu">*</span>t<span class="fu">+</span><span class="dv">2</span>) <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`quot`</span> <span class="dv">2</span>
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span>     t <span class="fu">=</span> (maxfibidx n) <span class="ot">`quot`</span> <span class="dv">3</span></code></pre></div>
<p>As a sanity check:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$&gt;</span> pe2' <span class="dv">4000000</span>
<span class="dv">4613732</span>
<span class="fu">$&gt;</span> pe2'' <span class="dv">4000000</span>
<span class="dv">4613732</span>
<span class="fu">$&gt;</span> pe2''' <span class="dv">4000000</span>
<span class="dv">4613732</span></code></pre></div>
<p>And more generally:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> test ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="fu">&gt;</span> test n <span class="fu">=</span> (pe2' n <span class="fu">==</span> pe2'' n) <span class="fu">&amp;&amp;</span> (pe2' n <span class="fu">==</span> pe2''' n)

<span class="fu">$&gt;</span> all test [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]
<span class="dt">True</span></code></pre></div>
<p>For comparison, here is a table of timings on my machine. I should note that the times for <code>pe2''</code> are misleading; they do not include time spent thrashing in memory. <code>pe2'''</code> did not suffer from this. The problem was so bad I couldn’t complete this table, but I think a trend is already evident.</p>
<table>
<colgroup>
<col width="25%" />
<col width="28%" />
<col width="28%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">n</th>
<th align="left"><code>pe2'' n</code> Time (s)</th>
<th align="left"><code>pe2''' n</code> Time (s)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(10^{1 \cdot 10^4}\)</span></td>
<td align="left">0.59</td>
<td align="left">0.15</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(10^{2 \cdot 10^4}\)</span></td>
<td align="left">1.07</td>
<td align="left">0.28</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(10^{3 \cdot 10^4}\)</span></td>
<td align="left">1.50</td>
<td align="left">0.44</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(10^{4 \cdot 10^4}\)</span></td>
<td align="left">2.03</td>
<td align="left">0.58</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(10^{5 \cdot 10^4}\)</span></td>
<td align="left">3.02</td>
<td align="left">0.74</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(10^{6 \cdot 10^4}\)</span></td>
<td align="left">6.84</td>
<td align="left">0.98</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(10^{7 \cdot 10^4}\)</span></td>
<td align="left">???</td>
<td align="left">1.08</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(10^{8 \cdot 10^4}\)</span></td>
<td align="left">???</td>
<td align="left">1.25</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(10^{9 \cdot 10^4}\)</span></td>
<td align="left">???</td>
<td align="left">1.40</td>
</tr>
</tbody>
</table>
<p>Just for fun, the sum of all even Fibonacci numbers less than <span class="math inline">\(10^{1000000}\)</span> is even. Shocking, I know! But my machine determined this by brute force in 14 seconds. :)</p>
<p>So the final answer is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> pe2 ::</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> pe2 <span class="fu">=</span> pe2''' <span class="dv">4000000</span></code></pre></div>


<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
