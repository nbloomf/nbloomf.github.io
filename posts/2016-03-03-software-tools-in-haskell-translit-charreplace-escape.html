<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell: translit, charreplace, escape</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../about.html">About</a>
    <a href="../contact.html">Contact</a>
    <a href="../archive.html">Posts</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: translit, charreplace, escape</h1>
<!-- BEGIN BODY -->
<div class="info">
Posted on 2016-03-03 by nbloomf
</div>

<!-- LaTeX Macros -->
<div class="invisible">
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\primrec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)

\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{t}}\)
\(\newcommand{\bfalse}{\mathsf{f}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathsf{and}}\)
\(\newcommand{\bor}{\mathsf{or}}\)
</div>
<!-- End LaTeX Macros -->

<p>This post is part of the <a href="../posts/2016-02-10-software-tools-in-haskell.html">Software Tools in Haskell</a> series.</p>
<p><a name="translit"></a></p>
<h2 id="translit-transliterate-or-remove-chars-on-stdin"><code>translit</code>: transliterate or remove chars on stdin</h2>
<p>The purpose of <code>translit</code> is to replace characters by other characters; it applies a mapping with signature <code>Char -&gt; Char</code> to each character on stdin. (While simple, this is surprisingly useful.) The most succinct way to specify such a mapping is with two lists of characters, one denoting the domain of the character mapping and the other the codomain. For instance, calling</p>
<pre><code>translit &quot;abc&quot; &quot;xyzw&quot;</code></pre>
<p>replaces all <code>a</code>s by <code>x</code>, <code>b</code>s by <code>y</code>, and <code>c</code>s by <code>z</code>. (The <code>w</code> has no effect.) It is useful if we can also specify <em>ranges</em> of characters with hyphens. For instance the string <code>a-g</code> should be shorthand for <code>abcdefg</code>. If the second list is nonempty, but shorter than the first, we pretend its final character is repeated indefinitely, so that</p>
<pre><code>translit &quot;abc&quot; &quot;x&quot;</code></pre>
<p>replaces all copies of <code>a</code>, <code>b</code>, or <code>c</code> by <code>x</code>.</p>
<p>If the second list is empty or not given, we can reasonably interpret this to mean we should remove the characters in the first list from the input. This is all well and good.</p>
<p>I have one quibble with Kernighan and Plauger’s design, though; they introduce another special input case. If the second list contains 0 or 1 characters, then the first list can be prepended by a “not” symbol like so:</p>
<pre><code>translit -&quot;abc&quot; &quot;x&quot;</code></pre>
<p>This means to replace every character <em>except</em> <code>a</code>, <code>b</code>, and <code>c</code> by <code>x</code>. I respectfully claim that this is the Wrong Thing. The arguments to <code>translit</code> are shorthand for a mapping, given in the form of two <strong>lists</strong>. We can tell by the significance of order; <code>translit ab xy</code> is not the same as <code>translit ba xy</code>. It is only by a quirk of combinatorics that this dependence on order goes away if the second list has 0 or 1 entry. But the special “not” option implicitly treats the arguments of <code>translit</code> as <strong>sets</strong>. To see this, think about what the complement of a list of characters is. In principle we could say that <code>-&quot;a-z&quot;</code>, as a list, means all characters (in order) except for the lower case roman letters. But is this useful? For instance, what if the user tries to run</p>
<pre><code>translit -&quot;abc&quot; &quot;xy&quot;</code></pre>
<p>What does this mean? Is the <code>y</code> just ignored? (User input should not be silently ignored.) Does the first unicode code point get mapped to <code>x</code>, and all others to <code>y</code>? Is this useful? Is it useful enough to warrant complicating <code>translit</code> with the extra code needed to handle this special case of a special case? I don’t think it is.</p>
<p>But the ability to replace or remove characters from a <em>set complement</em> is useful. And so I will split <code>translit</code> into two: <code>translit</code> will handle the list-wise mapping of characters, and a separate program, <code>charreplace</code>, will handle set-wise mappings. My opinion (and it’s just an opinion!) is that these two uses are different enough, semantically, to deserve separate tools; this avoids burdening the user with too many special cases and cluttering the interface with delicate options.</p>
<p>We already have most of the machinery needed for <code>translit</code>, except for the code needed to interpret command line arguments. We introduce an internal representation of character sequences: a character sequence is a list of either single characters or ranges of characters.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CharSeq</span>
  <span class="fu">=</span> <span class="dt">Single</span> <span class="dt">Char</span>
  <span class="fu">|</span> <span class="dt">Range</span>  <span class="dt">Char</span> <span class="dt">Char</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">interpArg ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
interpArg <span class="fu">=</span> fmap charSeqsToList <span class="fu">.</span> readCharSeqs <span class="fu">.</span> backslashUnEscape

<span class="ot">charSeqsToList ::</span> [<span class="dt">CharSeq</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
charSeqsToList <span class="fu">=</span> concatMap charSeqToList
  <span class="kw">where</span>
    charSeqToList (<span class="dt">Single</span> x) <span class="fu">=</span> [x]
    charSeqToList (<span class="dt">Range</span> x y) <span class="fu">=</span> enumFromTo x y

<span class="ot">readCharSeqs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">CharSeq</span>]
readCharSeqs <span class="fu">=</span> unfoldrMaybe firstCharSeq
  <span class="kw">where</span>
<span class="ot">    firstCharSeq ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">CharSeq</span>, <span class="dt">String</span>))
    firstCharSeq <span class="st">&quot;&quot;</span>      <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Nothing</span>
    firstCharSeq [x]     <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Single</span> x, <span class="st">&quot;&quot;</span>))
    firstCharSeq (<span class="ch">'-'</span><span class="fu">:</span>_) <span class="fu">=</span> <span class="dt">Nothing</span>
    firstCharSeq [x,y]   <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Single</span> x, [y]))
    firstCharSeq (x<span class="fu">:</span>y<span class="fu">:</span>z<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">case</span> y <span class="kw">of</span>
      <span class="ch">'-'</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Range</span> x z, xs))
      otherwise <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">Single</span> x, y<span class="fu">:</span>z<span class="fu">:</span>xs))</code></pre></div>
<p>Now the main program just has to interpret its arguments and call some library functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-translit: transliterate characters on stdin</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="kw">import </span><span class="dt">STH.Lib</span>
  (charFilter, applyListMap, padLast,
   readCharRange, reportErrorMsgs)


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  (from,to) <span class="ot">&lt;-</span> <span class="kw">case</span> map readCharRange args <span class="kw">of</span>
    [<span class="dt">Just</span> as]          <span class="ot">-&gt;</span> return (as, <span class="st">&quot;&quot;</span>)
    [<span class="dt">Just</span> as, <span class="dt">Just</span> bs] <span class="ot">-&gt;</span> return (as, bs)
    otherwise          <span class="ot">-&gt;</span> argError

  <span class="kw">let</span>
    remove   <span class="fu">=</span> filter (not <span class="fu">.</span> (<span class="ot">`elem`</span> from))
    translit <span class="fu">=</span> map (applyListMap <span class="fu">$</span> zip from (padLast to))

  <span class="kw">case</span> to <span class="kw">of</span>
    <span class="st">&quot;&quot;</span>        <span class="ot">-&gt;</span> charFilter remove
    otherwise <span class="ot">-&gt;</span> charFilter translit

  exitSuccess


<span class="ot">argError ::</span> <span class="dt">IO</span> a
argError <span class="fu">=</span> reportErrorMsgs
  [ <span class="st">&quot;usage:&quot;</span>
  , <span class="st">&quot;  translit [FROM] [TO]  -- replace chars in FROM by those in TO&quot;</span>
  , <span class="st">&quot;  translit [REMOVE]     -- remove chars in REMOVE&quot;</span>
  ] <span class="fu">&gt;&gt;</span> exitFailure</code></pre></div>
<p>Note that the arguments of <code>translit</code> are run through <code>bsUnEsc</code>, so that we can easily work with otherwise untypeable characters. (We could, for example, use this to replace <code>charfullwidth</code>.) With <code>translit</code>, many of the small tools we’ve written so far can suddenly be combined to do neat things. As a simple example, put the following text in a file called <code>unicode-test.txt</code>.</p>
<pre><code>\uxyz0 \uxyz1 \uxyz2 \uxyz3
\uxyz4 \uxyz5 \uxyz6 \uxyz7
\uxyz8 \uxyz9 \uxyza \uxyzb
\uxyzc \uxyzd \uxyze \uxyzf</code></pre>
<p>Now the pipeline</p>
<pre><code>cat unicode-test.txt | translit &quot;xyz&quot; &quot;001&quot; | unescape</code></pre>
<p>replaces the <code>x</code>, <code>y</code>, and <code>z</code> with <code>0</code>, <code>0</code>, and <code>1</code> and interprets the <code>\uXXXX</code> as escape codes. This lets us see what several unicode code points look like at one time. With a larger “template” file we could see more characters at a time.</p>
<p><a name="charreplace"></a></p>
<h2 id="charreplace-replace-chars-by-strings-on-stdin"><code>charreplace</code>: replace chars by strings on stdin</h2>
<p>The companion program <code>charreplace</code> requires no new machinery.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-charreplace: replace chars with strings on stdin</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="kw">import </span><span class="dt">STH.Lib</span>
  (charFilter, bsUnEsc, readCharRange, reportErrorMsgs)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  (notflag,from,to) <span class="ot">&lt;-</span> <span class="kw">case</span> args <span class="kw">of</span>
    [as] <span class="ot">-&gt;</span> <span class="kw">case</span> readCharRange as <span class="kw">of</span>
      <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (<span class="dt">False</span>, xs, <span class="st">&quot;&quot;</span>)
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argError
    [<span class="st">&quot;--not&quot;</span>,as] <span class="ot">-&gt;</span> <span class="kw">case</span> readCharRange as <span class="kw">of</span>
      <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (<span class="dt">True</span>, xs, <span class="st">&quot;&quot;</span>)
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argError
    [as,bs] <span class="ot">-&gt;</span> <span class="kw">case</span> readCharRange as <span class="kw">of</span>
      <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (<span class="dt">False</span>, xs, bsUnEsc bs)
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argError
    [<span class="st">&quot;--not&quot;</span>,as,bs] <span class="ot">-&gt;</span> <span class="kw">case</span> readCharRange as <span class="kw">of</span>
      <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (<span class="dt">True</span>, xs, bsUnEsc bs)
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argError
    otherwise          <span class="ot">-&gt;</span> argError

  <span class="kw">let</span>
    remove <span class="fu">=</span> <span class="kw">case</span> notflag <span class="kw">of</span>
      <span class="dt">False</span> <span class="ot">-&gt;</span> filter (not <span class="fu">.</span> (<span class="ot">`elem`</span> from))
      <span class="dt">True</span>  <span class="ot">-&gt;</span> filter (<span class="ot">`elem`</span> from)

  <span class="kw">let</span>
    replace <span class="fu">=</span> <span class="kw">case</span> notflag <span class="kw">of</span>
      <span class="dt">False</span> <span class="ot">-&gt;</span> concatMap
                 (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x<span class="ot">`elem`</span>from <span class="kw">then</span> to <span class="kw">else</span> [x])
      <span class="dt">True</span>  <span class="ot">-&gt;</span> concatMap
                 (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x<span class="ot">`elem`</span>from <span class="kw">then</span> [x] <span class="kw">else</span> to)

  <span class="kw">case</span> to <span class="kw">of</span>
    <span class="st">&quot;&quot;</span>        <span class="ot">-&gt;</span> charFilter remove
    otherwise <span class="ot">-&gt;</span> charFilter replace

  exitSuccess


<span class="ot">argError ::</span> <span class="dt">IO</span> a
argError <span class="fu">=</span> reportErrorMsgs
  [ <span class="st">&quot;usage:&quot;</span>
  , <span class="st">&quot;  charreplace [SOURCE] [TARGET] -- replace each char in SOURCE with TARGET string&quot;</span>
  , <span class="st">&quot;  charreplace [REMOVE]          -- remove each char in REMOVE string&quot;</span>
  , <span class="st">&quot;option:&quot;</span>
  , <span class="st">&quot;  --not  : invert selection (e.g. replace all *except* SOURCE)&quot;</span>
  ] <span class="fu">&gt;&gt;</span> exitFailure</code></pre></div>
<p>It may seem like overkill to split the functionality from <code>translit</code> and <code>charreplace</code> just to make the interface more consistent. But note that <code>charreplace</code> naturally does something we couldn’t have done if the two were rolled together, at least not without making the interface even <em>more</em> inconsistent: <code>charreplace</code> naturally replaces characters by <strong>strings</strong>, not just characters. This is not a trivial distinction; for example, if we have a text file which uses unix-style line endings (<code>\n</code>) and want to convert them to Windows-style line endings (<code>\r\n</code>) we can do this with</p>
<pre><code>charreplace &quot;\n&quot; &quot;\r\n&quot;</code></pre>
<p>I can’t think of a way to do this with <code>translit</code> alone.</p>
<p><a name="escape"></a></p>
<h2 id="escape-replace-non-printable-non-ascii-chars-on-stdin-with-c-escape-sequences"><code>escape</code>: replace non-printable, non-ascii chars on stdin with c escape sequences</h2>
<p>The <code>escape</code> program is the companion of <code>unescape</code>; it replaces any non-printing, non-ASCII characters with C-style escape sequences using only visible ASCII.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- sth-escape: replace non-printable, non-ascii chars on stdin with c escape sequences</span>
<span class="co">--   character-oriented</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess)
<span class="kw">import </span><span class="dt">STH.Lib</span> (charFilter, bsEsc)


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  charFilter bsEsc
  exitSuccess</code></pre></div>
<p>The work is done by <code>bsEsc</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bsEsc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
bsEsc <span class="fu">=</span> concatMap esc

<span class="ot">esc ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
esc x
  <span class="fu">|</span> <span class="dv">32</span> <span class="fu">&lt;=</span> k <span class="fu">&amp;&amp;</span> k <span class="fu">&lt;=</span> <span class="dv">126</span> <span class="fu">=</span> [x]
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">7</span>    <span class="fu">=</span> <span class="st">&quot;\\a&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">8</span>    <span class="fu">=</span> <span class="st">&quot;\\b&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">9</span>    <span class="fu">=</span> <span class="st">&quot;\\t&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">10</span>   <span class="fu">=</span> <span class="st">&quot;\\n&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">11</span>   <span class="fu">=</span> <span class="st">&quot;\\v&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">12</span>   <span class="fu">=</span> <span class="st">&quot;\\f&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">13</span>   <span class="fu">=</span> <span class="st">&quot;\\r&quot;</span>
  <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">27</span>   <span class="fu">=</span> <span class="st">&quot;\\e&quot;</span>
  <span class="fu">|</span> k <span class="fu">&lt;</span> <span class="dv">256</span>   <span class="fu">=</span> <span class="st">&quot;\\x&quot;</span> <span class="fu">++</span> show2Hex k
  <span class="fu">|</span> k <span class="fu">&lt;</span> <span class="dv">65536</span> <span class="fu">=</span> <span class="st">&quot;\\u&quot;</span> <span class="fu">++</span> show4Hex k
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;\\U&quot;</span> <span class="fu">++</span> show8Hex k
  <span class="kw">where</span>
    k <span class="fu">=</span> ord x

    show2Hex t <span class="fu">=</span> reverse <span class="fu">$</span> take <span class="dv">2</span> (reverse (showHex t) <span class="fu">++</span> (repeat <span class="ch">'0'</span>))
    show4Hex t <span class="fu">=</span> reverse <span class="fu">$</span> take <span class="dv">4</span> (reverse (showHex t) <span class="fu">++</span> (repeat <span class="ch">'0'</span>))
    show8Hex t <span class="fu">=</span> reverse <span class="fu">$</span> take <span class="dv">8</span> (reverse (showHex t) <span class="fu">++</span> (repeat <span class="ch">'0'</span>))</code></pre></div>
<p><code>showHex</code> is a library function that returns the hexadecimal expansion of a natural number.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showHex ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">String</span>
showHex n
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>  <span class="fu">=</span> <span class="ch">'-'</span> <span class="fu">:</span> showHex (<span class="fu">-</span>n)
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;0&quot;</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> map toHexDigit (digitsToBase <span class="dv">16</span> n)
      <span class="kw">where</span>
        toHexDigit k
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="ch">'0'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">1</span>    <span class="fu">=</span> <span class="ch">'1'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">2</span>    <span class="fu">=</span> <span class="ch">'2'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">3</span>    <span class="fu">=</span> <span class="ch">'3'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">4</span>    <span class="fu">=</span> <span class="ch">'4'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">5</span>    <span class="fu">=</span> <span class="ch">'5'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">6</span>    <span class="fu">=</span> <span class="ch">'6'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">7</span>    <span class="fu">=</span> <span class="ch">'7'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">8</span>    <span class="fu">=</span> <span class="ch">'8'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">9</span>    <span class="fu">=</span> <span class="ch">'9'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">10</span>   <span class="fu">=</span> <span class="ch">'a'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">11</span>   <span class="fu">=</span> <span class="ch">'b'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">12</span>   <span class="fu">=</span> <span class="ch">'c'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">13</span>   <span class="fu">=</span> <span class="ch">'d'</span>
          <span class="fu">|</span> k <span class="fu">==</span> <span class="dv">14</span>   <span class="fu">=</span> <span class="ch">'e'</span>
          <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="ch">'f'</span></code></pre></div>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
