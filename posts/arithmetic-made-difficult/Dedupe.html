<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Dedupe</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Dedupe</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2017-05-28 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}{\mathsf{compose}}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\apply}{\mathsf{apply}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)
\(\newcommand{\flipB}{\mathsf{flip2}}\)
\(\newcommand{\flipC}{\mathsf{flip3}}\)
\(\newcommand{\flipD}{\mathsf{flip4}}\)
\(\newcommand{\flipE}{\mathsf{flip5}}\)
\(\newcommand{\clone}{\mathsf{clone}}\)
\(\newcommand{\cloneC}{\mathsf{clone3}}\)
\(\newcommand{\composeB}{\mathsf{compose2}}\)
\(\newcommand{\composeC}{\mathsf{compose3}}\)


<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}{\mathsf{natrec}}\)
\(\newcommand{\simprec}{\mathsf{simprec}}\)
\(\newcommand{\bailrec}{\mathsf{bailrec}}\)
\(\newcommand{\mutrec}{\mathsf{mutrec}}\)
\(\newcommand{\dnatrec}{\mathsf{dnatrec}}\)
\(\newcommand{\normrec}{\mathsf{normrec}}\)
\(\newcommand{\findsmallest}{\mathsf{findsmallest}}\)
\(\newcommand{\mnormrec}{\mathsf{mnormrec}}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}{\mathsf{foldr}}\)
\(\newcommand{\foldl}{\mathsf{foldl}}\)
\(\newcommand{\tacunfoldN}{\mathsf{tacunfoldN}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\dfoldr}{\mathsf{dfoldr}}\)
\(\newcommand{\cfoldr}{\mathsf{cfoldr}}\)
\(\newcommand{\bfoldr}{\mathsf{bfoldr}}\)
\(\newcommand{\dbfoldr}{\mathsf{dbfoldr}}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Dedupe.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Dedupe</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( dedupeL, dedupeR, _test_dedupe, main_dedupe</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Booleans</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">NaturalNumbers</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Lists</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Snoc</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Reverse</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">PrefixAndSuffix</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Filter</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Elt</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">Unique</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Delete</span></a></code></pre></div>
<p>Today we’ll define a function <code>dedupe</code> which removes any “duplicate” items in a list. Before jumping in, let’s think a little about what such a function should do. For example, say we run <code>dedupe</code> on the list <span class="math display">\[\langle a, b, a, c, a \rangle.\]</span> The item <span class="math inline">\(a\)</span> appears three times, so after deduplicating it should only appear once. We’d prefer not to change the relative order of items in the list, so all we can do is remove two of the <span class="math inline">\(a\)</span>s. There are three ways to do this, resulting in either <span class="math display">\[\langle a, b, c \rangle,\]</span> <span class="math display">\[\langle b, a, c \rangle,\]</span> or <span class="math display">\[\langle b, c, a \rangle.\]</span> That is, we can keep the <em>first</em> copy of <span class="math inline">\(a\)</span>, the <em>last</em> copy, or <em>some middle</em> copy. It seems to me that keeping some middle copy is not the most general solution. If an item appears only twice, there is no middle appearance, and if an item appears more than three times then there is no <em>unique</em> middle appearance to keep. So it appears the two most general options are to keep the first copy of an item or to keep the last copy. We will call these strategies <span class="math inline">\(\dedupeL\)</span> (<strong>dedup</strong>licate from the <strong>L</strong>eft) and <span class="math inline">\(\dedupeR\)</span> (<strong>dedup</strong>licate from the <strong>R</strong>ight), respectively. We’ll see that these two options are related. We’ll start with <span class="math inline">\(\dedupeL\)</span>.</p>
<p>We want to implement <span class="math inline">\(\dedupeL\)</span> as either a right fold or a left fold. But which one? Say our input list is <span class="math display">\[x = \langle a, b, c \rangle.\]</span> Note that <span class="math inline">\(\foldr(\varepsilon)(\varphi)(x)\)</span> will expand into <span class="math display">\[\varphi(a, \varphi(b, \varphi(c, \varepsilon))),\]</span> while <span class="math inline">\(\foldl(\varepsilon){\varphi}(x)\)</span> will expand into <span class="math display">\[\varphi(c, \varphi(b, \varphi(a, \varepsilon))).\]</span> Note that <span class="math inline">\(\dedupeL\)</span> has to process the entire input list, so both of these computations will evaluate completely from the inside out. So which one makes more sense, keeping in mind that <span class="math inline">\(\dedupeL\)</span> needs to detect the <em>first</em> appearance of each item?</p>
<p>With this handwavy mess in mind, we define <span class="math inline">\(\dedupeL\)</span> as follows.</p>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> be a set. Define <span class="math inline">\(\varphi : A \times \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\varphi(a,x) = \cons(a,\delete(a,x)).\]</span> Now define <span class="math inline">\(\dedupeL : \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\dedupeL(x) = \foldr(\nil)(\varphi)(x).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">dedupeL ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">dedupeL <span class="fu">=</span> foldr nil phi</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    phi a x <span class="fu">=</span> cons a (delete a x)</a></code></pre></div>
</div>
<p>Since <span class="math inline">\(\dedupeL\)</span> is defined as a foldr, it can be characterized as the unique solution to a system of functional equations.</p>
<div class="corollary">
<p>Let <span class="math inline">\(A\)</span> be a set. <span class="math inline">\(\dedupeL\)</span> is the unique map <span class="math inline">\(f : \lists{A} \rightarrow \lists{A}\)</span> satisfying the following equations for all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span>. <span class="math display">\[\left\{\begin{array}{l}
 f(\nil) = \nil \\
 f(\cons(a,x)) = \cons(a,\delete(a)(f(x)))
\end{array}\right.\]</span></p>
<div class="test">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">_test_dedupeL_nil ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">_test_dedupeL_nil t <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  testName <span class="st">&quot;dedupeL(nil) == nil&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  eq (dedupeL nil) (nil <span class="ot">`withTypeOf`</span> t)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">_test_dedupeL_cons ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">_test_dedupeL_cons _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  testName <span class="st">&quot;dedupeL(cons(a,x)) == cons(a,delete(a)(dedupeL(x)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  \a x <span class="ot">-&gt;</span> eq (dedupeL (cons a x)) (cons a (delete a (dedupeL x)))</a></code></pre></div>
</div>
</div>
<p>Now <span class="math inline">\(\dedupeL\)</span> and <span class="math inline">\(\delete\)</span> commute.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, with <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math display">\[\delete(a,\dedupeL(x)) = \dedupeL(\delete(a,x)).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\nil)) \\
 &amp; = &amp; \delete(a,\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \dedupeL(\nil) \\
 &amp; = &amp; \dedupeL(\delete(a,\nil))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(a\)</span> for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(b \in A\)</span>. We consider two possibilities. If <span class="math inline">\(b = a\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\cons(b,x))) \\
 &amp; = &amp; \delete(a,\cons(b,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \delete(a,\delete(b,\dedupeL(x))) \\
 &amp; = &amp; \delete(a,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \delete(a,\dedupeL(x)) \\
 &amp; = &amp; \dedupeL(\delete(a,x)) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(a,x))) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(b,x)))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(b \neq a\)</span>. Now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\cons(b,x))) \\
 &amp; = &amp; \delete(a,\cons(b,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(a,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(b,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(b,\dedupeL(\delete(a,x)))) \\
 &amp; = &amp; \dedupeL(\cons(b,\delete(a,x))) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(b,x)))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">_test_dedupeL_delete ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">_test_dedupeL_delete _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  testName <span class="st">&quot;dedupeL(delete(a,x)) == delete(a,dedupeL(x))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  \a x <span class="ot">-&gt;</span> eq (dedupeL (delete a x)) (delete a (dedupeL x))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span>s are <span class="math inline">\(\unique\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeL(\nil)) \\
 &amp; = &amp; \unique(\nil) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Using the inductive hypothesis, we have <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>, so that <span class="math inline">\(\unique(\delete(a,\dedupeL(x))) = \btrue\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \unique(\cons(a,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\bnot(\elt(a,\delete(a,\dedupeL(x)))),\unique(\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\btrue,\unique(\delete(a,\dedupeL(x)))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/And.html#thm-and-true-left}
   = &amp; \unique(\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">_test_dedupeL_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">_test_dedupeL_unique _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  testName <span class="st">&quot;unique(dedupeL(x)) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  \x <span class="ot">-&gt;</span> unique (dedupeL x)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> preserves <span class="math inline">\(\prefix\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x,y \in \lists{A}\)</span>. If <span class="math inline">\(\prefix(x,y) = \btrue\)</span> then <span class="math inline">\(\prefix(\dedupeL(x),\dedupeL(y)) = \btrue\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\prefix(x,y) = \prefix(\nil,y) = \btrue\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prefix(\dedupeL(x),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\dedupeL(\nil),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\nil,\dedupeL(y)) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(y\)</span> for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Suppose further that <span class="math inline">\(\prefix(\cons(a,x),y) = \btrue\)</span>. Now we must have <span class="math inline">\(y = \cons(a,u)\)</span> where <span class="math inline">\(\prefix(x,u) = \btrue\)</span>. Using the inductive hypothesis, we have <span class="math display">\[\prefix(\dedupeL(x),\dedupeL(u)) = \btrue,\]</span> so that <span class="math display">\[\prefix(\delete(a,\dedupeL(x)),\delete(a,\dedupeL(u))) = \btrue.\]</span> Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prefix(\dedupeL(\cons(a,x)),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\dedupeL(\cons(a,x)),\dedupeL(\cons(a,u))) \\
 &amp; = &amp; \prefix(\cons(a,\delete(a,\dedupeL(x))),\cons(a,\delete(a,\dedupeL(u)))) \\
 &amp; = &amp; \prefix(\delete(a,\dedupeL(x)),\delete(a,\dedupeL(u))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">_test_dedupeL_prefix ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">_test_dedupeL_prefix _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  testName <span class="st">&quot;prefix(x,y) ==&gt; prefix(dedupeL(x),dedupeL(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> <span class="kw">if</span> prefix x y</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> prefix (dedupeL x) (dedupeL y)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> fixes <span class="math inline">\(\unique\)</span>s.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\beq(x,\dedupeL(x)) = \unique(x)\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \beq(x,\dedupeL(x)) \\
 &amp; = &amp; \beq(\nil,\dedupeL(\nil)) \\
 &amp; = &amp; \beq(\nil,\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Testing.html#thm-eq-reflexive}
   = &amp; \btrue \\
 &amp; = &amp; \unique(\nil) \\
 &amp; = &amp; \unique(x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \beq(\cons(a,x),\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \beq(\cons(a,x),\cons(a,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\beq(a,a),\beq(x,\delete(a,\dedupeL(x)))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Testing.html#thm-eq-reflexive}
   = &amp; \band(\btrue,\beq(x,\delete(a,\dedupeL(x)))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/And.html#thm-and-true-left}
   = &amp; \beq(x,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \beq(x,\dedupeL(\delete(a,x))) \\
 &amp; = &amp; Q.
\end{eqnarray*}\]</span> We now consider two possibilities. If <span class="math inline">\(\elt(a,x) = \bfalse\)</span>, then <span class="math display">\[\beq(x,\delete(a,x)) = \bnot(\elt(a,x)) = \btrue,\]</span> and using the inductive hypothesis on <span class="math inline">\(x\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; Q \\
 &amp; = &amp; \beq(x,\dedupeL(x)) \\
 &amp; = &amp; \unique(x) \\
 &amp;     \href{/posts/arithmetic-made-difficult/And.html#thm-and-true-left}
   = &amp; \band(\btrue,\unique(x)) \\
 &amp; = &amp; \band(\bnot(\elt(a,x)),\unique(x)) \\
 &amp; = &amp; \unique(\cons(a,x))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(\elt(a,x) = \btrue\)</span>. Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \elt(a,\dedupeL(\delete(a,x))) \\
 &amp; = &amp; \elt(a,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \bfalse,
\end{eqnarray*}\]</span> so that <span class="math inline">\(\beq(x,\dedupeL(\delete(a,x))) = \bfalse\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; Q \\
 &amp; = &amp; \bfalse \\
 &amp;     \href{/posts/arithmetic-made-difficult/And.html#thm-and-false-left}
   = &amp; \band(\bfalse,\unique(x)) \\
 &amp; = &amp; \band(\bnot(\elt(a,x)),\unique(x)) \\
 &amp; = &amp; \unique(\cons(a,x))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">_test_dedupeL_eq_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">_test_dedupeL_eq_unique _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  testName <span class="st">&quot;eq(x,dedupeL(x)) == unique(x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (eq x (dedupeL x)) (unique x)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> is idempotent.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\dedupeL(\dedupeL(x)) = \dedupeL(x)\)</span>.</p>
<div class="proof">
<p>Note that <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>, so that <span class="math inline">\(\dedupeL(\dedupeL(x)) = \dedupeL(x)\)</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">_test_dedupeL_idempotent ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">_test_dedupeL_idempotent _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  testName <span class="st">&quot;dedupeL(dedupeL(x)) == dedupeL(x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (dedupeL (dedupeL x)) (dedupeL x)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> interacts with <span class="math inline">\(\snoc\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span>, we have <span class="math display">\[\dedupeL(\snoc(a,x)) = \bif{\elt(a,x)}{\dedupeL(x)}{\snoc(a,\dedupeL(x))}.\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeL(\snoc(a,\nil)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Snoc.html#cor-snoc-nil}
   = &amp; \dedupeL(\cons(a,\nil)) \\
 &amp; = &amp; \cons(a,\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#cor-if-false}
   = &amp; \bif{\bfalse}{\nil}{\cons(a,\nil)} \\
 &amp; = &amp; \bif{\elt(a,\nil)}{\nil}{\cons(a,\nil)} \\
 &amp; = &amp; \bif{\elt(a,\nil)}{\dedupeL(\nil)}{\snoc(a,\nil)}
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(a\)</span> for some <span class="math inline">\(x\)</span>, and let <span class="math inline">\(b \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeL(\snoc(a,\cons(b,x))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Snoc.html#cor-snoc-cons}
   = &amp; \dedupeL(\cons(b,\snoc(a,x))) \\
 &amp; = &amp; \cons(b,\delete(b)(\dedupeL(\snoc(a,x)))) \\
 &amp; = &amp; \cons(b,\delete(b)(\bif{\elt(a,x)}{\dedupeL(x)}{\snoc(a,\dedupeL(x))})) \\
 &amp; = &amp; \bif{\elt(a,x)}{\cons(b,\delete(b)(\dedupeL(x)))}{\cons(b,\delete(b)(\snoc(a,\dedupeL(x))))} \\
 &amp; = &amp; \bif{\elt(a,x)}{\dedupeL(\cons(b,x))}{\cons(b,\delete(b)(\snoc(a,\dedupeL(x))))} \\
 &amp; = &amp; \bif{\elt(a,x)}{\dedupeL(\cons(b,x))}{\cons(b,\bif{\beq(a,b)}{\delete(b)(\dedupeL(x))}{\snoc(a,\delete(b)(\dedupeL(x)))})} \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#thm-iffunc}
   = &amp; \bif{\elt(a,x)}{\dedupeL(\cons(b,x))}{\bif{\beq(a,b)}{\cons(b,\delete(b)(\dedupeL(x)))}{\cons(b,\snoc(a,\delete(b)(\dedupeL(x))))}} \\
 &amp; = &amp; \bif{\elt(a,x)}{\dedupeL(\cons(b,x))}{\bif{\beq(a,b)}{\dedupeL(\cons(b,x))}{\cons(b,\snoc(a,\delete(b)(\dedupeL(x))))}} \\
 &amp; = &amp; \bif{\bor(\beq(a,b),\elt(a,x))}{\dedupeL(\cons(b,x))}{\cons(b,\snoc(a,\delete(b)(\dedupeL(x))))} \\
 &amp; = &amp; \bif{\elt(a,\cons(b,x))}{\dedupeL(\cons(b,x))}{\cons(b,\snoc(a,\delete(b)(\dedupeL(x))))} \\
 &amp;     \href{/posts/arithmetic-made-difficult/Snoc.html#cor-snoc-cons}
   = &amp; \bif{\elt(a,\cons(b,x))}{\dedupeL(\cons(b,x))}{\snoc(a,\cons(b,\delete(b)(\dedupeL(x))))} \\
 &amp; = &amp; \bif{\elt(a,\cons(b,x))}{\dedupeL(\cons(b,x))}{\snoc(a,\dedupeL(\cons(b,x)))}
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">_test_dedupeL_snoc ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">_test_dedupeL_snoc _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  testName <span class="st">&quot;dedupeL(snoc(a,x)) == if(elt(a,x),dedupeL(x),snoc(a,dedupeL(x)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  \a x <span class="ot">-&gt;</span> eq</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    (dedupeL (snoc a x))</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    (<span class="kw">if</span> elt a x <span class="kw">then</span> dedupeL x <span class="kw">else</span> snoc a (dedupeL x))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> interacts with <span class="math inline">\(\elt\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span>, we have <span class="math display">\[\elt(a,\dedupeL(x)) = \elt(a,x).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \elt(a,\dedupeL(\nil)) \\
 &amp; = &amp; \elt(a,\nil)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(a\)</span> for some <span class="math inline">\(x\)</span>, and let <span class="math inline">\(b \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \elt(a,\dedupeL(\cons(b,x))) \\
 &amp; = &amp; \elt(a,\cons(b,\delete(b)(\dedupeL(x)))) \\
 &amp; = &amp; \bif{\beq(a,b)}{\btrue}{\elt(a,\delete(b)(\dedupeL(x)))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\btrue}{\bif{\beq(a,b)}{\bfalse}{\elt(a,\dedupeL(x))}} \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#thm-if-prune-false}
   = &amp; \bif{\beq(a,b)}{\btrue}{\elt(a,\dedupeL(x))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\btrue}{\elt(a,x)} \\
 &amp; = &amp; \elt(a,\cons(b,x))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">_test_dedupeL_elt ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">_test_dedupeL_elt _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  testName <span class="st">&quot;elt(a,dedupeL(x)) == elt(a,x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  \a x <span class="ot">-&gt;</span> eq (elt a (dedupeL x)) (elt a x)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> commutes with <span class="math inline">\(\filter\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(p : A \rightarrow \bool\)</span> a predicate. For all <span class="math inline">\(x \in \lists{A}\)</span>, we have <span class="math display">\[\dedupeL(\filter(p)(x)) = \filter(p)(\dedupeL(x)).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeL(\filter(p)(\nil)) \\
 &amp; = &amp; \dedupeL(\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \filter(p)(\nil) \\
 &amp; = &amp; \filter(p)(\dedupeL(\nil))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equation holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. We consider the two possibilities for <span class="math inline">\(p(a)\)</span>. If <span class="math inline">\(p(a) = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \filter(p)(\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \filter(p)(\cons(a,\delete(a)(\dedupeL(x)))) \\
 &amp; = &amp; \bif{p(a)}{\cons(a,\filter(p)(\delete(a)(\dedupeL(x))))}{\filter(p)(\delete(a)(\dedupeL(x)))} \\
 &amp; = &amp; \bif{\btrue}{\cons(a,\filter(p)(\delete(a)(\dedupeL(x))))}{\filter(p)(\delete(a)(\dedupeL(x)))} \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#cor-if-true}
   = &amp; \cons(a,\filter(p)(\delete(a)(\dedupeL(x)))) \\
 &amp; = &amp; \cons(a,\delete(a)(\filter(a)(\dedupeL(x)))) \\
 &amp; = &amp; \cons(a,\delete(a)(\dedupeL(\filter(p)(x)))) \\
 &amp; = &amp; \dedupeL(\cons(a,\filter(p)(x))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#cor-if-true}
   = &amp; \dedupeL(\bif{\btrue}{\cons(a,\filter(p)(x))}{\filter(p)(x)}) \\
 &amp; = &amp; \dedupeL(\filter(p)(\cons(a,x)))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(p(a) = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \filter(p)(\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \filter(p)(\cons(a,\delete(a)(\dedupeL(x)))) \\
 &amp; = &amp; \bif{p(a)}{\cons(a,\filter(p)(\delete(a)(\dedupeL(x))))}{\filter(p)(\delete(a)(\dedupeL(x)))} \\
 &amp; = &amp; \bif{\bfalse}{\cons(a,\filter(p)(\delete(a)(\dedupeL(x))))}{\filter(p)(\delete(a)(\dedupeL(x)))} \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#cor-if-false}
   = &amp; \filter(p)(\delete(a)(\dedupeL(x))) \\
 &amp; = &amp; \delete(a)(\filter(p)(\dedupeL(x))) \\
 &amp; = &amp; \filter(p)(\dedupeL(x)) \\
 &amp; = &amp; \dedupeL(\filter(p)(x)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Booleans.html#cor-if-false}
   = &amp; \dedupeL(\bif{\bfalse}{\cons(a,\filter(p)(x))}{\filter(p)(x)}) \\
 &amp; = &amp; \dedupeL(\bif{p(a)}{\cons(a,\filter(p)(x))}{\filter(p)(x)}) \\
 &amp; = &amp; \dedupeL(\filter(p)(\cons(a,x)))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_test_dedupeL_filter ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">_test_dedupeL_filter _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  testName <span class="st">&quot;dedupeL(filter(p)(x)) == filter(p)(dedupeL(x))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  \p x <span class="ot">-&gt;</span> eq (dedupeL (filter p x)) (filter p (dedupeL x))</a></code></pre></div>
</div>
</div>
<p>We define <span class="math inline">\(\dedupeR\)</span> in terms of <span class="math inline">\(\dedupeL\)</span>.</p>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> be a set. Define <span class="math inline">\(\dedupeL : \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\dedupeL(x) = \rev(\dedupeR(\rev(x))).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">dedupeR ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">dedupeR <span class="fu">=</span> rev <span class="fu">.</span> dedupeL <span class="fu">.</span> rev</a></code></pre></div>
</div>
<p>The defining equations for <span class="math inline">\(\dedupeL\)</span> have equivalents for <span class="math inline">\(\dedupeR\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span> we have the following.</p>
<ol type="1">
<li><span class="math inline">\(\dedupeR(\nil) = \nil\)</span>.</li>
<li><span class="math inline">\(\dedupeR(\snoc(a,x)) = \snoc(a,\delete(a,\dedupeR(x)))\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR(\nil) \\
 &amp; = &amp; \rev(\dedupeL(\rev(\nil))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Reverse.html#cor-rev-nil}
= &amp; \rev(\dedupeL(\nil)) \\
 &amp; = &amp; \rev(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Reverse.html#cor-rev-nil}
= &amp; \nil
\end{eqnarray*}\]</span> as needed.</li>
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR(\snoc(a,x)) \\
 &amp; = &amp; \rev(\dedupeL(\rev(\snoc(a,x)))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Reverse.html#thm-rev-snoc}
= &amp; \rev(\dedupeL(\cons(a,\rev(x)))) \\
 &amp; = &amp; \rev(\cons(a,\delete(a,\dedupeL(\rev(x))))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Reverse.html#cor-rev-cons}
= &amp; \snoc(a,\rev(\delete(a,\dedupeL(\rev(x))))) \\
 &amp; = &amp; \snoc(a,\delete(a,\rev(\dedupeL(\rev(x))))) \\
 &amp; = &amp; \snoc(a,\delete(a,\dedupeR(x)))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_test_dedupeR_nil ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">_test_dedupeR_nil t <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  testName <span class="st">&quot;dedupeR(nil) == nil&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  eq (dedupeR nil) (nil <span class="ot">`withTypeOf`</span> t)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ot">_test_dedupeR_snoc ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">_test_dedupeR_snoc _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  testName <span class="st">&quot;dedupeR(snoc(a,x)) == snoc(a,delete(a)(dedupeR(x)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  \a x <span class="ot">-&gt;</span> eq (dedupeR (snoc a x)) (snoc a (delete a (dedupeR x)))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeR\)</span>s are unique.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\unique(\dedupeR(x)) = \btrue\)</span>.</p>
<div class="proof">
<p>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeR(x)) \\
 &amp; = &amp; \unique(\rev(\dedupeL(\rev(x)))) \\
 &amp; = &amp; \unique(\dedupeL(\rev(x))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">_test_dedupeR_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">_test_dedupeR_unique _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  testName <span class="st">&quot;unique(dedupeR(x)) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (unique (dedupeR x)) true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\dedupeR\)</span> is idempotent.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\dedupeR(\dedupeR(x)) = \dedupeR(x)\)</span>.</p>
<div class="proof">
<p>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR \circ \dedupeR \\
 &amp; = &amp; \rev \circ \dedupeL \circ \rev \circ \rev \circ \dedupeL \circ \rev \\
 &amp; = &amp; \rev \circ \dedupeL \circ \dedupeL \circ \rev \\
 &amp; = &amp; \rev \circ \dedupeL \circ \rev \\
 &amp; = &amp; \dedupeR
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">_test_dedupeR_idempotent ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">_test_dedupeR_idempotent _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  testName <span class="st">&quot;dedupeR(dedupeR(x)) == dedupeR(x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (dedupeR (dedupeR x)) (dedupeR x)</a></code></pre></div>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>Suite:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_test_dedupe ::</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  ( <span class="dt">TypeName</span> a, <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  , <span class="dt">TypeName</span> (t a), <span class="dt">List</span> t</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  , <span class="dt">Equal</span> (t a), <span class="dt">Show</span> (t a), <span class="dt">Arbitrary</span> (t a), <span class="dt">Equal</span> (t (t a))</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  ) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">_test_dedupe t size cases <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  testLabel1 <span class="st">&quot;dedupeL &amp; dedupeR&quot;</span> t</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="kw">let</span> args <span class="fu">=</span> testArgs size cases</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  runTest args (_test_dedupeL_nil t)</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  runTest args (_test_dedupeL_cons t)</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  runTest args (_test_dedupeL_delete t)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  runTest args (_test_dedupeL_unique t)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  runTest args (_test_dedupeL_prefix t)</a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  runTest args (_test_dedupeL_eq_unique t)</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  runTest args (_test_dedupeL_idempotent t)</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  runTest args (_test_dedupeL_snoc t)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">  runTest args (_test_dedupeL_elt t)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20">  runTest args (_test_dedupeL_filter t)</a>
<a class="sourceLine" id="cb16-21" data-line-number="21"></a>
<a class="sourceLine" id="cb16-22" data-line-number="22">  runTest args (_test_dedupeR_nil t)</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">  runTest args (_test_dedupeR_snoc t)</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">  runTest args (_test_dedupeR_unique t)</a>
<a class="sourceLine" id="cb16-25" data-line-number="25">  runTest args (_test_dedupeR_idempotent t)</a></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">main_dedupe ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">main_dedupe <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  _test_dedupe (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>)  <span class="dv">50</span> <span class="dv">500</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  _test_dedupe (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) <span class="dv">50</span> <span class="dv">500</span></a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
