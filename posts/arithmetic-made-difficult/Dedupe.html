<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Dedupe</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../pages/contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Dedupe</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2017-05-28 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\swap}{\mathsf{swap}}\)
\(\newcommand{\pair}{\mathsf{pair}}\)
\(\newcommand{\assocL}{\mathsf{assocL}}\)
\(\newcommand{\assocR}{\mathsf{assocR}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\simprec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)
\(\newcommand{\bailrec}[4]{\left(\!\left[ #1, #2, #3, #4 \right]\!\right)}\)
\(\newcommand{\mutrec}[3]{\left\{\!\left[ #1, #2, #3 \right]\!\right\}}\)

<!--- natural number arithmetic ---->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- list -->
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\foldl}[2]{\mathsf{foldl}(#1,#2)}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p>This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Dedupe.lhs">the source</a> into GHCi and play along.</p>

<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Dedupe</span>
<span class="ot">&gt;</span>   ( dedupeL, dedupeR, _test_dedupe, main_dedupe
<span class="ot">&gt;</span>   ) <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Booleans</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Tuples</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">NaturalNumbers</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Plus</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Lists</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Reverse</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Length</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Map</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Cat</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">UnfoldN</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Zip</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prefix</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">AllAndAny</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">TailsAndInits</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Filter</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Elt</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Count</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Repeat</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Select</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Unique</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Delete</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> ()
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Text.Show.Functions</span></code></pre></div>
<p>Today we’ll define a function <code>dedupe</code> which removes any “duplicate” items in a list. Before jumping in, let’s think a little about what such a function should do. For example, say we run <code>dedupe</code> on the list <span class="math display">\[\langle a, b, a, c, a \rangle.\]</span> The item <span class="math inline">\(a\)</span> appears three times, so after deduplicating it should only appear once. We’d prefer not to change the relative order of items in the list, so all we can do is remove two of the <span class="math inline">\(a\)</span>s. There are three ways to do this, resulting in either <span class="math display">\[\langle a, b, c \rangle,\]</span> <span class="math display">\[\langle b, a, c \rangle,\]</span> or <span class="math display">\[\langle b, c, a \rangle.\]</span> That is, we can keep the <em>first</em> copy of <span class="math inline">\(a\)</span>, the <em>last</em> copy, or <em>some middle</em> copy. It seems to me that keeping some middle copy is not the most general solution. If an item appears only twice, there is no middle appearance, and if an item appears more than three times then there is no <em>unique</em> middle appearance to keep. So it appears the two most general options are to keep the first copy of an item or to keep the last copy. We will call these strategies <span class="math inline">\(\dedupeL\)</span> (<strong>dedup</strong>licate from the <strong>L</strong>eft) and <span class="math inline">\(\dedupeR\)</span> (<strong>dedup</strong>licate from the <strong>R</strong>ight), respectively. We’ll see that these two options are related. We’ll start with <span class="math inline">\(\dedupeL\)</span>.</p>
<p>We want to implement <span class="math inline">\(\dedupeL\)</span> as either a right fold or a left fold. But which one? Say our input list is <span class="math display">\[x = \langle a, b, c \rangle.\]</span> Note that <span class="math inline">\(\foldr{\varepsilon}{\varphi}(x)\)</span> will expand into <span class="math display">\[\varphi(a, \varphi(b, \varphi(c, \varepsilon))),\]</span> while <span class="math inline">\(\foldl{\varepsilon}{\varphi}(x)\)</span> will expand into <span class="math display">\[\varphi(c, \varphi(b, \varphi(a, \varepsilon))).\]</span> Note that <span class="math inline">\(\dedupeL\)</span> has to process the entire input list, so both of these computations will evaluate completely from the inside out. So which one makes more sense, keeping in mind that <span class="math inline">\(\dedupeL\)</span> needs to detect the <em>first</em> appearance of each item?</p>
<p>With this handwavy mess in mind, we define <span class="math inline">\(\dedupeL\)</span> as follows.</p>
<div class="result">
<div class="defn">
<p>
<p>Let <span class="math inline">\(A\)</span> be a set. Define <span class="math inline">\(\varphi : A \times \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\varphi(a,x) = \cons(a,\delete(a,x)).\]</span> Now define <span class="math inline">\(\dedupeL : \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\dedupeL(x) = \foldr{\nil}{\varphi}(x).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dedupeL ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a
<span class="ot">&gt;</span> dedupeL <span class="fu">=</span> foldr nil phi
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     phi a x <span class="fu">=</span> cons a (delete a x)</code></pre></div>
</p>
</div>
</div>
<p>The following result suggests an alternative implementation.</p>
<div class="result">
<div class="thm">
<p>
<p>Let <span class="math inline">\(A\)</span> be a set.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\dedupeL(\nil) = \nil\)</span>.</li>
<li><span class="math inline">\(\dedupeL(\cons(a,x)) = \cons(a,\delete(a,\dedupeL(x)))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeL(\nil) \\
 &amp; = &amp; \foldr{\nil}{\varphi}(\nil) \\
 &amp; = &amp; \nil
\end{eqnarray*}\]</span> as claimed.</li>
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeL(\cons(a,x)) \\
 &amp; = &amp; \foldr{\nil}{\varphi}(\cons(a,x)) \\
 &amp; = &amp; \varphi(a,\foldr{\nil}{\varphi}(x)) \\
 &amp; = &amp; \varphi(a,\dedupeL(x)) \\
 &amp; = &amp; \cons(a,\delete(a,\dedupeL(x)))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dedupeL' ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a
<span class="ot">&gt;</span> dedupeL' x <span class="fu">=</span> <span class="kw">case</span> listShape x <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Nil</span>      <span class="ot">-&gt;</span> nil
<span class="ot">&gt;</span>   <span class="dt">Cons</span> a u <span class="ot">-&gt;</span> cons a (delete a (dedupeL' u))</code></pre></div>
<p>Now <span class="math inline">\(\dedupeL\)</span> and <span class="math inline">\(\delete\)</span> commute.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set, with <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math display">\[\delete(a,\dedupeL(x)) = \dedupeL(\delete(a,x)).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\nil)) \\
 &amp; = &amp; \delete(a,\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \dedupeL(\nil) \\
 &amp; = &amp; \dedupeL(\delete(a,\nil))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(a\)</span> for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(b \in A\)</span>. We consider two possibilities. If <span class="math inline">\(b = a\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\cons(b,x))) \\
 &amp; = &amp; \delete(a,\cons(b,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \delete(a,\delete(b,\dedupeL(x))) \\
 &amp; = &amp; \delete(a,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \delete(a,\dedupeL(x)) \\
 &amp; = &amp; \dedupeL(\delete(a,x)) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(a,x))) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(b,x)))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(b \neq a\)</span>. Now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \delete(a,\dedupeL(\cons(b,x))) \\
 &amp; = &amp; \delete(a,\cons(b,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(a,\delete(b,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(b,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \cons(b,\delete(b,\dedupeL(\delete(a,x)))) \\
 &amp; = &amp; \dedupeL(\cons(b,\delete(a,x))) \\
 &amp; = &amp; \dedupeL(\delete(a,\cons(b,x)))
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span>s are <span class="math inline">\(\unique\)</span>:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>.
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeL(\nil)) \\
 &amp; = &amp; \unique(\nil) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Using the inductive hypothesis, we have <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>, so that <span class="math inline">\(\unique(\delete(a,\dedupeL(x))) = \btrue\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \unique(\cons(a,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\all(\bnot(\beq(a,-)),\delete(a,\dedupeL(x))),\unique(\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\btrue,\unique(\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \unique(\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> preserves <span class="math inline">\(\prefix\)</span>:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x,y \in \lists{A}\)</span>. If <span class="math inline">\(\prefix(x,y) = \btrue\)</span> then <span class="math inline">\(\prefix(\dedupeL(x),\dedupeL(y)) = \btrue\)</span>.
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\prefix(x,y) = \prefix(\nil,y) = \btrue\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prefix(\dedupeL(x),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\dedupeL(\nil),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\nil,\dedupeL(y)) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(y\)</span> for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Suppose further that <span class="math inline">\(\prefix(\cons(a,x),y) = \btrue\)</span>. Now we must have <span class="math inline">\(y = \cons(a,u)\)</span> where <span class="math inline">\(\prefix(x,u) = \btrue\)</span>. Using the inductive hypothesis, we have <span class="math display">\[\prefix(\dedupeL(x),\dedupeL(u)) = \btrue,\]</span> so that <span class="math display">\[\prefix(\delete(a,\dedupeL(x)),\delete(a,\dedupeL(u))) = \btrue.\]</span> Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prefix(\dedupeL(\cons(a,x)),\dedupeL(y)) \\
 &amp; = &amp; \prefix(\dedupeL(\cons(a,x)),\dedupeL(\cons(a,u))) \\
 &amp; = &amp; \prefix(\cons(a,\delete(a,\dedupeL(x))),\cons(a,\delete(a,\dedupeL(u)))) \\
 &amp; = &amp; \prefix(\delete(a,\dedupeL(x)),\delete(a,\dedupeL(u))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> fixes <span class="math inline">\(\unique\)</span>s.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\beq(x,\dedupeL(x)) = \unique(x)\)</span>.
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \beq(x,\dedupeL(x)) \\
 &amp; = &amp; \beq(\nil,\dedupeL(\nil)) \\
 &amp; = &amp; \beq(\nil,\nil) \\
 &amp; = &amp; \btrue \\
 &amp; = &amp; \unique(\nil) \\
 &amp; = &amp; \unique(x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \beq(\cons(a,x),\dedupeL(\cons(a,x))) \\
 &amp; = &amp; \beq(\cons(a,x),\cons(a,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\beq(a,a),\beq(x,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \band(\btrue,\beq(x,\delete(a,\dedupeL(x)))) \\
 &amp; = &amp; \beq(x,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \beq(x,\dedupeL(\delete(a,x))) \\
 &amp; = &amp; Q.
\end{eqnarray*}\]</span> We now consider two possibilities. If <span class="math inline">\(\elt(a,x) = \bfalse\)</span>, then <span class="math display">\[\beq(x,\delete(a,x)) = \bnot(\elt(a,x)) = \btrue,\]</span> and using the inductive hypothesis on <span class="math inline">\(x\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; Q \\
 &amp; = &amp; \beq(x,\dedupeL(x)) \\
 &amp; = &amp; \unique(x) \\
 &amp; = &amp; \band(\btrue,\unique(x)) \\
 &amp; = &amp; \band(\bnot(\elt(a,x)),\unique(x)) \\
 &amp; = &amp; \unique(\cons(a,x))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(\elt(a,x) = \btrue\)</span>. Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \elt(a,\dedupeL(\delete(a,x))) \\
 &amp; = &amp; \elt(a,\delete(a,\dedupeL(x))) \\
 &amp; = &amp; \bfalse,
\end{eqnarray*}
so that $\beq(x,\dedupeL(\delete(a,x))) = \bfalse. Now
\]</span>
\begin{eqnarray*}
 &amp;   &amp; Q \\
 &amp; = &amp; \bfalse \\
 &amp; = &amp; \band(\bfalse,\unique(x)) \\
 &amp; = &amp; \band(\bnot(\elt(a,x)),\unique(x)) \\
 &amp; = &amp; \unique(\cons(a,x))
\end{eqnarray*}
$$ as needed.
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeL\)</span> is idempotent.</p>
<div class="result">
<div class="corollary">
<p>
Let <span class="math inline">\(A\)</span> be a set and <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\dedupeL(\dedupeL(x)) = \dedupeL(x)\)</span>.
</p>
</div>
<div class="proof">
<p>
Note that <span class="math inline">\(\unique(\dedupeL(x)) = \btrue\)</span>, so that <span class="math inline">\(\dedupeL(\dedupeL(x)) = \dedupeL(x)\)</span> as claimed.
</p>
</div>
</div>
<p>Now for <span class="math inline">\(\dedupeR\)</span>:</p>
<div class="result">
<div class="defn">
<p>
<p>Let <span class="math inline">\(A\)</span> be a set. Define <span class="math inline">\(\dedupeL : \lists{A} \rightarrow \lists{A}\)</span> by <span class="math display">\[\dedupeL(x) = \rev(\dedupeR(\rev(x))).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dedupeR ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a
<span class="ot">&gt;</span> dedupeR <span class="fu">=</span> rev <span class="fu">.</span> dedupeL <span class="fu">.</span> rev</code></pre></div>
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeR\)</span>s are unique:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\unique(\dedupeR(x)) = \btrue\)</span>.
</p>
</div>
<div class="proof">
<p>
Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unique(\dedupeR(x)) \\
 &amp; = &amp; \unique(\rev(\dedupeL(\rev(x)))) \\
 &amp; = &amp; \unique(\dedupeL(\rev(x))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as claimed.
</p>
</div>
</div>
<p>blah…</p>
<div class="result">
<div class="thm">
<p>
<p>Let <span class="math inline">\(A\)</span> be a set.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\dedupeR(\nil) = \nil\)</span>.</li>
<li><span class="math inline">\(\dedupeR(\snoc(a,x)) = \snoc(a,\delete(a,\dedupeR(x)))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR(\nil) \\
 &amp; = &amp; \rev(\dedupeL(\rev(\nil))) \\
 &amp; = &amp; \rev(\dedupeL(\nil)) \\
 &amp; = &amp; \rev(\nil) \\
 &amp; = &amp; \nil
\end{eqnarray*}\]</span> as needed.</li>
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR(\snoc(a,x)) \\
 &amp; = &amp; \rev(\dedupeL(\rev(\snoc(a,x)))) \\
 &amp; = &amp; \rev(\dedupeL(\cons(a,\rev(x)))) \\
 &amp; = &amp; \rev(\cons(a,\delete(a,\dedupeL(\rev(x))))) \\
 &amp; = &amp; \snoc(a,\rev(\delete(a,\dedupeL(\rev(x))))) \\
 &amp; = &amp; \snoc(a,\delete(a,\rev(\dedupeL(\rev(x))))) \\
 &amp; = &amp; \snoc(a,\delete(a,\dedupeR(x)))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p><span class="math inline">\(\dedupeR\)</span> is idempotent.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x \in \lists{A}\)</span>. Then <span class="math inline">\(\dedupeR(\dedupeR(x)) = \dedupeR(x)\)</span>.
</p>
</div>
<div class="proof">
<p>
Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \dedupeR \circ \dedupeR \\
 &amp; = &amp; \rev \circ \dedupeL \circ \rev \circ \rev \circ \dedupeL \circ \rev \\
 &amp; = &amp; \rev \circ \dedupeL \circ \dedupeL \circ \rev \\
 &amp; = &amp; \rev \circ \dedupeL \circ \rev \\
 &amp; = &amp; \dedupeR
\end{eqnarray*}\]</span> as claimed.
</p>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>Here are our property tests for <span class="math inline">\(\dedupeL\)</span> and <span class="math inline">\(\dedupeR\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _<span class="ot">test_dedupeL_alt ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_alt _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;dedupeL(x) == dedupeL'(x)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (dedupeL x) <span class="fu">====</span> (dedupeL' x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeL_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_unique _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;unique(dedupeL(x)) == true&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (unique (dedupeL x)) <span class="fu">====</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeL_delete ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_delete _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;dedupeL(delete(a,x)) == delete(a,dedupeL(x))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \a x <span class="ot">-&gt;</span> (dedupeL (delete a x)) <span class="fu">====</span> (delete a (dedupeL x))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeL_idempotent ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_idempotent _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;dedupeL(dedupeL(x)) == dedupeL(x)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (dedupeL (dedupeL x)) <span class="fu">====</span> (dedupeL x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeL_eq_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_eq_unique _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;eq(x,dedupeL(x)) == unique(x)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (eq x (dedupeL x)) <span class="fu">====</span> (unique x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeL_prefix ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeL_prefix _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;prefix(x,y) ==&gt; prefix(dedupeL(x),dedupeL(y))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x y <span class="ot">-&gt;</span> <span class="kw">if</span> prefix x y
<span class="ot">&gt;</span>     <span class="kw">then</span> prefix (dedupeL x) (dedupeL y)
<span class="ot">&gt;</span>     <span class="kw">else</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeR_unique ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeR_unique _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;unique(dedupeR(x)) == true&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (unique (dedupeR x)) <span class="fu">====</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_dedupeR_idempotent ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (<span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_dedupeR_idempotent _ <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;dedupeR(dedupeR(x)) == dedupeR(x)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \x <span class="ot">-&gt;</span> (dedupeR (dedupeR x)) <span class="fu">====</span> (dedupeR x)</code></pre></div>
<p>And the suite:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- run all tests for dedupe</span>
<span class="ot">&gt;</span> _test_dedupe <span class="ot">::</span>
<span class="ot">&gt;</span>   ( <span class="dt">TypeName</span> a, <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a
<span class="ot">&gt;</span>   , <span class="dt">TypeName</span> (t a), <span class="dt">List</span> t
<span class="ot">&gt;</span>   ) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> _test_dedupe t maxSize numCases <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   testLabel (<span class="st">&quot;dedupeL &amp; dedupeR: &quot;</span> <span class="fu">++</span> typeName t)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     args <span class="fu">=</span> stdArgs
<span class="ot">&gt;</span>       { maxSuccess <span class="fu">=</span> numCases
<span class="ot">&gt;</span>       , maxSize    <span class="fu">=</span> maxSize
<span class="ot">&gt;</span>       }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_alt t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_unique t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_delete t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_idempotent t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_eq_unique t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeL_prefix t)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args (_test_dedupeR_unique t)
<span class="ot">&gt;</span>   runTest args (_test_dedupeR_idempotent t)</code></pre></div>
<p>And <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main_dedupe ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main_dedupe <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   _test_dedupe (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>)  <span class="dv">20</span> <span class="dv">100</span>
<span class="ot">&gt;</span>   _test_dedupe (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) <span class="dv">20</span> <span class="dv">100</span></code></pre></div>


<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
