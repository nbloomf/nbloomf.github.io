<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Zip</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Zip</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2017-05-06 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}{\mathsf{compose}}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\apply}{\mathsf{apply}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)
\(\newcommand{\flipB}{\mathsf{flip2}}\)
\(\newcommand{\flipC}{\mathsf{flip3}}\)
\(\newcommand{\flipD}{\mathsf{flip4}}\)
\(\newcommand{\flipE}{\mathsf{flip5}}\)
\(\newcommand{\clone}{\mathsf{clone}}\)
\(\newcommand{\cloneC}{\mathsf{clone3}}\)
\(\newcommand{\composeB}{\mathsf{compose2}}\)
\(\newcommand{\composeC}{\mathsf{compose3}}\)


<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}{\mathsf{natrec}}\)
\(\newcommand{\simprec}{\mathsf{simprec}}\)
\(\newcommand{\bailrec}{\mathsf{bailrec}}\)
\(\newcommand{\mutrec}{\mathsf{mutrec}}\)
\(\newcommand{\dnatrec}{\mathsf{dnatrec}}\)
\(\newcommand{\normrec}{\mathsf{normrec}}\)
\(\newcommand{\findsmallest}{\mathsf{findsmallest}}\)
\(\newcommand{\mnormrec}{\mathsf{mnormrec}}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}{\mathsf{foldr}}\)
\(\newcommand{\foldl}{\mathsf{foldl}}\)
\(\newcommand{\tacunfoldN}{\mathsf{tacunfoldN}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\dfoldr}{\mathsf{dfoldr}}\)
\(\newcommand{\cfoldr}{\mathsf{cfoldr}}\)
\(\newcommand{\bfoldr}{\mathsf{bfoldr}}\)
\(\newcommand{\dbfoldr}{\mathsf{dbfoldr}}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Zip.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Zip</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( zip, _test_zip, main_zip</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Tuples</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">NaturalNumbers</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">MaxAndMin</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Lists</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">DoubleFold</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Length</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Map</span></a></code></pre></div>
<p>Today we’ll define a really useful function on lists called <span class="math inline">\(\zip\)</span>. This map will take two lists, one in <span class="math inline">\(\lists{A}\)</span> and one in <span class="math inline">\(\lists{B}\)</span>, and return a list in <span class="math inline">\(\lists{A \times B}\)</span>. In progress, <span class="math inline">\(\zip\)</span>ping two lists looks something like this: <span class="math display">\[\begin{array}{ccccccccccc}
          &amp;   &amp;           &amp;   &amp;           &amp;           &amp; a_4 &amp; - &amp; a_5 &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp; \diagup   &amp;     &amp;   &amp;     &amp;   &amp;     \\
(a_1,b_1) &amp; - &amp; (a_2,b_2) &amp; - &amp; (a_3,b_3) &amp;           &amp;     &amp;   &amp;     &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp; \diagdown &amp;     &amp;   &amp;     &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp;           &amp; b_4 &amp; - &amp; b_5 &amp; - &amp; b_6
\end{array}\]</span> Hence the name <span class="math inline">\(\zip\)</span> – it looks like a zipper in action. A big question has to be resolved. It seems clear what <span class="math inline">\(\zip\)</span> should do if we give it two lists with the same length. But what if we try to zip two lists of different lengths? I can see two basic strategies. On one hand we can just truncate to the length of the shortest list. Another idea is to <em>pad</em> the shorter list to the length of the longer. These are both useful but essentially different behaviors, so we will define two different functions to handle them. The truncation strategy will be called <span class="math inline">\(\zip\)</span> and the padding strategy will be called <span class="math inline">\(\zipPad\)</span>.</p>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Define <span class="math inline">\(\delta : \lists{B} \rightarrow \lists{A \times B}\)</span> by <span class="math display">\[\delta(y) = \nil,\]</span> <span class="math inline">\(\psi : A \times \lists{A \times B} \rightarrow \lists{A \times B}\)</span> by <span class="math display">\[\psi(a,z) = \nil,\]</span> and <span class="math inline">\(\chi : A \times B \times \lists{B} \times \lists{A \times B} \times \lists{A \times B} \rightarrow \lists{A \times B}\)</span> by <span class="math display">\[\chi(a,b,y,z,w) = \cons((a,b),z).\]</span> Now define <span class="math display">\[\zip : \lists{A} \times \lists{B} \rightarrow \lists{A \times B}\]</span> by <span class="math display">\[\zip = \dfoldr(\delta)(\psi)(\chi).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">zip<span class="ot"> ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (<span class="dt">Pair</span> a b)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">zip <span class="fu">=</span> dfoldr delta psi chi</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    delta _ <span class="fu">=</span> nil</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    psi _ _ <span class="fu">=</span> nil</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    chi a b _ z _ <span class="fu">=</span> cons (tup a b) z</a></code></pre></div>
</div>
<p>Since <span class="math inline">\(\zip\)</span> is defined in terms of <span class="math inline">\(\dfoldr\)</span>, it is the unique solution to a system of functional equations.</p>
<div class="corollary">
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Then <span class="math inline">\(\zip\)</span> is the unique solution <span class="math inline">\(f : \lists{A} \times \lists{B} \rightarrow \lists{A \times B}\)</span> to the following equations for all <span class="math inline">\(a \in A\)</span>, <span class="math inline">\(b \in B\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span>. <span class="math display">\[\left\{\begin{array}{l}
 f(\nil,y) = \nil \\
 f(\cons(a,x),\nil) = \nil \\
 f(\cons(a,x),\cons(b,y)) = \cons((a,b),f(x,y))
\end{array}\right.\]</span></p>
<div class="test">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">_test_zip_nil_list ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a b)))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Test</span> (t b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">_test_zip_nil_list ta _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  testName <span class="st">&quot;zip(nil,y) == nil&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  \y <span class="ot">-&gt;</span> eq (zip (nil <span class="ot">`withTypeOf`</span> ta) y) nil</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">_test_zip_cons_nil ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a b)))</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">_test_zip_cons_nil _ tb <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  testName <span class="st">&quot;zip(cons(a,x),nil) == nil&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  \a x <span class="ot">-&gt;</span> eq (zip (cons a x) (nil <span class="ot">`withTypeOf`</span> tb)) nil</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">_test_zip_cons_cons ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a b)))</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">_test_zip_cons_cons _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  testName <span class="st">&quot;zip(cons(a,x),cons(b,y)) == cons((a,b),zip(x,y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  \a x b y <span class="ot">-&gt;</span> eq (zip (cons a x) (cons b y)) (cons (tup a b) (zip x y))</a></code></pre></div>
</div>
</div>
<p>Now <span class="math inline">\(\map(\tSwap) \circ \zip = \zip \circ \tSwap\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Then for all <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span> we have <span class="math display">\[\map(\tSwap)(\zip(x,y)) = \zip(y,x).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tSwap)(\zip(x,y)) \\
 &amp; = &amp; \map(\tSwap)(\zip(\nil,y)) \\
 &amp; = &amp; \map(\tSwap)(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \nil \\
 &amp; = &amp; \zip(y,\nil) \\
 &amp; = &amp; \zip(y,x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(y \in \lists{B}\)</span> for some <span class="math inline">\(x \in \lists{A}\)</span>, and let <span class="math inline">\(a \in A\)</span>. Now we consider two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tSwap)(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\tSwap)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\tSwap)(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \nil \\
 &amp; = &amp; \zip(\nil,\cons(a,x)) \\
 &amp; = &amp; \zip(y,\cons(a,x))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(y = \cons(b,z)\)</span>, using the induction hypotheses, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tSwap)(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\tSwap)(\zip(\cons(a,x),\cons(b,z))) \\
 &amp; = &amp; \map(\tSwap)(\cons((a,b),\zip(x,z))) \\
 &amp; = &amp; \cons(\tSwap(a,b),\map(\tSwap)(\zip(x,z))) \\
 &amp; = &amp; \cons((b,a),\zip(z,x)) \\
 &amp; = &amp; \zip(\cons(b,z),\cons(a,x)) \\
 &amp; = &amp; \zip(y,\cons(a,x))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">_test_zip_tswap ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> b a)))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">_test_zip_tswap _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  testName <span class="st">&quot;map(tswap)(zip(x,y)) == zip(y,x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> eq (map tswap (zip x y)) (zip y x)</a></code></pre></div>
</div>
</div>
<p>And <span class="math inline">\(\map(\tPair(f,g)) \circ \zip = \zip \circ \tPair(\map(f),\map(g))\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(U\)</span>, and <span class="math inline">\(V\)</span> be sets, with functions <span class="math inline">\(f : A \rightarrow U\)</span> and <span class="math inline">\(g : B \rightarrow V\)</span>. Then for all <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span>, we have <span class="math display">\[\map(\tPair(f,g))(\zip(x,y)) = \zip(\map(f)(x),\map(g)(y)).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tPair(f,g))(\zip(x,y)) \\
 &amp; = &amp; \map(\tPair(f,g))(\zip(\nil,y)) \\
 &amp; = &amp; \map(\tPair(f,g))(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \nil \\
 &amp; = &amp; \zip(\nil,\map(g)(y)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \zip(\map(f)(\nil),\map(g)(y)) \\
 &amp; = &amp; \zip(\map(f)(x),\map(g)(y))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the result holds for all <span class="math inline">\(y\)</span> for some <span class="math inline">\(x \in \lists{A}\)</span>, and let <span class="math inline">\(a \in A\)</span>. We now consider two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tPair(f,g))(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\tPair(f,g))(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\tPair(f,g))(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \nil \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
   = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(\nil)) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(y))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(y = \cons(b,z)\)</span>, using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\tPair(f,g))(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\tPair(f,g))(\zip(\cons(a,x),\cons(b,z))) \\
 &amp; = &amp; \map(\tPair(f,g))(\cons((a,b),\zip(x,z))) \\
 &amp; = &amp; \cons(\tPair(f,g)(a,b),\map(\tPair(f,g))(\zip(x,z))) \\
 &amp; = &amp; \cons(\tPair(f,g)(a,b),\zip(\map(f)(x),\map(g)(z))) \\
 &amp; = &amp; \cons((f(a),g(b)),\zip(\map(f)(x),\map(g)(z))) \\
 &amp; = &amp; \zip(\cons(f(a),\map(f)(x)),\cons(g(b),\map(g)(z))) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(\cons(b,z))) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(y))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">_test_zip_tpair ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a b)))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">_test_zip_tpair _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  testName <span class="st">&quot;map(tpair(f,g))(zip(x,y)) == zip(map(f)(x),map(g)(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  \f g x y <span class="ot">-&gt;</span> eq (map (tpair f g) (zip x y)) (zip (map f x) (map g y))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\zip\)</span> interacts with <span class="math inline">\(\length\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets, with <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span>. Then <span class="math display">\[\length(\zip(x,y)) = \nmin(\length(x),\length(y)).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,y)) \\
 &amp; = &amp; \length(\zip(x,\nil)) \\
 &amp; = &amp; \length(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Length.html#cor-length-nil}
   = &amp; \zero \\
 &amp; = &amp; \nmin(\length(x),\zero) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Length.html#cor-length-nil}
   = &amp; \nmin(\length(x),\length(\nil)) \\
 &amp; = &amp; \nmin(\length(x),\length(y))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span> and let <span class="math inline">\(b \in B\)</span>. We consider two cases: either <span class="math inline">\(x = \nil\)</span> or <span class="math inline">\(x = \cons(a,z)\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,\cons(b,y))) \\
 &amp; = &amp; \length(\zip(\nil,\cons(b,y))) \\
 &amp; = &amp; \length(\nil) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Length.html#cor-length-nil}
   = &amp; \zero \\
 &amp;     \href{/posts/arithmetic-made-difficult/MaxAndMin.html#thm-min-zero-left}
   = &amp; \nmin(\zero,\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(\length(\nil),\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(\length(x),\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed. Suppose <span class="math inline">\(x = \cons(b,z)\)</span>; now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,\cons(b,y))) \\
 &amp; = &amp; \length(\zip(\cons(a,z),\cons(b,y))) \\
 &amp; = &amp; \length(\cons((a,b),\zip(z,y))) \\
 &amp; = &amp; \next(\length(\zip(z,y))) \\
 &amp; = &amp; \next(\nmin(\length(z),\length(y))) \\
 &amp;     \href{/posts/arithmetic-made-difficult/MaxAndMin.html#thm-next-min-distribute}
   = &amp; \nmin(\next(\length(z)),\next(\length(y))) \\
 &amp; = &amp; \nmin(\length(\cons(a,z)),\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(x,\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">_test_zip_length ::</span> (<span class="dt">List</span> t, <span class="dt">Natural</span> n, <span class="dt">Equal</span> n)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">_test_zip_length _ _ n <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  testName <span class="st">&quot;length(zip(x,y)) == min(length(x),length(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> eq</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    ((length (zip x y)) <span class="ot">`withTypeOf`</span> n)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    (min (length x) (length y))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\zip\)</span> is kind of associative.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> be sets, with <span class="math inline">\(x \in \lists{A}\)</span>, <span class="math inline">\(y \in \lists{B}\)</span>, and <span class="math inline">\(z \in \lists{C}\)</span>. Then the following hold.</p>
<ol type="1">
<li><span class="math inline">\(\zip(\zip(x,y),z) = \map(\tAssocL)(\zip(x,\zip(y,z)))\)</span>.</li>
<li><span class="math inline">\(\zip(x,\zip(y,z)) = \map(\tAssocR)(\zip(\zip(x,y),z))\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(x,y),z) \\
 &amp; = &amp; \zip(\zip(\nil,y),z) \\
 &amp; = &amp; \zip(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
= &amp; \map(\tAssocL)(\nil) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\nil,\zip(y,z)))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span>, and let <span class="math inline">\(a \in A\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),\nil),z) \\
 &amp; = &amp; \zip(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
= &amp; \map(\tAssocL)(\nil) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\zip(\nil,z))) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\zip(y,z)))
\end{eqnarray*}\]</span> as claimed. Similarly, if <span class="math inline">\(z = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),y),\nil) \\
 &amp; = &amp; \nil \\
 &amp;     \href{/posts/arithmetic-made-difficult/Map.html#cor-map-nil}
= &amp; \map(\tAssocL)(\nil) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\zip(y,z)))
\end{eqnarray*}\]</span> as claimed. Suppose then that <span class="math inline">\(y = \cons(b,u)\)</span> and <span class="math inline">\(z = \cons(c,v)\)</span>. Using the inductive hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),\cons(b,u)),\cons(c,v)) \\
 &amp; = &amp; \zip(\cons((a,b),\zip(x,u)),\cons(c,v)) \\
 &amp; = &amp; \cons(((a,b),c),\zip(\zip(x,u),v)) \\
 &amp; = &amp; \cons(\tAssocL(a,(b,c)),\map(\tAssocL)(\zip(x,\zip(u,v)))) \\
 &amp; = &amp; \map(\tAssocL)(\cons((a,(b,c)),\zip(x,\zip(u,v)))) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\cons((b,c),\zip(u,v)))) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\zip(\cons(b,u),\cons(c,v)))) \\
 &amp; = &amp; \map(\tAssocL)(\zip(\cons(a,x),\zip(y,z)))
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(x,\zip(y,z)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-id}
= &amp; \id(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\id)(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\tAssocR \circ \tAssocL)(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\tAssocR)(\map(\tAssocL)(\zip(x,\zip(y,z)))) \\
 &amp; = &amp; \map(\tAssocR)(\zip(\zip(x,y),z)) 
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">_test_zip_zip_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> (<span class="dt">Pair</span> a a) a)))</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">_test_zip_zip_left _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  testName <span class="st">&quot;zip(zip(x,y),z) == map(tassocL)(zip(x,zip(y,z)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  \x y z <span class="ot">-&gt;</span> eq (zip (zip x y) z) (map tassocL (zip x (zip y z)))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">_test_zip_zip_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a (<span class="dt">Pair</span> a a))))</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">_test_zip_zip_right _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  testName <span class="st">&quot;zip(zip(x,y),z) == map(tassocR)(zip(x,zip(y,z)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  \x y z <span class="ot">-&gt;</span> eq (zip x (zip y z)) (map tassocR (zip (zip x y) z))</a></code></pre></div>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>Suite:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">_test_zip ::</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  ( <span class="dt">TypeName</span> a, <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  , <span class="dt">TypeName</span> b, <span class="dt">Equal</span> b, <span class="dt">Show</span> b, <span class="dt">Arbitrary</span> b, <span class="dt">CoArbitrary</span> b</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  , <span class="dt">TypeName</span> n, <span class="dt">Natural</span> n, <span class="dt">Equal</span> n, <span class="dt">Show</span> n, <span class="dt">Arbitrary</span> n</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  , <span class="dt">TypeName</span> (t a), <span class="dt">TypeName</span> (t b), <span class="dt">List</span> t, <span class="dt">Equal</span> (t a), <span class="dt">Show</span> (t a), <span class="dt">Arbitrary</span> (t a)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  , <span class="dt">Equal</span> (t b), <span class="dt">Show</span> (t b), <span class="dt">Arbitrary</span> (t b), <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a b)), <span class="dt">Equal</span> (t (<span class="dt">Pair</span> b a))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  , <span class="dt">Equal</span> (t (<span class="dt">Pair</span> a (<span class="dt">Pair</span> a a))), <span class="dt">Equal</span> (t (<span class="dt">Pair</span> (<span class="dt">Pair</span> a a) a))</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  ) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">_test_zip t u n size cases <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  testLabel3 <span class="st">&quot;zip&quot;</span> t u n</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  <span class="kw">let</span> args <span class="fu">=</span> testArgs size cases</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  runTest args (_test_zip_nil_list t u)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  runTest args (_test_zip_cons_nil t u)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">  runTest args (_test_zip_cons_cons t u)</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  runTest args (_test_zip_tswap t u)</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  runTest args (_test_zip_tpair t u)</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  runTest args (_test_zip_length t u n)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  runTest args (_test_zip_zip_left t)</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">  runTest args (_test_zip_zip_right t)</a></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">main_zip ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">main_zip <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  _test_zip (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>)  (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>)  (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">20</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  _test_zip (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">20</span> <span class="dv">100</span></a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
