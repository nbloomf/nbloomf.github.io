<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Zip</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../pages/contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Zip</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2017-05-06 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\swap}{\mathsf{swap}}\)
\(\newcommand{\pair}{\mathsf{pair}}\)
\(\newcommand{\assocL}{\mathsf{assocL}}\)
\(\newcommand{\assocR}{\mathsf{assocR}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\simprec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)
\(\newcommand{\bailrec}[4]{\left(\!\left[ #1, #2, #3, #4 \right]\!\right)}\)

<!--- natural number arithmetic ---->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- list -->
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\foldl}[2]{\mathsf{foldl}(#1,#2)}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p>This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Zip.lhs">the source</a> into GHCi and play along.</p>

<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Zip</span>
<span class="ot">&gt;</span>   ( zip, zipPad, _test_zip, main_zip, swap, pair, assocL, assocR
<span class="ot">&gt;</span>   ) <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Booleans</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">NaturalNumbers</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Plus</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">MaxAndMin</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Lists</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Reverse</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Cat</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Length</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">At</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Map</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">UnfoldN</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Range</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> (<span class="dt">Show</span>, <span class="dt">Int</span>, <span class="dt">IO</span>)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span></code></pre></div>
<p>Today we’ll define a really useful function on lists called <span class="math inline">\(\zip\)</span>. This map will take two lists, one in <span class="math inline">\(\lists{A}\)</span> and one in <span class="math inline">\(\lists{B}\)</span>, and return a list in <span class="math inline">\(\lists{A \times B}\)</span>. In progress, <span class="math inline">\(\zip\)</span>ping two lists looks something like this: <span class="math display">\[\begin{array}{ccccccccccc}
          &amp;   &amp;           &amp;   &amp;           &amp;           &amp; a_4 &amp; - &amp; a_5 &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp; \diagup   &amp;     &amp;   &amp;     &amp;   &amp;     \\
(a_1,b_1) &amp; - &amp; (a_2,b_2) &amp; - &amp; (a_3,b_3) &amp;           &amp;     &amp;   &amp;     &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp; \diagdown &amp;     &amp;   &amp;     &amp;   &amp;     \\
          &amp;   &amp;           &amp;   &amp;           &amp;           &amp; b_4 &amp; - &amp; b_5 &amp; - &amp; b_6
\end{array}\]</span> Hence the name <span class="math inline">\(\zip\)</span> – it looks like a zipper in action. Two big questions have to be resolved. First, it seems clear what <span class="math inline">\(\zip\)</span> should do if we give it two lists with the same length. But what if we try to zip two lists of different lengths? I can see two basic strategies. On one hand we can just truncate to the length of the shortest list. Another idea is to <em>pad</em> the shorter list to the length of the longer. These are both useful but essentially different behaviors, so we will define two different functions to handle them. The truncation strategy will be called <span class="math inline">\(\zip\)</span> and the padding strategy will be called <span class="math inline">\(\zipPad\)</span>.</p>
<p>The second problem to address is exactly how to implement such a function. The signature of <span class="math inline">\(\zip\)</span> is <span class="math display">\[\lists{A} \times \lists{B} \rightarrow \lists{A \times B}.\]</span> At the moment we have only two essentially different recursion operators on <span class="math inline">\(\lists{-}\)</span>. There’s <span class="math inline">\(\foldr{-}{-}\)</span>, with signature <span class="math display">\[\lists{A} \rightarrow B,\]</span> and <span class="math inline">\(\unfoldN(-,-,-)\)</span>, with signature <span class="math display">\[(A \rightarrow \ast + A \times B) \times \nats \times A \rightarrow \lists{B}.\]</span> Which to use? <span class="math inline">\(\unfoldN\)</span> has the right output type, and it is reasonably straightforward to define <span class="math inline">\(\zip\)</span> using <span class="math inline">\(\unfoldN\)</span> (try it!). But <span class="math inline">\(\unfoldN\)</span> has a drawback – we have to compute an upper bound on the length of the output in advance. In the case of <span class="math inline">\(\zip(x,y)\)</span>, that bound is <span class="math inline">\(\nmin(\length(x),\length(y))\)</span>. We prefer to avoid doing too much computation in the <span class="math inline">\(\nats\)</span> argument of <span class="math inline">\(\unfoldN\)</span>, so that strategy is out.</p>
<p>But <span class="math inline">\(\foldr{-}{-}\)</span> takes only one input list. The usual way to turn a function of one argument into a function of two arguments is with currying – that is, make the <em>return</em> type a function. So we should look for appropriate <span class="math inline">\(\varepsilon\)</span> and <span class="math inline">\(\varphi\)</span> so that <span class="math display">\[\foldr{\varepsilon}{\varphi} : \lists{A} \rightarrow \lists{A \times B}^{\lists{B}}\]</span> uncurries to <span class="math display">\[\zip : \lists{A} \times \lists{B} \rightarrow \lists{A \times B}\]</span> as we want. Now we should have <span class="math display">\[\varepsilon : \lists{A \times B}^{\lists{B}},\]</span> and intuitively, <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nil \\
 &amp; = &amp; \zip(\nil,y) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\nil)(y) \\
 &amp; = &amp; \varepsilon(y).
\end{eqnarray*}\]</span></p>
<p>Similarly, we want <span class="math display">\[\varphi : \lists{A} \times \lists{A \times B}^{\lists{B}} \rightarrow \lists{A \times B}^{\lists{B}},\]</span> with <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nil \\
 &amp; = &amp; \zip(\cons(a,x),\nil) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\cons(a,x))(\nil) \\
 &amp; = &amp; \varphi(a,\foldr{\varepsilon}{\varphi}(x))(\nil) \\
 &amp; = &amp; \varphi(a,\zip(x,-))(\nil)
\end{eqnarray*}\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \cons((a,b),\zip(x,y)) \\
 &amp; = &amp; \zip(\cons(a,x),\cons(b,y)) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\cons(a,x))(\cons(b,y)) \\
 &amp; = &amp; \varphi(a,\foldr{\varepsilon}{\varphi}(x))(\cons(b,y)) \\
 &amp; = &amp; \varphi(a,\zip(x,-))(\cons(b,y)).
\end{eqnarray*}\]</span></p>
<p>Once again, the recursion operators allow us to be sloppy at first. :) With these constraints in hand, we define <span class="math inline">\(\zip\)</span> like so.</p>
<div class="result">
<div class="defn">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Define <span class="math inline">\(\varepsilon : \lists{A \times B}^{\lists{B}}\)</span> by <span class="math display">\[\varepsilon(y) = \nil\]</span> and define <span class="math inline">\(\varphi : \lists{A} \times \lists{A \times B}^{\lists{B}} \rightarrow \lists{A\times B}^{\lists{B}}\)</span> by <span class="math display">\[\varphi(x,f)(z) = \left\{\begin{array}{ll} \nil &amp; \mathrm{if}\ z = \nil \\ \cons((x,y),f(w)) &amp; \mathrm{if}\ z = \cons(y,w). \end{array}\right.\]</span> We then define <span class="math inline">\(\zip : \lists{A} \times \lists{B} \rightarrow \lists{A \times B}\)</span> by <span class="math display">\[\zip(x,y) = \foldr{\varepsilon}{\varphi}(x)(y).\]</span>
</p>
</div>
</div>
<p>We can implement <span class="math inline">\(\zip\)</span> directly with <span class="math inline">\(\foldr{-}{-}\)</span> as in the definition.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zip' ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="ot">&gt;</span> zip' <span class="fu">=</span> foldr epsilon phi
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     phi ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (t b <span class="ot">-&gt;</span> t (a,b)) <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="ot">&gt;</span>     phi x f z <span class="fu">=</span> <span class="kw">case</span> listShape z <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nil</span>       <span class="ot">-&gt;</span> nil
<span class="ot">&gt;</span>       <span class="dt">Cons</span> y ys <span class="ot">-&gt;</span> cons (x,y) (f ys)
<span class="ot">&gt;</span> 
<span class="ot">&gt;     epsilon ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="ot">&gt;</span>     epsilon _ <span class="fu">=</span> nil</code></pre></div>
<p>This does the job. But it’s also a little awkward; it constructs an intermediate list of functions. The following result suggests a more straightforward implementation.</p>
<div class="result">
<div class="thm">
<p>
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Then we have the following for all <span class="math inline">\(a \in A\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, <span class="math inline">\(b \in B\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\zip(\nil,y) = \nil\)</span>.</li>
<li><span class="math inline">\(\zip(x,\nil) = \nil\)</span>.</li>
<li><span class="math inline">\(\zip(\cons(a,x),\cons(b,y)) = \cons((a,b),\zip(x,y))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\nil,y) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\nil)(y) \\
 &amp; = &amp; \varepsilon(y) \\
 &amp; = &amp; \nil
\end{eqnarray*}\]</span> as claimed.</li>
<li>We consider two cases: either <span class="math inline">\(x = \nil\)</span> or <span class="math inline">\(x = \cons(d,w)\)</span> for some <span class="math inline">\(d \in A\)</span> and <span class="math inline">\(w \in \lists{A}\)</span>. Certainly if <span class="math inline">\(x = \nil\)</span> we have <span class="math display">\[\zip(x,\nil) = \zip(\nil,\nil) = \nil\]</span> as claimed. Suppose then that <span class="math inline">\(x = \cons(d,w)\)</span>; now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\cons(d,w),\nil) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\cons(d,w))(\nil) \\
 &amp; = &amp; \varphi(d,\foldr{\varepsilon}{\varphi}(x))(\nil) \\
 &amp; = &amp; \nil
\end{eqnarray*}\]</span> as claimed.</li>
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\cons(a,x),\cons(b,y)) \\
 &amp; = &amp; \foldr{\varepsilon}{\varphi}(\cons(a,x))(\cons(b,y)) \\
 &amp; = &amp; \varphi(a,\foldr{\varepsilon}{\varphi}(x))(\cons(b,y)) \\
 &amp; = &amp; \cons((a,b),\foldr{\varepsilon}{\varphi}(x)(y)) \\
 &amp; = &amp; \cons((a,b),\zip(x,y))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zip ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="ot">&gt;</span> zip x y <span class="fu">=</span> <span class="kw">case</span> listShape x <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Nil</span>       <span class="ot">-&gt;</span> nil
<span class="ot">&gt;</span>   <span class="dt">Cons</span> a as <span class="ot">-&gt;</span> <span class="kw">case</span> listShape y <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Nil</span>       <span class="ot">-&gt;</span> nil
<span class="ot">&gt;</span>     <span class="dt">Cons</span> b bs <span class="ot">-&gt;</span> cons (a,b) (zip as bs)</code></pre></div>
<p><span class="math inline">\(\zip\)</span> will turn out to be pretty useful. Before establishing some properties for it, we need a few utility functions on pairs.</p>
<div class="result">
<div class="defn">
<p>
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(U\)</span>, and <span class="math inline">\(V\)</span> be sets.</p>
<p>Define <span class="math inline">\(\swap : A \times B \rightarrow B \times A\)</span> by <span class="math display">\[\swap(a,b) = (b,a).\]</span></p>
<p>Define <span class="math inline">\(\pair : U^A \times V^B \rightarrow (U \times V)^{A \times B}\)</span> by <span class="math display">\[\pair(f,g)(a,b) = (f(a),g(b)).\]</span></p>
<p>Define <span class="math inline">\(\assocL : A \times (B \times C) \rightarrow (A \times B) \times C\)</span> by <span class="math display">\[\assocL(a,(b,c)) = ((a,b),c).\]</span></p>
<p>Define <span class="math inline">\(\assocR : (A \times B) \times C \rightarrow A \times (B \times C)\)</span> by <span class="math display">\[\assocR((a,b),c) = (a,(b,c)).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)
<span class="ot">&gt;</span> swap (a,b) <span class="fu">=</span> (b,a)
<span class="ot">&gt;</span> 
<span class="ot">&gt; pair ::</span> (a <span class="ot">-&gt;</span> u) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> (u,v)
<span class="ot">&gt;</span> pair f g (a,b) <span class="fu">=</span> (f a, g b)
<span class="ot">&gt;</span> 
<span class="ot">&gt; assocL ::</span> (a,(b,c)) <span class="ot">-&gt;</span> ((a,b),c)
<span class="ot">&gt;</span> assocL (a,(b,c)) <span class="fu">=</span> ((a,b),c)
<span class="ot">&gt;</span> 
<span class="ot">&gt; assocR ::</span> ((a,b),c) <span class="ot">-&gt;</span> (a,(b,c))
<span class="ot">&gt;</span> assocR ((a,b),c) <span class="fu">=</span> (a,(b,c))</code></pre></div>
</p>
</div>
</div>
<p>Now <span class="math inline">\(\map(\swap) \circ \zip = \zip \circ \swap\)</span>:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Then for all <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span> we have <span class="math display">\[\map(\swap)(\zip(x,y)) = \zip(y,x).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zip(x,y)) \\
 &amp; = &amp; \map(\swap)(\zip(\nil,y)) \\
 &amp; = &amp; \map(\swap)(\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \zip(y,\nil) \\
 &amp; = &amp; \zip(y,x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(y \in \lists{B}\)</span> for some <span class="math inline">\(x \in \lists{A}\)</span>, and let <span class="math inline">\(a \in A\)</span>. Now we consider two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\swap)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\swap)(\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \zip(\nil,\cons(a,x)) \\
 &amp; = &amp; \zip(y,\cons(a,x))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(y = \cons(b,z)\)</span>, using the induction hypotheses, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\swap)(\zip(\cons(a,x),\cons(b,z))) \\
 &amp; = &amp; \map(\swap)(\cons((a,b),\zip(x,z))) \\
 &amp; = &amp; \cons(\swap(a,b),\map(\swap)(\zip(x,z))) \\
 &amp; = &amp; \cons((b,a),\zip(z,x)) \\
 &amp; = &amp; \zip(\cons(b,z),\cons(a,x)) \\
 &amp; = &amp; \zip(y,\cons(a,x))
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>And <span class="math inline">\(\map(\pair(f,g)) \circ \zip = \zip \circ \pair(\map(f),\map(g))\)</span>:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(U\)</span>, and <span class="math inline">\(V\)</span> be sets, with functions <span class="math inline">\(f : A \rightarrow U\)</span> and <span class="math inline">\(g : B \rightarrow V\)</span>. Then for all <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span>, we have <span class="math display">\[\map(\pair(f,g))(\zip(x,y)) = \zip(\map(f)(x),\map(g)(y)).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zip(x,y)) \\
 &amp; = &amp; \map(\pair(f,g))(\zip(\nil,y)) \\
 &amp; = &amp; \map(\pair(f,g))(\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \zip(\nil,\map(g)(y)) \\
 &amp; = &amp; \zip(\map(f)(\nil),\map(g)(y)) \\
 &amp; = &amp; \zip(\map(f)(x),\map(g)(y))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the result holds for all <span class="math inline">\(y\)</span> for some <span class="math inline">\(x \in \lists{A}\)</span>, and let <span class="math inline">\(a \in A\)</span>. We now consider two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\pair(f,g))(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\pair(f,g))(\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\nil) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(\nil)) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(y))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(y = \cons(b,z)\)</span>, using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zip(\cons(a,x),y)) \\
 &amp; = &amp; \map(\pair(f,g))(\zip(\cons(a,x),\cons(b,z))) \\
 &amp; = &amp; \map(\pair(f,g))(\cons((a,b),\zip(x,z))) \\
 &amp; = &amp; \cons(\pair(f,g)(a,b),\map(\pair(f,g))(\zip(x,z))) \\
 &amp; = &amp; \cons(\pair(f,g)(a,b),\zip(\map(f)(x),\map(g)(z))) \\
 &amp; = &amp; \cons((f(a),g(b)),\zip(\map(f)(x),\map(g)(z))) \\
 &amp; = &amp; \zip(\cons(f(a),\map(f)(x)),\cons(g(b),\map(g)(z))) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(\cons(b,z))) \\
 &amp; = &amp; \zip(\map(f)(\cons(a,x)),\map(g)(y))
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>The length of a zipped list:</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets, with <span class="math inline">\(x \in \lists{A}\)</span> and <span class="math inline">\(y \in \lists{B}\)</span>. Then <span class="math display">\[\length(\zip(x,y)) = \nmin(\length(x),\length(y)).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,y)) \\
 &amp; = &amp; \length(\zip(x,\nil)) \\
 &amp; = &amp; \length(\nil) \\
 &amp; = &amp; \zero \\
 &amp; = &amp; \nmin(\length(x),\zero) \\
 &amp; = &amp; \nmin(\length(x),\length(\nil)) \\
 &amp; = &amp; \nmin(\length(x),\length(y)) \\
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span> and let <span class="math inline">\(b \in B\)</span>. We consider two cases: either <span class="math inline">\(x = \nil\)</span> or <span class="math inline">\(x = \cons(a,z)\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,\cons(b,y))) \\
 &amp; = &amp; \length(\zip(\nil,\cons(b,y))) \\
 &amp; = &amp; \length(\nil) \\
 &amp; = &amp; \zero \\
 &amp; = &amp; \nmin(\zero,\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(\length(\nil),\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(\length(x),\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed. Suppose <span class="math inline">\(x = \cons(b,z)\)</span>; now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zip(x,\cons(b,y))) \\
 &amp; = &amp; \length(\zip(\cons(a,z),\cons(b,y))) \\
 &amp; = &amp; \length(\cons((a,b),\zip(z,y))) \\
 &amp; = &amp; \next(\length(\zip(z,y))) \\
 &amp; = &amp; \next(\min(\length(z),\length(y))) \\
 &amp; = &amp; \nmin(\next(\length(z)),\next(\length(y))) \\
 &amp; = &amp; \nmin(\length(\cons(a,z)),\length(\cons(b,y))) \\
 &amp; = &amp; \nmin(x),\length(\cons(b,y))) \\
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p><span class="math inline">\(\zip\)</span> is kind of associative:</p>
<div class="result">
<div class="thm">
<p>
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> be sets, with <span class="math inline">\(x \in \lists{A}\)</span>, <span class="math inline">\(y \in \lists{B}\)</span>, and <span class="math inline">\(z \in \lists{C}\)</span>. Then the following hold.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\zip(\zip(x,y),z) = \map(\assocL)(\zip(x,\zip(y,z)))\)</span>.</li>
<li><span class="math inline">\(\zip(x,\zip(y,z)) = \map(\assocR)(\zip(\zip(x,y),z))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(x,y),z) \\
 &amp; = &amp; \zip(\zip(\nil,y),z) \\
 &amp; = &amp; \zip(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zip(\nil,\zip(y,z)))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span>, and let <span class="math inline">\(a \in A\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),\nil),z) \\
 &amp; = &amp; \zip(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\zip(\nil,z))) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\zip(y,z)))
\end{eqnarray*}\]</span> as claimed. Similarly, if <span class="math inline">\(z = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),y),\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\zip(y,z)))
\end{eqnarray*}\]</span> as claimed. Suppose then that <span class="math inline">\(y = \cons(b,u)\)</span> and <span class="math inline">\(z = \cons(c,v)\)</span>. Using the inductive hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(\zip(\cons(a,x),y),z) \\
 &amp; = &amp; \zip(\zip(\cons(a,x),\cons(b,u)),\cons(c,v)) \\
 &amp; = &amp; \zip(\cons((a,b),\zip(x,u)),\cons(c,v)) \\
 &amp; = &amp; \cons(((a,b),c),\zip(\zip(x,u),v)) \\
 &amp; = &amp; \cons(\assocL(a,(b,c)),\map(\assocL)(\zip(x,\zip(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\cons((a,(b,c)),\zip(x,\zip(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\cons((b,c),\zip(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\zip(\cons(b,u),\cons(c,v)))) \\
 &amp; = &amp; \map(\assocL)(\zip(\cons(a,x),\zip(y,z))) \\
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zip(x,\zip(y,z)) \\
 &amp; = &amp; \id(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\id)(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\assocR \circ \assocL)(\zip(x,\zip(y,z))) \\
 &amp; = &amp; \map(\assocR)(\map(\assocL)(\zip(x,\zip(y,z)))) \\
 &amp; = &amp; \map(\assocR)(\zip(\zip(x,y),z)) 
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>How about <span class="math inline">\(\zipPad\)</span>? We want a signature like <span class="math display">\[A \times B \rightarrow \lists{A} \times \lists{B} \rightarrow \lists{A \times B},\]</span> from a function <span class="math display">\[\foldr{\delta}{\psi} : \lists{A} \rightarrow \lists{A \times B}^{\lists{B}}.\]</span> Let <span class="math inline">\(\alpha \in A\)</span> and <span class="math inline">\(\beta \in B\)</span> be the “pad” elements. Now <span class="math inline">\(\delta : \lists{A \times B}^{\lists{B}}\)</span> should satisfy <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map((\alpha,-))(y) \\
 &amp; = &amp; \zipPad(\alpha,\beta)(\nil,y) \\
 &amp; = &amp; \foldr{\delta}{\psi}(\nil)(y) \\
 &amp; = &amp; \delta(y),
\end{eqnarray*}\]</span> and <span class="math inline">\(\psi : \lists{A} \times \lists{A \times B}^{\lists{B}} \rightarrow \lists{A \times B}^{\lists{B}}\)</span> should satisfy <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \cons((a,\beta),\foldr{\delta}{\psi}(x)(\nil)) \\
 &amp; = &amp; \cons((a,\beta),\zipPad(\alpha,\beta)(x,\nil)) \\
 &amp; = &amp; \zipPad(\alpha,\beta)(\cons(a,x),\nil) \\
 &amp; = &amp; \foldr{\delta}{\psi}(\cons(a,x))(\nil) \\
 &amp; = &amp; \psi(a,\foldr{\delta}{\psi}(x))(\nil)
\end{eqnarray*}\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \cons((a,b),\zipPad(x,y)) \\
 &amp; = &amp; \zipPad(\alpha,\beta)(\cons(a,x),\cons(b,y)) \\
 &amp; = &amp; \foldr{\delta}{\psi}(\cons(a,x))(\cons(b,y)) \\
 &amp; = &amp; \psi(a,\foldr{\delta}{\psi}(x))(\cons(b,y)).
\end{eqnarray*}\]</span> With this in mind, we define <span class="math inline">\(\zipPad\)</span> like so.</p>
<div class="result">
<div class="defn">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Define <span class="math inline">\(\delta : A \rightarrow \lists{A \times B}^{\lists{B}}\)</span> by <span class="math display">\[\delta(u)(y) = \map((u,-))(y)\]</span> and define <span class="math inline">\(\psi : B \rightarrow \lists{A} \times \lists{A \times B}^{\lists{B}} \rightarrow \lists{A\times B}^{\lists{B}}\)</span> by <span class="math display">\[\psi(v)(x,f)(z) = \left\{\begin{array}{ll} \cons((x,v),f(z)) &amp; \mathrm{if}\ z = \nil \\ \cons((x,y),f(w)) &amp; \mathrm{if}\ z = \cons(y,w). \end{array}\right.\]</span> We then define <span class="math inline">\(\zipPad : A \times B \rightarrow \lists{A} \times \lists{B} \rightarrow \lists{A \times B}\)</span> by <span class="math display">\[\zipPad(u,v)(x,y) = \foldr{\delta(u)}{\psi(v)}(x)(y).\]</span>
</p>
</div>
</div>
<p>The implementation from the definition does the job:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span><span class="ot"> zipPad' ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="fu">&gt;</span> zipPad' u v <span class="fu">=</span> foldr (delta u) (psi v)
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span><span class="ot">     psi ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (t b <span class="ot">-&gt;</span> t (a,b)) <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="fu">&gt;</span>     psi v x f z <span class="fu">=</span> <span class="kw">case</span> listShape z <span class="kw">of</span>
<span class="fu">&gt;</span>       <span class="dt">Nil</span>       <span class="ot">-&gt;</span> cons (x,v) (f nil)
<span class="fu">&gt;</span>       <span class="dt">Cons</span> y ys <span class="ot">-&gt;</span> cons (x,y) (f ys)
<span class="fu">&gt;</span>
<span class="fu">&gt;</span><span class="ot">     delta ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="fu">&gt;</span>     delta u z <span class="fu">=</span> map (\t <span class="ot">-&gt;</span> (u,t)) z</code></pre></div>
<p>But again, a more straightforward implementation is possible.</p>
<div class="result">
<div class="defn">
<p>
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. The following hold for all <span class="math inline">\(\alpha, a \in A\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, <span class="math inline">\(\beta, b \in B\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\zipPad(\alpha,\beta)(\nil,y) = \map((\alpha,-))(y)\)</span>.</li>
<li><span class="math inline">\(\zipPad(\alpha,\beta)(x,\nil) = \map((-,\beta))(x)\)</span>.</li>
<li><span class="math inline">\(\zipPad(\alpha,\beta)(\cons(a,x),\cons(b,y)) = \cons((a,b),\zipPad(\alpha,\beta)(x,y))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,\beta)(\nil,y) \\
 &amp; = &amp; \foldr{\delta(\alpha)}{\psi(\beta)}(\nil)(y) \\
 &amp; = &amp; \delta(\alpha)(y) \\
 &amp; = &amp; \map((\alpha,-))(y)
\end{eqnarray*}\]</span> as claimed.</li>
<li>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,\beta)(\nil,\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map((-,\beta))(\nil) \\
 &amp; = &amp; \map((-,\beta))(x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,\beta)(\cons(a,x),\nil) \\
 &amp; = &amp; \foldr{\delta(\alpha)}{\psi(\beta)}(\cons(a,x))(\nil) \\
 &amp; = &amp; \psi(\beta)(a,\foldr{\delta(\alpha)}{\psi(\beta)}(x))(\nil) \\
 &amp; = &amp; \cons((a,\beta),\foldr{\delta(\alpha)}{\psi(\beta)}(x)(\nil)) \\
 &amp; = &amp; \cons((a,\beta),\zipPad(\alpha,\beta)(x,\nil)) \\
 &amp; = &amp; \cons((a,\beta),\map((-,\beta))(x)) \\
 &amp; = &amp; \map((-,\beta))(\cons(a,x))
\end{eqnarray*}\]</span> as needed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,\beta)(\cons(a,x),\cons(b,y)) \\
 &amp; = &amp; \foldr{\delta(\alpha)}{\psi(\beta)}(\cons(a,x))(\cons(b,y)) \\
 &amp; = &amp; \psi(\beta)(a,\foldr{\delta(\alpha)}{\psi(\beta)}(x))(\cons(b,y)) \\
 &amp; = &amp; \cons((a,b),\foldr{\delta(\alpha)}{\psi(\beta)}(x)(y)) \\
 &amp; = &amp; \cons((a,b),\zipPad(\alpha,\beta)(x,y))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zipPad ::</span> (<span class="dt">List</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> t (a,b)
<span class="ot">&gt;</span> zipPad u v x y <span class="fu">=</span> <span class="kw">case</span> listShape x <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Nil</span>       <span class="ot">-&gt;</span> map (\w <span class="ot">-&gt;</span> (u,w)) y
<span class="ot">&gt;</span>   <span class="dt">Cons</span> a as <span class="ot">-&gt;</span> <span class="kw">case</span> listShape y <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Nil</span>       <span class="ot">-&gt;</span> map (\w <span class="ot">-&gt;</span> (w,v)) x
<span class="ot">&gt;</span>     <span class="dt">Cons</span> b bs <span class="ot">-&gt;</span> cons (a,b) (zipPad u v as bs)</code></pre></div>
<p>Now <span class="math inline">\(\zipPad\)</span> satisfies several properties analogous to those of <span class="math inline">\(\zip\)</span>.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets. Then for all <span class="math inline">\(\alpha \in A\)</span>, <span class="math inline">\(\beta \in B\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span> we have <span class="math display">\[\map(\swap)(\zipPad(\alpha,\beta)(x,y)) = \zipPad(\beta,\alpha)(y,x).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zipPad(\alpha,\beta)(x,y)) \\
 &amp; = &amp; \map(\swap)(\zipPad(\alpha,\beta)(\nil,y)) \\
 &amp; = &amp; \map(\swap)(\map((\alpha,-))(y)) \\
 &amp; = &amp; (\map(\swap) \circ \map((\alpha,-)))(y) \\
 &amp; = &amp; \map(\swap \circ (\alpha,-))(y) \\
 &amp; = &amp; \map((-,\alpha))(y) \\
 &amp; = &amp; \zipPad(\beta,\alpha)(y,\nil) \\
 &amp; = &amp; \zipPad(\beta,\alpha)(y,x)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Now we consider two cases for <span class="math inline">\(y\)</span>; either <span class="math inline">\(y = \nil\)</span> or <span class="math inline">\(y = \cons(b,w)\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zipPad(\alpha,\beta)(\cons(a,x),y)) \\
 &amp; = &amp; \map(\swap)(\zipPad(\alpha,\beta)(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\swap)(\map((-,\beta))(\cons(a,x))) \\
 &amp; = &amp; (\map(\swap) \circ \map((-,\beta)))(\cons(a,x)) \\
 &amp; = &amp; \map(\swap \circ (-,\beta))(\cons(a,x)) \\
 &amp; = &amp; \map((\beta,-))(\cons(a,x)) \\
 &amp; = &amp; \zipPad(\alpha,\beta)(\nil,\cons(a,x)) \\
 &amp; = &amp; \zipPad(\alpha,\beta)(y,\cons(a,x))
\end{eqnarray*}\]</span> as needed. Finally, suppose <span class="math inline">\(y = \cons(b,w)\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\swap)(\zipPad(\alpha,\beta)(\cons(a,x),y)) \\
 &amp; = &amp; \map(\swap)(\zipPad(\alpha,\beta)(\cons(a,x),\cons(b,w))) \\
 &amp; = &amp; \map(\swap)(\cons((a,b),\zipPad(\alpha,\beta)(x,w)) \\
 &amp; = &amp; \cons(\swap((a,b)),\map(\swap)(\zipPad(\alpha,\beta)(x,w))) \\
 &amp; = &amp; \cons((b,a),\zipPad(\beta,\alpha)(w,x)) \\
 &amp; = &amp; \zipPad(\beta,\alpha)(\cons(b,w),\cons(a,x)) \\
 &amp; = &amp; \zipPad(\beta,\alpha)(y,\cons(a,x)) \\
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>and…</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(U\)</span>, and <span class="math inline">\(V\)</span> be sets, with functions <span class="math inline">\(f : A \rightarrow U\)</span> and <span class="math inline">\(g : B \rightarrow V\)</span>. Then for all <span class="math inline">\(\alpha \in A\)</span>, <span class="math inline">\(\beta \in B\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span>, we have <span class="math display">\[\map(\pair(f,g))(\zipPad(\alpha,\beta)(x,y)) = \zipPad(f(\alpha),g(\beta))(\map(f)(x),\map(g)(y)).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zipPad(\alpha,\beta)(x,y)) \\
 &amp; = &amp; \map(\pair(f,g))(\zipPad(\alpha,\beta)(\nil,y)) \\
 &amp; = &amp; \map(\pair(f,g))(\map((\alpha,-))(y)) \\
 &amp; = &amp; (\map(\pair(f,g)) \circ \map((\alpha,-)))(y) \\
 &amp; = &amp; \map(\pair(f,g) \circ (\alpha,-))(y) \\
 &amp; = &amp; \map((f(\alpha),g(-)))(y) \\
 &amp; = &amp; \map((f(\alpha),-) \circ g)(y) \\
 &amp; = &amp; \map((f(\alpha),-))(\map(g)(y)) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\nil,\map(g)(y)) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(x,\map(g)(y))
\end{eqnarray*}\]</span> as needed. Now suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. We consider two cases for <span class="math inline">\(y\)</span>; either <span class="math inline">\(y = \nil\)</span> or <span class="math inline">\(y = \cons(b,w)\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zipPad(\alpha,\beta)(\cons(a,x),y)) \\
 &amp; = &amp; \map(\pair(f,g))(\zipPad(\alpha,\beta)(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\pair(f,g))(\map((-,\beta))(\cons(a,x))) \\
 &amp; = &amp; (\map(\pair(f,g)) \circ \map((-,\beta)))(\cons(a,x)) \\
 &amp; = &amp; \map(\pair(f,g) \circ (-,\beta))(\cons(a,x)) \\
 &amp; = &amp; \map((f(-),g(\beta)))(\cons(a,x)) \\
 &amp; = &amp; \map((-,g(\beta)) \circ f)(\cons(a,x)) \\
 &amp; = &amp; \map((-,g(\beta)))(\map(f)(\cons(a,x))) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\map(f)(\cons(a,x)),\nil) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\map(f)(\cons(a,x)),y) \\
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(y = \cons(b,w)\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \map(\pair(f,g))(\zipPad(\alpha,\beta)(\cons(a,x),\cons(b,w))) \\
 &amp; = &amp; \map(\pair(f,g))(\cons((a,b),\zipPad(\alpha,\beta)(x,w))) \\
 &amp; = &amp; \cons(\pair(f,g)(a,b),\map(\pair(f,g))(\zipPad(\alpha,\beta)(x,w))) \\
 &amp; = &amp; \cons((f(a),g(b)),\zipPad(f(\alpha),g(\beta))(\map(f)(x),\map(g)(w))) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\cons(f(a),\map(f)(x)),\cons(g(b),\map(g)(w))) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\map(f)(\cons(a,x)),\map(g)(\cons(b,w))) \\
 &amp; = &amp; \zipPad(f(\alpha),g(\beta))(\map(f)(\cons(a,x)),\map(g)(y)) \\
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>and…</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets, with <span class="math inline">\(\alpha \in A\)</span>, <span class="math inline">\(\beta \in B\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, and <span class="math inline">\(y \in \lists{B}\)</span>. Then <span class="math display">\[\length(\zipPad(\alpha,\beta)(x,y)) = \nmax(\length(x),\length(y)).\]</span>
</p>
</div>
<div class="proof">
<p>
We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zipPad(\alpha,\beta)(x,y)) \\
 &amp; = &amp; \length(\zipPad(\alpha,\beta)(\nil,y)) \\
 &amp; = &amp; \length(\map((\alpha,-))(y)) \\
 &amp; = &amp; \length(y) \\
 &amp; = &amp; \nmax(\zero,\length(y)) \\
 &amp; = &amp; \nmax(\length(\nil),\length(y)) \\
 &amp; = &amp; \nmax(\length(x),\length(y)) \\
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. We consider two possibilities for <span class="math inline">\(y\)</span>: either <span class="math inline">\(y = \nil\)</span> or <span class="math inline">\(y = \cons(b,w)\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zipPad(\alpha,\beta)(\cons(a,x),y)) \\
 &amp; = &amp; \length(\zipPad(\alpha,\beta)(\cons(a,x),\nil)) \\
 &amp; = &amp; \length(\map((-,\beta))(\cons(a,x))) \\
 &amp; = &amp; \length(\cons(a,x)) \\
 &amp; = &amp; \nmax(\length(\cons(a,x)),\zero) \\
 &amp; = &amp; \nmax(\length(\cons(a,x)),\length(\nil)) \\
 &amp; = &amp; \nmax(\length(\cons(a,x)),\length(y)) \\
\end{eqnarray*}\]</span> as claimed. Suppose then that <span class="math inline">\(y = \cons(b,w)\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \length(\zipPad(\alpha,\beta)(\cons(a,x),y)) \\
 &amp; = &amp; \length(\zipPad(\alpha,\beta)(\cons(a,x),\cons(b,w))) \\
 &amp; = &amp; \length(\cons((a,b),\zipPad(\alpha,\beta)(x,w))) \\
 &amp; = &amp; \next(\length(\zipPad(\alpha,\beta)(x,w))) \\
 &amp; = &amp; \next(\nmax(\length(x),\length(w))) \\
 &amp; = &amp; \nmax(\next(\length(x)),\next(\length(w))) \\
 &amp; = &amp; \nmax(\length(\cons(a,x)),\length(\cons(b,w))) \\
 &amp; = &amp; \nmax(\length(\cons(a,x)),\length(y)) \\
\end{eqnarray*}\]</span> as claimed.
</p>
</div>
</div>
<p><span class="math inline">\(\zipPad\)</span> is also kind of associative:</p>
<div class="result">
<div class="thm">
<p>
<p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> be sets, with <span class="math inline">\(\alpha \in A\)</span>, <span class="math inline">\(\beta \in B\)</span>, <span class="math inline">\(\gamma \in C\)</span>, <span class="math inline">\(x \in \lists{A}\)</span>, <span class="math inline">\(y \in \lists{B}\)</span>, and <span class="math inline">\(z \in \lists{C}\)</span>. Then the following hold.</p>
<ol style="list-style-type: decimal">
<li><span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(x,y),z) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z))).
\end{eqnarray*}\]</span></li>
<li><span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z)) \\
 &amp; = &amp; \map(\assocR)(\zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(x,y),z)).
\end{eqnarray*}\]</span></li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(x,y),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\nil,y),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\nil,\zipPad(\beta,\gamma)(y,z))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z)))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),y),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),\nil),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\nil,z) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zipPad(\beta,\gamma)(\nil,z))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zipPad(\beta,\gamma)(y,z)))
\end{eqnarray*}\]</span> as claimed. Similarly, if <span class="math inline">\(z = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),y),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),y),\nil) \\
 &amp; = &amp; \nil \\
 &amp; = &amp; \map(\assocL)(\nil) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\nil)) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zipPad(\beta,\gamma)(y,\nil))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zipPad(\beta,\gamma)(y,z))) \\
\end{eqnarray*}\]</span> as claimed. Suppose then that <span class="math inline">\(y = \cons(b,u)\)</span> and <span class="math inline">\(z = \cons(c,v)\)</span>. Using the inductive hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),y),z) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(\cons(a,x),\cons(b,u)),\cons(c,v)) \\
 &amp; = &amp; \zipPad((\alpha,\beta),\gamma)(\cons((a,b),\zipPad(\alpha,\beta)(x,u)),\cons(c,v)) \\
 &amp; = &amp; \cons(((a,b),c),\zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(x,u),v)) \\
 &amp; = &amp; \cons(\assocL(a,(b,c)),\map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\cons((a,(b,c)),\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\cons((b,c),\zipPad(\beta,\gamma)(u,v)))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zipPad(\beta,\gamma)(\cons(b,u),\cons(c,v)))) \\
 &amp; = &amp; \map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(\cons(a,x),\zip(y,z))) \\
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z)) \\
 &amp; = &amp; \id(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z))) \\
 &amp; = &amp; \map(\id)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z))) \\
 &amp; = &amp; \map(\assocR \circ \assocL)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z))) \\
 &amp; = &amp; \map(\assocR)(\map(\assocL)(\zipPad(\alpha,(\beta,\gamma))(x,\zipPad(\beta,\gamma)(y,z)))) \\
 &amp; = &amp; \map(\assocR)(\zipPad((\alpha,\beta),\gamma)(\zipPad(\alpha,\beta)(x,y),z))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>A utility for type fixing:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; withTypeOf ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> withTypeOf x _ <span class="fu">=</span> x</code></pre></div>
<p>Here are our property tests for <span class="math inline">\(\zip\)</span> and <span class="math inline">\(\zipPad\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- map(swap)(zip(x,y)) == zip(y,x)</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip_swap ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zip_swap _ x y <span class="fu">=</span>
<span class="ot">&gt;</span>   (map swap (zip x y)) <span class="fu">====</span> (zip y x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- length(zip(x,y)) == min(length(x),length(y))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip_length ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zip_length _ n x y <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     lx <span class="fu">=</span> length x <span class="ot">`withTypeOf`</span> <span class="dt">Nat</span> n
<span class="ot">&gt;</span>   <span class="kw">in</span>
<span class="ot">&gt;</span>     (length (zip x y)) <span class="fu">====</span> (min lx (length y))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zip(zip(x,y),z) == map(assocL)zip(x,zip(y,z))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip_zip_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zip_zip_left _ x y z <span class="fu">=</span>
<span class="ot">&gt;</span>   (zip (zip x y) z) <span class="fu">====</span> map assocL (zip x (zip y z))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zip(zip(x,y),z) == map(assocR)zip(x,zip(y,z))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip_zip_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zip_zip_right _ x y z <span class="fu">=</span>
<span class="ot">&gt;</span>   (zip x (zip y z)) <span class="fu">====</span> map assocR (zip (zip x y) z)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zip'(x,y) == zip(x,y)</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip_alt ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zip_alt _ x y <span class="fu">=</span>
<span class="ot">&gt;</span>   (zip' x y) <span class="fu">====</span> (zip x y)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- map(swap)(zipPad(u,v)(x,y)) == zipPad(v,u)(y,x)</span>
<span class="ot">&gt;</span> _<span class="ot">test_zipPad_swap ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zipPad_swap _ u v x y <span class="fu">=</span>
<span class="ot">&gt;</span>   (map swap (zipPad u v x y)) <span class="fu">====</span> (zipPad v u y x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- length(zipPad(u,v)(x,y)) == max(length(x),length(y))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zipPad_length ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zipPad_length _ n u v x y <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     lx <span class="fu">=</span> length x <span class="ot">`withTypeOf`</span> <span class="dt">Nat</span> n
<span class="ot">&gt;</span>   <span class="kw">in</span>
<span class="ot">&gt;</span>     (length (zipPad u v x y)) <span class="fu">====</span> (max lx (length y))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zipPad((a,b),c)(zipPad(a,b)(x,y),z)</span>
<span class="ot">&gt;</span> <span class="co">--   == map(assocL)zipPad(a,(b,c))(x,zipPad(b,c)(y,z))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zipPad_zipPad_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zipPad_zipPad_left _ a b c x y z <span class="fu">=</span>
<span class="ot">&gt;</span>   eq
<span class="ot">&gt;</span>     (zipPad (a,b) c (zipPad a b x y) z)
<span class="ot">&gt;</span>     (map assocL (zipPad a (b,c) x (zipPad b c y z)))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zipPad((a,b),c)(zipPad(a,b)(x,y),z)</span>
<span class="ot">&gt;</span> <span class="co">--   == map(assocR)zipPad(a,(b,c))(x,zipPad(b,c)(y,z))</span>
<span class="ot">&gt;</span> _<span class="ot">test_zipPad_zipPad_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zipPad_zipPad_right _ a b c x y z <span class="fu">=</span>
<span class="ot">&gt;</span>   eq
<span class="ot">&gt;</span>     (zipPad a (b,c) x (zipPad b c y z))
<span class="ot">&gt;</span>     (map assocR (zipPad (a,b) c (zipPad a b x y) z))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- zipPad'(x,y) == zipPad(x,y)</span>
<span class="ot">&gt;</span> _<span class="ot">test_zipPad_alt ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">ListOf</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_zipPad_alt _ u v x y <span class="fu">=</span>
<span class="ot">&gt;</span>   (zipPad' u v x y) <span class="fu">====</span> (zipPad u v x y)</code></pre></div>
<p>And the suite:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- run all tests for zip</span>
<span class="ot">&gt;</span> _<span class="ot">test_zip ::</span> (<span class="dt">List</span> t, <span class="dt">Arbitrary</span> (t a), <span class="dt">Show</span> (t n), <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Natural</span> n, <span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> n, <span class="dt">Show</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> _test_zip t n maxSize numCases <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     args <span class="fu">=</span> stdArgs
<span class="ot">&gt;</span>       { maxSuccess <span class="fu">=</span> numCases
<span class="ot">&gt;</span>       , maxSize    <span class="fu">=</span> maxSize
<span class="ot">&gt;</span>       }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args (_test_zip_swap t)
<span class="ot">&gt;</span>   runTest args (_test_zip_length t n)
<span class="ot">&gt;</span>   runTest args (_test_zip_zip_left t)
<span class="ot">&gt;</span>   runTest args (_test_zip_zip_right t)
<span class="ot">&gt;</span>   runTest args (_test_zip_alt t)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args (_test_zipPad_swap t)
<span class="ot">&gt;</span>   runTest args (_test_zipPad_length t n)
<span class="ot">&gt;</span>   runTest args (_test_zipPad_zipPad_left t)
<span class="ot">&gt;</span>   runTest args (_test_zipPad_zipPad_right t)
<span class="ot">&gt;</span>   runTest args (_test_zipPad_alt t)</code></pre></div>
<p>And <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main_zip ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main_zip <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   _test_zip (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>) (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">20</span> <span class="dv">100</span>
<span class="ot">&gt;</span>   _test_zip (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">20</span> <span class="dv">100</span></code></pre></div>


<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
