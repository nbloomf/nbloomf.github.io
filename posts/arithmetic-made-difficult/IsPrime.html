<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Is Prime</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Is Prime</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2017-04-13 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}{\mathsf{compose}}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\apply}{\mathsf{apply}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)
\(\newcommand{\flipB}{\mathsf{flip2}}\)
\(\newcommand{\flipC}{\mathsf{flip3}}\)
\(\newcommand{\flipD}{\mathsf{flip4}}\)
\(\newcommand{\flipE}{\mathsf{flip5}}\)
\(\newcommand{\clone}{\mathsf{clone}}\)
\(\newcommand{\cloneC}{\mathsf{clone3}}\)
\(\newcommand{\composeB}{\mathsf{compose2}}\)
\(\newcommand{\composeC}{\mathsf{compose3}}\)


<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}{\mathsf{natrec}}\)
\(\newcommand{\simprec}{\mathsf{simprec}}\)
\(\newcommand{\bailrec}{\mathsf{bailrec}}\)
\(\newcommand{\mutrec}{\mathsf{mutrec}}\)
\(\newcommand{\dnatrec}{\mathsf{dnatrec}}\)
\(\newcommand{\normrec}{\mathsf{normrec}}\)
\(\newcommand{\findsmallest}{\mathsf{findsmallest}}\)
\(\newcommand{\mnormrec}{\mathsf{mnormrec}}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}{\mathsf{foldr}}\)
\(\newcommand{\foldl}{\mathsf{foldl}}\)
\(\newcommand{\tacunfoldN}{\mathsf{tacunfoldN}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\dfoldr}{\mathsf{dfoldr}}\)
\(\newcommand{\cfoldr}{\mathsf{cfoldr}}\)
\(\newcommand{\bfoldr}{\mathsf{bfoldr}}\)
\(\newcommand{\dbfoldr}{\mathsf{dbfoldr}}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/IsPrime.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">IsPrime</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( mindiv, prime, _test_prime, main_prime</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Functions</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Flip</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Booleans</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">And</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">DisjointUnions</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">NaturalNumbers</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">LessThanOrEqualTo</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Divides</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">GreatestCommonDivisor</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">FindSmallest</span></a></code></pre></div>
<p>Today we’ll nail down what it means for a natural number to be <em>prime</em>. Typically this is done by saying something like “a natural number other than 0 or 1 is prime if it is not divisible by any natural number besides itself and 1” and from there, arguing that this property can be checked using trial division. As is typical in this series, we will turn this around – <em>defining</em> primes to be those numbers which are detected by trial division (i.e. an algorithm) and then proving that such numbers have the divisibility properties we expect.</p>
<p>In fact we’ll do a little more: instead of simply using trial division to detect whether a natural number <span class="math inline">\(n\)</span> is prime, we can use it to find the smallest divisor of <span class="math inline">\(n\)</span>. If the smallest divisor is <span class="math inline">\(n\)</span> itself, then <span class="math inline">\(n\)</span> is prime. To make this work we have to define “smallest divisor” in such a way that the trivial divisor <span class="math inline">\(\next(\zero)\)</span> is excluded. We will call this function that finds the smallest divisor <span class="math inline">\(\nmindiv\)</span>, and intuitively it should have the signature <span class="math inline">\(\nats \rightarrow \nats\)</span>.</p>
<div class="definition">
<p>Define <span class="math inline">\(\sigma : \nats \rightarrow \bool^{\nats}\)</span> by <span class="math display">\[\sigma(a)(b) = \div(b,a),\]</span> and define <span class="math inline">\(\varphi : \nats \rightarrow 1 + \nats\)</span> piecewise by <span class="math display">\[\nmindiv(n) = \left\{\begin{array}{ll}
 \rgt(\zero) &amp; \mathrm{if}\ n = \zero \\
 \rgt(\next(\zero)) &amp; \mathrm{if}\ n = \next(\zero) \\
 \findsmallest(\sigma(n))(m,\next(\next(\zero))) &amp; \mathrm{if}\ n = \next(\next(m)).
\end{array}\right.\]</span> Now define <span class="math inline">\(\nmindiv : \nats \rightarrow \nats\)</span> by <span class="math display">\[\nmindiv(n) = \either(\const(n),\id)(\varphi(n)).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mindiv ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">mindiv n <span class="fu">=</span> either (const n) id (phi n)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    phi t <span class="fu">=</span> <span class="kw">case</span> unnext t <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="dt">Left</span> () <span class="ot">-&gt;</span> rgt zero</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">Right</span> k <span class="ot">-&gt;</span> <span class="kw">case</span> unnext k <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        <span class="dt">Left</span> () <span class="ot">-&gt;</span> rgt (next zero)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="dt">Right</span> m <span class="ot">-&gt;</span> findSmallest (sigma n) m (next (next zero))</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    sigma <span class="fu">=</span> flip div</a></code></pre></div>
</div>
<p>Almost by definition, <span class="math inline">\(\nmindiv(a)\)</span> is the smallest divisor of <span class="math inline">\(a\)</span> in a precise sense.</p>
<div class="theorem">
<p>Let <span class="math inline">\(a \in \nats\)</span> with <span class="math inline">\(\nleq(\next(\next(\zero)),a)\)</span>. Then we have the following.</p>
<ol type="1">
<li><span class="math inline">\(\nleq(\next(\next(\zero)),\nmindiv(a))\)</span> and <span class="math inline">\(\ndiv(\nmindiv(a),a)\)</span>.</li>
<li>If <span class="math inline">\(\nleq(\next(\next(\zero)),k)\)</span> and <span class="math inline">\(\ndiv(k,a)\)</span>, then <span class="math inline">\(\nleq(\nmindiv(a),k)\)</span>.</li>
</ol>
<div class="proof">
<p>If <span class="math inline">\(a = \next(\next(m))\)</span> for some <span class="math inline">\(m\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nmindiv(a) \\
 &amp; = &amp; \nmindiv(\next(\next(m))) \\
 &amp; = &amp; \either(\const(a),\id)(\findsmallest(\sigma(a))(m,\next(\next(\zero)))).
\end{eqnarray*}\]</span> We have two possibilities for <span class="math inline">\(\findsmallest(\sigma(a))(m,\next(\next(\zero))) = Q\)</span>.</p>
<p>Suppose <span class="math inline">\(Q = \rgt(t)\)</span>; then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \either(\const(a),\id)(Q) \\
 &amp; = &amp; \either(\const(a),\id)(\rgt(t)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/DisjointUnions.html#def-either-rgt}
   = &amp; \id(t) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-id}
   = &amp; t
\end{eqnarray*}\]</span> By the properties of <span class="math inline">\(\findsmallest(\sigma(a))\)</span> we have <span class="math inline">\(\nleq(\next(\next(\zero)),t)\)</span> and <span class="math inline">\(\nleq(t,\next(m))\)</span> (so <span class="math inline">\(t \neq \zero\)</span> and <span class="math inline">\(t \neq \next(\zero)\)</span>) and <span class="math inline">\(\ndiv(t,a)\)</span>, and moreover if <span class="math inline">\(\nleq(\next(\next(\zero)),k)\)</span> and <span class="math inline">\(\nleq(k,\next(m))\)</span> and <span class="math inline">\(\ndiv(k,a)\)</span> then <span class="math inline">\(\nleq(t,k)\)</span> as claimed.</p>
<p>Suppose instead that <span class="math inline">\(Q = \lft(\ast)\)</span>; then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \either(\const(a),\id)(Q) \\
 &amp; = &amp; \either(\const(a),\id)(\lft(\ast)) \\
 &amp;     \href{/posts/arithmetic-made-difficult/DisjointUnions.html#def-either-lft}
   = &amp; \const(a)(\ast) \\
 &amp; = &amp; a. 
\end{eqnarray*}\]</span> Again by the properties of <span class="math inline">\(\findsmallest(\sigma(a))\)</span>, there does not exist <span class="math inline">\(k\)</span> such that <span class="math inline">\(\nleq(\next(\next(\zero)),k)\)</span> and <span class="math inline">\(\nleq(k,\next(m))\)</span> and <span class="math inline">\(\ndiv(k,a)\)</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">_test_mindiv_div ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (n <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">_test_mindiv_div _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  testName <span class="st">&quot;if leq(next(next(zero)),a) then leq(next(next(zero)),mindiv(a)) and div(mindiv(a),a)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  \a <span class="ot">-&gt;</span> <span class="kw">if</span> leq (next (next zero)) a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">then</span> and (leq (next (next zero)) (mindiv a)) (div (mindiv a) a)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">_test_mindiv_min ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (n <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">_test_mindiv_min _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  testName <span class="st">&quot;if leq(next(next(zero)),k) and div(k,a) then leq(mindiv(a),k)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  \a k <span class="ot">-&gt;</span> <span class="kw">if</span> and (leq (next (next zero)) k) (div k a)</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="kw">then</span> leq (mindiv a) k</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p>Now we define a boolean function <span class="math inline">\(\nisprime\)</span> as follows.</p>
<div class="definition">
<p>Define <span class="math inline">\(\nisprime : \nats \rightarrow \bool\)</span> by <span class="math display">\[\nisprime(a) = \left\{ \begin{array}{ll} \bfalse &amp; \mathrm{if} a = \zero\ \mathrm{or}\ a = \next(\zero) \\ \beq(a,\nmindiv(a)) &amp; \mathrm{otherwise}. \end{array} \right.\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">prime ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">prime a <span class="fu">=</span> <span class="kw">if</span> leq a (next zero)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">then</span> false</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">else</span> eq a (mindiv a)</a></code></pre></div>
</div>
<p>It is straightforward to show that <span class="math inline">\(\nisprime\)</span> is equivalent to the usual definition.</p>
<div class="theorem">
<p>Let <span class="math inline">\(a \in \nats\)</span>. Then the following are equivalent.</p>
<ol type="1">
<li><span class="math inline">\(\nisprime(a) = \btrue\)</span>.</li>
<li><span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>, and if <span class="math inline">\(u,v \in \nats\)</span> such that <span class="math inline">\(a = \ntimes(u,v)\)</span>, then <span class="math inline">\((u,v)\)</span> is either <span class="math inline">\((\next(\zero),a)\)</span> or <span class="math inline">\((a,\next(\zero))\)</span>.</li>
<li><span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>, and if <span class="math inline">\(u,v \in \nats\)</span> such that <span class="math inline">\(\ndiv(a,\ntimes(u,v))\)</span>, then either <span class="math inline">\(\ndiv(a,u)\)</span> or <span class="math inline">\(\ndiv(a,v)\)</span>.</li>
</ol>
<div class="proof">
<p><span class="math inline">\((1)\)</span> implies <span class="math inline">\((2)\)</span>: Suppose <span class="math inline">\(\nisprime(a) = \btrue\)</span>. Certainly <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span> (by definition), and we have <span class="math inline">\(a = \nmindiv(a)\)</span>. Suppose now that <span class="math inline">\(a = \ntimes(u,v)\)</span>; we consider three cases for <span class="math inline">\(u\)</span>. If <span class="math inline">\(u = \zero\)</span> we have <span class="math inline">\(a = \zero\)</span>, a contradiction. If <span class="math inline">\(u = \next(\zero)\)</span>, then <span class="math inline">\(v = a\)</span>. If <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>, we have <span class="math inline">\(\ndiv(u,a)\)</span>, so that <span class="math inline">\(\nleq(\nmindiv(a),u)\)</span>; thus <span class="math inline">\(\nleq(a,u)\)</span>. But also <span class="math inline">\(\nleq(u,a)\)</span>, so that <span class="math inline">\(u = a\)</span>, and thus <span class="math inline">\(v = \next(\zero)\)</span> as claimed.</p>
<p><span class="math inline">\((2)\)</span> implies <span class="math inline">\((3)\)</span>: Of course <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>. Say <span class="math inline">\(\ndiv(a,\ntimes(u,v))\)</span>, and consider <span class="math inline">\(\ngcd(a,u)\)</span>. In particular, we have <span class="math inline">\(a = \ntimes(k,\ngcd(a,u))\)</span> for some <span class="math inline">\(k\)</span>. There are two possibilities: if <span class="math inline">\(\ngcd(a,u) = a\)</span>, then <span class="math inline">\(\ndiv(a,u)\)</span>, and if <span class="math inline">\(\ngcd(a,u) = \next(\zero)\)</span>, then <span class="math inline">\(\ndiv(a,v)\)</span> by Euclid’s lemma.</p>
<p><span class="math inline">\((3)\)</span> implies <span class="math inline">\((1)\)</span>: It suffices to show that if <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span> then <span class="math inline">\(\nmindiv(a) = a\)</span>. To this end, let <span class="math inline">\(d = \nmindiv(a)\)</span> and write <span class="math inline">\(a = \ntimes(\nmindiv(a),k)\)</span>. Suppose <span class="math inline">\(\ndiv(a,k)\)</span>, with <span class="math inline">\(k = \ntimes(a,w)\)</span>. Since <span class="math inline">\(a \neq \zero\)</span>, by cancellation we have <span class="math inline">\(\next(\zero) = \ntimes(\nmindiv(a),w)\)</span>, so that <span class="math inline">\(\nmindiv(a) = \next(\zero)\)</span>, a contradiction. Thus <span class="math inline">\(\ndiv(a,\nmindiv(a))\)</span>, so we have <span class="math inline">\(a = \nmindiv(a)\)</span> as needed.</p>
</div>
</div>
<p>Minimal divisors are prime.</p>
<div class="theorem">
<p>Let <span class="math inline">\(a \in \nats\)</span> with <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>. Then <span class="math display">\[\nisprime(\nmindiv(a)) = \btrue.\]</span></p>
<div class="proof">
<p>Let <span class="math inline">\(a \in \nats\)</span> with <span class="math inline">\(a \neq \zero\)</span> and <span class="math inline">\(a \neq \next(\zero)\)</span>, and let <span class="math inline">\(d = \nmindiv(a)\)</span>. Suppose now that <span class="math inline">\(d = \ntimes(u,v)\)</span>. Since <span class="math inline">\(d \neq \zero\)</span>, we have <span class="math inline">\(u \neq \zero\)</span>. If <span class="math inline">\(u = \next(\zero)\)</span>, we have <span class="math inline">\(v = d\)</span>. If <span class="math inline">\(u \neq \next(\zero)\)</span>, we have <span class="math inline">\(\ndiv(u,a)\)</span> and thus <span class="math inline">\(\nleq(d,u)\)</span>; but <span class="math inline">\(\nleq(u,d)\)</span>, so that <span class="math inline">\(d = u\)</span> by antisymmetry and thus <span class="math inline">\(v = \next(\zero)\)</span>. Thus <span class="math inline">\(\nisprime(\nmindiv(a))\)</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">_test_prime_mindiv ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (n <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">_test_prime_mindiv _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  testName <span class="st">&quot;if leq(next(next(zero)),a) then prime(mindiv(a)) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  \a <span class="ot">-&gt;</span> <span class="kw">if</span> leq (next (next zero)) a</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="kw">then</span> eq (prime (mindiv a)) true</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p>Primes interact with <span class="math inline">\(\ngcd\)</span> as expected.</p>
<div class="theorem">
<p>Let <span class="math inline">\(p,a \in \nats\)</span> with <span class="math inline">\(\nisprime(p)\)</span>. Then <span class="math display">\[\ngcd(a,p) = \left\{ \begin{array}{ll} p &amp; \mathrm{if}\ \ndiv(p,a) \\ \next(\zero) &amp; \mathrm{otherwise}. \end{array} \right.\]</span></p>
<div class="proof">
<p>Let <span class="math inline">\(d = \ngcd(a,p)\)</span>. Now <span class="math inline">\(\ndiv(d,p)\)</span>, so that either <span class="math inline">\(d = \next(\zero)\)</span> or <span class="math inline">\(d = p\)</span>. If <span class="math inline">\(\ndiv(p,a) = \bfalse\)</span>, we thus have <span class="math inline">\(d = \next(\zero)\)</span>.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">_test_prime_gcd ::</span> (<span class="dt">Natural</span> n, <span class="dt">Equal</span> n)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (n <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">_test_prime_gcd _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  testName <span class="st">&quot;if prime(p) then eq(gcd(a,p),if(div(p,a),p,next(0)))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  \a p <span class="ot">-&gt;</span> <span class="kw">if</span> prime p</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> <span class="kw">if</span> div p a</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      <span class="kw">then</span> eq (gcd a p) p</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      <span class="kw">else</span> eq (gcd a p) (next zero)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>Suite:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">_test_prime ::</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  ( <span class="dt">TypeName</span> n, <span class="dt">Natural</span> n, <span class="dt">Equal</span> n, <span class="dt">Arbitrary</span> n, <span class="dt">Show</span> n</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  ) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">_test_prime n size cases <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  testLabel1 <span class="st">&quot;mindiv &amp; prime&quot;</span> n</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">let</span> args <span class="fu">=</span> testArgs size cases</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  runTest args (_test_mindiv_div n)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  runTest args (_test_mindiv_min n)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  runTest args (_test_prime_mindiv n)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  runTest args (_test_prime_gcd n)</a></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">main_prime ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">main_prime <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  _test_prime (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">40</span> <span class="dv">100</span></a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
