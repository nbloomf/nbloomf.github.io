<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Arithmetic Made Difficult</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Arithmetic Made Difficult</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2018-01-12 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}{\mathsf{compose}}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\apply}{\mathsf{apply}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)
\(\newcommand{\flipB}{\mathsf{flip2}}\)
\(\newcommand{\flipC}{\mathsf{flip3}}\)
\(\newcommand{\flipD}{\mathsf{flip4}}\)
\(\newcommand{\flipE}{\mathsf{flip5}}\)
\(\newcommand{\clone}{\mathsf{clone}}\)
\(\newcommand{\cloneC}{\mathsf{clone3}}\)
\(\newcommand{\composeAonB}{\mathsf{compose1on2}}\)
\(\newcommand{\composeAonC}{\mathsf{compose1on3}}\)
\(\newcommand{\composeAonD}{\mathsf{compose1on4}}\)
\(\newcommand{\composeBonA}{\mathsf{compose2on1}}\)
\(\newcommand{\composeBonB}{\mathsf{compose2on2}}\)
\(\newcommand{\composeConA}{\mathsf{compose3on1}}\)


<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}{\mathsf{natrec}}\)
\(\newcommand{\simprec}{\mathsf{simprec}}\)
\(\newcommand{\bailrec}{\mathsf{bailrec}}\)
\(\newcommand{\mutrec}{\mathsf{mutrec}}\)
\(\newcommand{\dnatrec}{\mathsf{dnatrec}}\)
\(\newcommand{\normrec}{\mathsf{normrec}}\)
\(\newcommand{\findsmallest}{\mathsf{findsmallest}}\)
\(\newcommand{\mnormrec}{\mathsf{mnormrec}}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}{\mathsf{foldr}}\)
\(\newcommand{\foldl}{\mathsf{foldl}}\)
\(\newcommand{\tacunfoldN}{\mathsf{tacunfoldN}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\dfoldr}{\mathsf{dfoldr}}\)
\(\newcommand{\cfoldr}{\mathsf{cfoldr}}\)
\(\newcommand{\bfoldr}{\mathsf{bfoldr}}\)
\(\newcommand{\dbfoldr}{\mathsf{dbfoldr}}\)
\(\newcommand{\lfoldr}{\mathsf{lfoldr}}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\last}{\mathsf{last}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Testing.lhs">the source</a> into GHCi and play along.</p>

<hr />

<p>Proving that programs are correct is hard. For one thing, determining what it means for a program to <em>be</em> correct is not trivial – it always has a certain output? never has an error? doesn’t do unnecessary work? what is the execution model? But programs can be very useful and expensive things, and any assurance that they do what we think they do is valuable.</p>
<p>Comparatively, proving theorems in mathematics is easy. In algebra especially lots of proofs can be written in the so-called “equational” style, which is straightforward to the point of boringness. In this style of proof we start with a list of <em>identities</em>; equalities between two expressions involving both <em>constants</em> and <em>variables</em> that we assume to be true for any values we might substitute for the variables. We then deduce more identities using a substitution rule. For example, we can think of the symbols <span class="math inline">\(+\)</span>, <span class="math inline">\(2\)</span>, and <span class="math inline">\(3\)</span> as constants, the symbols <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as variables, and the expression <span class="math inline">\(a + b = b + a\)</span> as an identity. From this identity we can deduce the identity <span class="math inline">\(2 + 3 = 3 + 2\)</span>, by making the substitution <span class="math inline">\(a = 2\)</span> and <span class="math inline">\(b = 3\)</span>. This is a simple, one-step example, but the basic strategy is widely applicable – the <a href="http://us.metamath.org/">Metamath</a> project aims to formalize large chunks of mathematics using (more or less) this strategy. What’s more, verifying that such proofs are valid can be done by pattern matching, using the identities as rewrite rules.</p>
<p>So we have on the one hand some programs we’d like to prove things about, and on the other a simple proof technique. With some careful thought, we can apply one to the other – we just have to get used to thinking of programs as <em>arithmetic</em> in an appropriate <em>algebra</em>.</p>
<p>This is an old idea, and many books have been written about it. In this series of posts I’ll be exploring this idea for myself. In a nutshell, different kinds of data structures can be thought of as elements of an algebra with a universal property. The prototype for this point of view is the natural numbers; the universal property is essentially the principle of mathematical induction, and we can use it to define the usual arithmetic on numbers. This process generalizes to other kinds of structures, and “arithmetic” generalizes to <em>programs</em>. And just like induction is the power tool for proving things about the natural numbers, generalized induction can be used to prove things in the equational style.</p>
<p>We can build an <em>algebra of programs</em>, and doing so has some interesting benefits.</p>
<ul>
<li>In algebra, interesting objects are often defined in terms of a <em>universal property</em>. Instead of defining an object in terms of what it <em>is</em>, a universal property characterizes an object by how it <em>behaves</em>. It’s a very declarative way of thinking. This gives a simple, prepackaged way to detect when two programs are equivalent, such as a slow-but-obviously-correct one and a fast-but-not-obviously-correct one.</li>
<li>Just as in ordinary arithmetic, many theorems come in the form of universally quantified equations. These are tailor made for <em>property-based</em> or <em>generative</em> testing.</li>
<li>Equational proofs come with a simple strategy for verification: term rewriting. If we’re careful about how we write proofs, individual steps can be mechanically verified by a simple tool.</li>
</ul>
<p>We could do this using a language designed specifically for formal verification, but I’d like to stay as close to English as possible. At the same time, in any big list of proofs there’s the danger that some of them are wrong. To help mitigate this I’ll use two different kinds of checks. First, we’ll implement our definitions in an executable language and include automated tests for as many theorems as possible. And second, as much as possible, we’ll use a term rewriting tool to check that the steps in our equational proofs are correct. If you see a blue equals sign in an equational proof, that signifies a link to the previous theorem or definition which justifies the equality. But more than that, the blue equals signs are verified by an <a href="../../posts/2018-01-22-a-simple-term-rewriting-tool.html">automated tool</a>.</p>
<h2 id="property-testing">Property Testing</h2>
<p>I’ve chosen to write my executable definitions in Haskell, because that’s what I’m most comfortable with, but that’s just a choice – many other languages would do. Many theorems will have a stackish flavor; something like Factor or J might also work well.</p>
<p>We’ll use the <code>QuickCheck</code> library to make our theorems testable. This is not the same as making our proofs machine-checkable, but can still be a useful tool for finding bugs and checking assumptions. This module reexports just enough of <code>QuickCheck</code> for our needs.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( <span class="dt">Test</span>, runTest, testName, withTypeOf, <span class="dt">TypeName</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  , labelTestArgs1</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  , testLabel0, testLabel1, testLabel2, testLabel3, testArgs</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  , <span class="dt">Equal</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  , <span class="kw">module</span> <span class="dt">Prelude</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  , <span class="kw">module</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  , <span class="kw">module</span> <span class="dt">Test.QuickCheck.Test</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  , <span class="kw">module</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  , <span class="kw">module</span> <span class="dt">Data.Typeable</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="dt">Prelude</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  ( <span class="dt">Show</span>(show), <span class="dt">IO</span>, <span class="dt">Int</span>, undefined, concat, <span class="dt">Bool</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  , putStrLn, (<span class="fu">&gt;&gt;</span>), (<span class="fu">&gt;&gt;=</span>), return, (<span class="fu">++</span>), <span class="dt">String</span>, (<span class="fu">.</span>), (<span class="fu">$</span>), <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  )</a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  ( <span class="dt">Testable</span>(<span class="fu">..</span>), <span class="dt">Args</span>(<span class="fu">..</span>), <span class="dt">Arbitrary</span>(<span class="fu">..</span>), <span class="dt">CoArbitrary</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  , quickCheckWithResult, stdArgs, variant</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  )</a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="kw">import</span> <span class="dt">Test.QuickCheck.Test</span> (isSuccess)</a>
<a class="sourceLine" id="cb1-26" data-line-number="26"><span class="kw">import</span> <span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="kw">import</span> <span class="dt">Data.Typeable</span> (<span class="dt">Typeable</span>, typeRep)</a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="kw">import</span> <span class="dt">Text.Show.Functions</span> ()</a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="kw">import</span> <span class="dt">System.Exit</span></a></code></pre></div>
<p>The <code>Test</code> type, with <code>testName</code>, is a shorthand for writing named tests.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Test</span> prop <span class="fu">=</span> (<span class="dt">String</span>, prop)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">testName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">Test</span> prop</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">testName name prop <span class="fu">=</span> (name, prop)</a></code></pre></div>
<p><code>runTest</code> runs a named test.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">runTest ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Args</span> <span class="ot">-&gt;</span> <span class="dt">Test</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">runTest args (name, prop) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  putStrLn (<span class="st">&quot;\x1b[1;34m&quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  result <span class="ot">&lt;-</span> quickCheckWithResult args prop</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="kw">if</span> isSuccess result</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">then</span> return ()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">else</span> putStrLn (show result) <span class="fu">&gt;&gt;</span> exitFailure</a></code></pre></div>
<p><code>TypeName</code>, <code>testLabel</code>, and friends are used to print headers for test suites.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> <span class="dt">TypeName</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  typeName ::</span> t <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">TypeName</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  typeName _ <span class="fu">=</span> <span class="st">&quot;Bool&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">TypeName</span> () <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  typeName _ <span class="fu">=</span> <span class="st">&quot;()&quot;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ot">testLabel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">testLabel msg <span class="fu">=</span> putStrLn (<span class="st">&quot;\n\x1b[1;32m&quot;</span> <span class="fu">++</span> msg <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="ot">testLabel0 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">testLabel0 <span class="fu">=</span> testLabel</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"><span class="ot">labelTestArgs1 ::</span> (<span class="dt">Typeable</span> a)</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">labelTestArgs1 str a <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  [ str, <span class="st">&quot;: &quot;</span>, show <span class="fu">$</span> typeRep a ]</a>
<a class="sourceLine" id="cb4-21" data-line-number="21"></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="ot">testLabel1 ::</span> (<span class="dt">TypeName</span> a)</a>
<a class="sourceLine" id="cb4-23" data-line-number="23">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">testLabel1 str a <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  [ str, <span class="st">&quot;: &quot;</span>, typeName a ]</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27"><span class="ot">testLabel2 ::</span> (<span class="dt">TypeName</span> a, <span class="dt">TypeName</span> b)</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">testLabel2 str a b <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">  [ str, <span class="st">&quot;: &quot;</span>, typeName a, <span class="st">&quot;, &quot;</span>, typeName b ]</a>
<a class="sourceLine" id="cb4-31" data-line-number="31"></a>
<a class="sourceLine" id="cb4-32" data-line-number="32"><span class="ot">testLabel3 ::</span> (<span class="dt">TypeName</span> a, <span class="dt">TypeName</span> b, <span class="dt">TypeName</span> c)</a>
<a class="sourceLine" id="cb4-33" data-line-number="33">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-34" data-line-number="34">testLabel3 str a b c <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-35" data-line-number="35">  [ str, <span class="st">&quot;: &quot;</span>, typeName a, <span class="st">&quot;, &quot;</span>, typeName b, <span class="st">&quot;, &quot;</span>, typeName c ]</a>
<a class="sourceLine" id="cb4-36" data-line-number="36"></a>
<a class="sourceLine" id="cb4-37" data-line-number="37"><span class="ot">testArgs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Args</span></a>
<a class="sourceLine" id="cb4-38" data-line-number="38">testArgs size cases <span class="fu">=</span> stdArgs</a>
<a class="sourceLine" id="cb4-39" data-line-number="39">  { maxSuccess <span class="fu">=</span> cases, maxSize <span class="fu">=</span> size }</a></code></pre></div>
<p><code>withTypeOf</code> is used to enforce type constraints in tests. It makes more sense when you see some examples.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">withTypeOf ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">withTypeOf x _ <span class="fu">=</span> x</a></code></pre></div>
<h2 id="equality">Equality</h2>
<p>To write tests, we also need a notion of “equality” for values. This is a little out of order – we’ll define the boolean truth values in a later post – but we need equality now, so I’ll put the definition here. Typically I think of equality (as in the <span class="math inline">\(=\)</span> symbol) as a metalanguage expression anyway.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Equal</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  eq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>(Why not use the built in <code>Eq</code> class? No good reason.) We’ll implement <code>Equal</code> for new types as we encounter them. For now we need two: <code>Bool</code> and <code>()</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Equal</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  eq <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  eq <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  eq <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  eq <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Equal</span> () <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  eq () () <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>All our instances of <code>Equal</code> will be assumed to satisfy the following.</p>
<div class="axiom">
<p><span id="thm-eq-reflexive"></span><span id="thm-eq-symmetric"></span> Let <span class="math inline">\(A\)</span> be a set.</p>
<ol type="1">
<li>For all <span class="math inline">\(a \in A\)</span>, we have <span class="math inline">\(\beq(a,a) = \btrue\)</span>.</li>
<li>For all <span class="math inline">\(a,b \in A\)</span>, we have <span class="math inline">\(\beq(a,b) = \beq(b,a)\)</span>.</li>
</ol>
</div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
