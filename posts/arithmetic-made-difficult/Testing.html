<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Arithmetic Made Difficult</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Arithmetic Made Difficult</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2018-01-12 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}[2]{(#1 \circ #2)}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)

<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}[2]{\mathsf{natrec}(#1,#2)}\)
\(\newcommand{\simprec}[2]{\mathsf{simprec}(#1,#2)}\)
\(\newcommand{\bailrec}[4]{\mathsf{bailrec}(#1,#2,#3,#4)}\)
\(\newcommand{\mutrec}[5]{\mathsf{mutrec}(#1,#2,#3,#4,#5)}\)
\(\newcommand{\dnatrec}[3]{\mathsf{dnatrec}(#1,#2,#3)}\)
\(\newcommand{\normrec}[3]{\mathsf{normrec}(#1,#2,#3)}\)
\(\newcommand{\findsmallest}[1]{\mathsf{findsmallest}(#1)}\)
\(\newcommand{\mnormrec}[4]{\mathsf{normrec}(#1,#2,#3,#4)}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\foldl}[1]{\mathsf{foldl}(#1)}\)
\(\newcommand{\tacunfoldN}[1]{\mathsf{tacunfoldN}(#1)}\)
\(\newcommand{\unfoldN}[1]{\mathsf{unfoldN}(#1)}\)
\(\newcommand{\dfoldr}[3]{\mathsf{dfoldr}(#1,#2,#3)}\)
\(\newcommand{\cfoldr}[2]{\mathsf{cfoldr}(#1,#2)}\)
\(\newcommand{\bfoldr}[4]{\mathsf{bfoldr}(#1,#2,#3,#4)}\)
\(\newcommand{\dbfoldr}[5]{\mathsf{dbfoldr}(#1,#2,#3,#4,#5)}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Testing.lhs">the source</a> into GHCi and play along.</p>

<hr />

<p>Proving that programs are correct is hard. For one thing, determining what it means for a program to <em>be</em> correct is not trivial – it always has a certain output? never has an error? doesn’t do unnecessary work? what is the execution model? But programs can be very useful things, and assurance that they are “correct” (whatever that means) may be valuable.</p>
<p>Comparatively, proving theorems in mathematics is easy. In algebra especially lots of proofs can be written in the so-called “equational” style, which is straightforward to the point of boringness. In this style of proof we can establish that <span class="math inline">\(A\)</span> is equal to <span class="math inline">\(B\)</span> by producing a sequence of statements, each equal to the next according to strict rules, starting at <span class="math inline">\(A\)</span> and ending at <span class="math inline">\(B\)</span>. Verifying that such proofs are valid can be done by pattern matching, using identities as rewrite rules.</p>
<p>So we have on the one hand some programs we’d like to prove things about, and on the other a simple proof technique. With some careful thought, we can apply one to the other – we just have to get used to thinking of programs as <em>arithmetic</em> in an appropriate <em>algebra</em>.</p>
<p>This is an old idea, and many books have been written about it. In this series of posts I’ll be exploring this idea for myself. In a nutshell, different kinds of data structures can be thought of as elements of an algebra with a universal property. The prototype for this point of view is the natural numbers; the universal property is essentially the principle of mathematical induction, and we can use it to define the usual arithmetic on numbers. This process generalizes to other kinds of structures, and “arithmetic” generalizes to <em>programs</em>. And just like induction is the power tool for proving things about the natural numbers, generalized induction can be used to prove things in the equational style.</p>
<p>We can build an <em>algebra of programs</em>, and doing so has some interesting benefits.</p>
<ul>
<li>In algebra, interesting objects are often defined in terms of a <em>universal property</em>. Instead of defining an object in terms of what it <em>is</em>, a universal property characterizes an object by how it <em>behaves</em>. It’s a very declarative way of thinking. This gives a simple, prepackaged way to detect when two programs are equivalent, such as a slow-but-obviously-correct one and a fast-but-not-obviously-correct one.</li>
<li>Just as in ordinary arithmetic, many theorems come in the form of universally quantified equations. These are tailor made for <em>property-based</em> or <em>generative</em> testing.</li>
<li>Equational proofs come with a simple strategy for verification: term rewriting. If we’re careful about how we write proofs, individual steps can be mechanically verified by a simple tool.</li>
</ul>
<p>In this series of posts I’ll be exploring this idea in detail, including lots of proofs. We could do this using a language designed specifically for formal verification, but I’d like to stay as close to English as possible. At the same time, in any big list of proofs there’s the danger that some of them are wrong. To help mitigate this I’ll use two different kinds of checks. First, we’ll include automated tests for as many theorems as possible. And second, as much as possible, we’ll use a term rewriting tool to check that the steps in our equational proofs are correct. If you see a blue equals sign in an equational proof, that signifies a link to the previous theorem or definition which justifies the equality. But more than that, the blue equals signs are verified by an <a href="../../posts/2018-01-22-a-simple-term-rewriting-tool.html">automated tool</a>.</p>
<h2 id="property-testing">Property Testing</h2>
<p>We’ll use the <code>QuickCheck</code> library to make our theorems testable. This is not the same as making our proofs machine-checkable, but can still be a useful tool for finding bugs. This module reexports just enough of <code>QuickCheck</code> for our needs.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( <span class="dt">Test</span>, runTest, testName, withTypeOf, <span class="dt">TypeName</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  , testLabel0, testLabel1, testLabel2, testLabel3</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  , <span class="kw">module</span> <span class="dt">Prelude</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  , <span class="kw">module</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  , <span class="kw">module</span> <span class="dt">Test.QuickCheck.Test</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Prelude</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  ( <span class="dt">Show</span>(show), <span class="dt">IO</span>, <span class="dt">Bool</span>(), <span class="dt">Int</span>, <span class="dt">Maybe</span>(<span class="fu">..</span>), <span class="dt">Either</span>(<span class="fu">..</span>), undefined, concat</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  , putStrLn, (<span class="fu">&gt;&gt;</span>), return, (<span class="fu">++</span>), <span class="dt">String</span>, (<span class="fu">.</span>), (<span class="fu">$</span>), <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  )</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  ( <span class="dt">Testable</span>(<span class="fu">..</span>), <span class="dt">Args</span>(<span class="fu">..</span>), <span class="dt">Arbitrary</span>(<span class="fu">..</span>), <span class="dt">CoArbitrary</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  , quickCheckWithResult, stdArgs, variant</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  )</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Test.QuickCheck.Test</span> (isSuccess)</a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">Text.Show.Functions</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="dt">System.Exit</span></a></code></pre></div>
<p>The <code>Test</code> type, with <code>testName</code>, is a shorthand for writing named tests.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Test</span> prop <span class="fu">=</span> (<span class="dt">String</span>, prop)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">testName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">Test</span> prop</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">testName name prop <span class="fu">=</span> (name, prop)</a></code></pre></div>
<p><code>runTest</code> runs a named test.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">runTest ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Args</span> <span class="ot">-&gt;</span> <span class="dt">Test</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">runTest args (name, prop) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  putStrLn (<span class="st">&quot;\x1b[1;34m&quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  result <span class="ot">&lt;-</span> quickCheckWithResult args prop</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="kw">if</span> isSuccess result</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">then</span> return ()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">else</span> putStrLn (show result) <span class="fu">&gt;&gt;</span> exitFailure</a></code></pre></div>
<p><code>TypeName</code>, <code>testLabel</code>, and friends are used to print headers for test suites.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> <span class="dt">TypeName</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  typeName ::</span> t <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">TypeName</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  typeName _ <span class="fu">=</span> <span class="st">&quot;Bool&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ot">testLabel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">testLabel msg <span class="fu">=</span> putStrLn (<span class="st">&quot;\n\x1b[1;32m&quot;</span> <span class="fu">++</span> msg <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ot">testLabel0 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">testLabel0 <span class="fu">=</span> testLabel</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="ot">testLabel1 ::</span> (<span class="dt">TypeName</span> a)</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">testLabel1 str a <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  [ str, <span class="st">&quot;: &quot;</span>, typeName a ]</a>
<a class="sourceLine" id="cb4-18" data-line-number="18"></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"><span class="ot">testLabel2 ::</span> (<span class="dt">TypeName</span> a, <span class="dt">TypeName</span> b)</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">testLabel2 str a b <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  [ str, <span class="st">&quot;: &quot;</span>, typeName a, <span class="st">&quot;, &quot;</span>, typeName b ]</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24"><span class="ot">testLabel3 ::</span> (<span class="dt">TypeName</span> a, <span class="dt">TypeName</span> b, <span class="dt">TypeName</span> c)</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">testLabel3 str a b c <span class="fu">=</span> testLabel <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  [ str, <span class="st">&quot;: &quot;</span>, typeName a, <span class="st">&quot;, &quot;</span>, typeName b, <span class="st">&quot;, &quot;</span>, typeName c ]</a></code></pre></div>
<p><code>withTypeOf</code> is used to enforce type constraints in tests. It makes more sense when you see some examples.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">withTypeOf ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">withTypeOf x _ <span class="fu">=</span> x</a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
