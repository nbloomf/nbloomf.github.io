<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Sublist</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Sublist</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2017-05-23 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}[2]{\mathsf{natrec}(#1,#2)}\)
\(\newcommand{\simprec}[2]{\mathsf{simprec}(#1,#2)}\)
\(\newcommand{\bailrec}[4]{\mathsf{bailrec}(#1,#2,#3,#4)}\)
\(\newcommand{\mutrec}[5]{\mathsf{mutrec}(#1,#2,#3,#4,#5)}\)
\(\newcommand{\dnatrec}[3]{\mathsf{dnatrec}(#1,#2,#3)}\)
\(\newcommand{\normrec}[3]{\mathsf{normrec}(#1,#2,#3)}\)
\(\newcommand{\findsmallest}[1]{\mathsf{findsmallest}(#1)}\)
\(\newcommand{\mnormrec}[4]{\mathsf{normrec}(#1,#2,#3,#4)}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\foldl}[1]{\mathsf{foldl}(#1)}\)
\(\newcommand{\tacunfoldN}[1]{\mathsf{tacunfoldN}(#1)}\)
\(\newcommand{\unfoldN}[1]{\mathsf{unfoldN}(#1)}\)
\(\newcommand{\dfoldr}[3]{\mathsf{dfoldr}(#1,#2,#3)}\)
\(\newcommand{\cfoldr}[2]{\mathsf{cfoldr}(#1,#2)}\)
\(\newcommand{\bfoldr}[4]{\mathsf{bfoldr}(#1,#2,#3,#4)}\)
\(\newcommand{\dbfoldr}[5]{\mathsf{dbfoldr}(#1,#2,#3,#4,#5)}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Sublist.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Sublist</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( sublist, _test_sublist, main_sublist</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Booleans</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Not</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">And</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Or</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Implies</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Tuples</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">NaturalNumbers</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Plus</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">LessThanOrEqualTo</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Lists</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="dt">HeadAndTail</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">DoubleFold</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Snoc</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Reverse</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">Length</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span> <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="dt">UnfoldN</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="kw">import</span> <span class="dt">Zip</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26"><span class="kw">import</span> <span class="dt">PrefixAndSuffix</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="kw">import</span> <span class="dt">AllAndAny</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="kw">import</span> <span class="dt">TailsAndInits</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="kw">import</span> <span class="dt">Filter</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30"><span class="kw">import</span> <span class="dt">Elt</span></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="kw">import</span> <span class="dt">Count</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32"><span class="kw">import</span> <span class="dt">Repeat</span></a></code></pre></div>
<p>Today we’ll nail down what it means for one list to be a <em>sublist</em> of another. Intuitively, a sublist is “part of” some larger list; but there is some ambiguity here: does the sublist have to be contiguous in the larger list? For example, it seems clear that <span class="math display">\[\langle b, c \rangle\]</span> should be considered a sublist of <span class="math display">\[\langle a, b, c, d, e \rangle\]</span> while <span class="math display">\[\langle e, g \rangle\]</span> should not. But what about <span class="math display">\[\langle a, c \rangle,\]</span> or even <span class="math display">\[\langle c, a \rangle\]</span> for that matter? First, lists are inherently ordered, so the “sublist” idea should reflect this – sublists have to respect the order of their superlists. On the other hand, it is less crucial that sublists be contiguous in their superlists. Contiguous sublists are still interesting though (for reasons we’ll see later), so we will single them out as infixes (analogous to prefixes and suffixes).</p>
<p>So we have two related but distinct concepts, sublists and infixes, that will need to be dealt with separately. We’ll define two boolean functions, <span class="math inline">\(\sublist\)</span> and <span class="math inline">\(\infix\)</span>, which detect when one list is a sublist or infix (respectively) of another. We’ll start with <span class="math inline">\(\sublist\)</span>. This function should have a signature like <span class="math display">\[\lists{A} \times \lists{A} \rightarrow \bool.\]</span> Double fold was made for situations like this, so we could try to define <span class="math inline">\(\sublist\)</span> as a double fold like <span class="math display">\[\sublist(x,y) = \dfoldr{\delta}{\psi}{\chi}(x,y)\]</span> But if we do this, assuming some reasonable behavior for <span class="math inline">\(\sublist\)</span>, we get stuck! (Try it!) What happens is that the fold eats <span class="math inline">\(x\)</span>, but when <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are not nil but have different first items we need the recursion to un-eat the <span class="math inline">\(x\)</span> parameter. The fix is to instead fold on <span class="math inline">\(y\)</span> like <span class="math display">\[\sublist(x,y) = \dfoldr{\delta}{\psi}{\chi}(y,x).\]</span></p>
<p>Blah blah, define <span class="math inline">\(\sublist\)</span> like this.</p>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> be a set. Define <span class="math inline">\(\psi : A \times \bool \rightarrow \bool\)</span> by <span class="math display">\[\psi(a,p) = \btrue,\]</span> and <span class="math inline">\(\chi : A \times A \times \lists{A} \times \bool \times \bool \rightarrow \lists{A}\)</span> by <span class="math display">\[\chi(a,b,y,p,q) = \bif{\beq(a,b)}{p}{q}.\]</span> We now define <span class="math inline">\(\sublist : \lists{A} \times \lists{A} \rightarrow \bool\)</span> by <span class="math display">\[\sublist(x,y) = \dfoldr{\isnil}{\psi}{\chi}(y,x).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">sublist ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">sublist x y <span class="fu">=</span> dfoldr delta psi chi y x</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    delta y <span class="fu">=</span> isNil y</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    psi _ _ <span class="fu">=</span> true</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    chi a b _ p q <span class="fu">=</span> <span class="kw">if</span> eq a b <span class="kw">then</span> p <span class="kw">else</span> q</a></code></pre></div>
</div>
<p>Since <span class="math inline">\(\sublist\)</span> is defined as a <span class="math inline">\(\dfoldr{\ast}{\ast}{\ast}\)</span>, it can be characterized as the unique solution to a system of functional equations.</p>
<div class="corollary">
<p>Let <span class="math inline">\(A\)</span> be a set. <span class="math inline">\(\sublist\)</span> is the unique map <span class="math inline">\(f : \lists{A} \times \lists{A} \rightarrow \bool\)</span> satisfying the following system of functional equations for all <span class="math inline">\(a,b \in A\)</span> and <span class="math inline">\(x,y \in \lists{A}\)</span>. <span class="math display">\[\left\{\begin{array}{l}
 f(x,\nil) = \isnil(x) \\
 f(\nil,\cons(b,y)) = \btrue \\
 f(\cons(a,x),\cons(b,y)) = \bif{\beq(a,b)}{\sublist(x,y)}{\sublist(\cons(a,x),y)}
\end{array}\right.\]</span></p>
<div class="test">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">_test_sublist_list_nil ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">_test_sublist_list_nil _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  testName <span class="st">&quot;sublist(x,nil) == isNil(x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (sublist x nil) (isNil x)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">_test_sublist_nil_cons ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">_test_sublist_nil_cons _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  testName <span class="st">&quot;sublist(nil,cons(b,y)) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  \b y <span class="ot">-&gt;</span> eq (sublist nil (cons b y)) true</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">_test_sublist_cons_cons ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">_test_sublist_cons_cons _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  testName <span class="st">&quot;sublist(cons(a,x),cons(b,y)) == if(eq(a,b),sublist(x,y),sublist(cons(a,x),y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  \a x b y <span class="ot">-&gt;</span> eq</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">    (sublist (cons a x) (cons b y))</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    (<span class="kw">if</span> eq a b <span class="kw">then</span> sublist x y <span class="kw">else</span> sublist (cons a x) y)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> is reflexive.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(x \in \lists{A}\)</span> we have <span class="math inline">\(\sublist(x,x)\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, certainly <span class="math display">\[\sublist(\nil,\nil) = \btrue.\]</span> For the inductive step, suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(a,x),\cons(a,x)) \\
 &amp; = &amp; \bif{\beq(a,a)}{\sublist(x,x)}{\sublist(\cons(a,x),x)} \\
 &amp; = &amp; \sublist(x,x) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">_test_sublist_reflexive ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">_test_sublist_reflexive _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  testName <span class="st">&quot;sublist(x,x) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  \x <span class="ot">-&gt;</span> eq (sublist x x) true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\snoc\)</span> is cancellative inside <span class="math inline">\(\sublist\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x,y \in \lists{A}\)</span>, we have the following.</p>
<ol type="1">
<li><span class="math inline">\(\sublist(nil,\snoc(b,y)) = \btrue\)</span>.</li>
<li><span class="math inline">\(\sublist(\snoc(a,x),\snoc(a,y)) = \sublist(x,y)\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>There are two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\nil,\snoc(b,\nil)) \\
 &amp; = &amp; \sublist(\nil,\cons(b,\nil)) \\
 &amp; = &amp; \btrue,
\end{eqnarray*}\]</span> and if <span class="math inline">\(y = \cons(c,u)\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\nil,\snoc(b,\cons(c,u))) \\
 &amp; = &amp; \sublist(\nil,\cons(c,\snoc(b,u))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as claimed.</li>
<li>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. We show that <span class="math inline">\(\sublist(\snoc(a,\nil),\snoc(a,y)) = \btrue\)</span> by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\sublist(\snoc(a,\nil),\snoc(a,\nil)) = \btrue\]</span> by reflexivity. For the inductive step (on <span class="math inline">\(y\)</span>), suppose the equality holds for some <span class="math inline">\(y\)</span> and let <span class="math inline">\(b \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,\nil),\snoc(a,\cons(b,y))) \\
 &amp; = &amp; \sublist(\cons(a,\nil),\cons(b,\snoc(a,y))) \\
 &amp; = &amp; \bif{\beq(a,b)}{\sublist(\nil,\snoc(a,y))}{\sublist(\cons(a,\nil),\snoc(a,y))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\btrue}{\sublist(\snoc(a,\nil),\snoc(a,y))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\btrue}{\btrue} \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step (on <span class="math inline">\(x\)</span>), suppose the equality holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(c \in A\)</span>. We need to show that <span class="math display">\[\sublist(\cons(c,x),y) = \sublist(\snoc(a,\cons(c,x)),\snoc(a,y))\]</span> for all <span class="math inline">\(y\)</span>; we again proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(c,x),y) \\
 &amp; = &amp; \sublist(\cons(c,x),\nil) \\
 &amp; = &amp; \isnil(\cons(c,x)) \\
 &amp; = &amp; \bfalse,
\end{eqnarray*}\]</span> and likewise <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,\cons(c,x)),\snoc(a,y)) \\
 &amp; = &amp; \sublist(\snoc(a,\cons(c,x)),\snoc(a,\nil)) \\
 &amp; = &amp; \sublist(\cons(c,\snoc(a,x)),\cons(a,\nil)) \\
 &amp; = &amp; \bif{\beq(c,a)}{\sublist(\snoc(a,x),\nil)}{\sublist(\cons(c,\snoc(a,x)),\nil)} \\
 &amp; = &amp; \bif{\beq(c,a)}{\bfalse}{\bfalse} \\
 &amp; = &amp; \bfalse
\end{eqnarray*}\]</span> as needed. For the inductive step (on <span class="math inline">\(y\)</span>), suppose we have <span class="math display">\[\sublist(\cons(c,x),y) = \sublist(\snoc(a,\cons(c,x)),\snoc(a,y))\]</span> for some <span class="math inline">\(y\)</span>, and let <span class="math inline">\(b \in A\)</span>. Using both the outer and nested inductive hypotheses we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,\cons(c,x)),\snoc(a,\cons(b,y))) \\
 &amp; = &amp; \sublist(\cons(c,\snoc(a,x)),\cons(b,\snoc(a,y))) \\
 &amp; = &amp; \bif{\beq(c,b)}{\sublist(\snoc(a,x),\snoc(a,y))}{\sublist(\cons(c,\snoc(a,x)),\snoc(a,y))} \\
 &amp; = &amp; \bif{\beq(c,b)}{\sublist(x,y)}{\sublist(\snoc(a,\cons(c,x)),\snoc(a,y))} \\
 &amp; = &amp; \bif{\beq(c,b)}{\sublist(x,y)}{\sublist(\cons(c,x),y)} \\
 &amp; = &amp; \sublist(\cons(c,x),\cons(b,y))
\end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">_test_sublist_nil_snoc ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">_test_sublist_nil_snoc _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  testName <span class="st">&quot;sublist(nil,snoc(b,y)) == true&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  \b y <span class="ot">-&gt;</span> eq (sublist nil (snoc b y)) true</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">_test_sublist_snoc_cancel ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">_test_sublist_snoc_cancel _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  testName <span class="st">&quot;sublist(snoc(a,x),snoc(a,y)) == sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  \a x y <span class="ot">-&gt;</span> eq (sublist (snoc a x) (snoc a y)) (sublist x y)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\cat\)</span> is cancellative inside <span class="math inline">\(\sublist\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(x,y,z \in \lists{A}\)</span> we have the following.</p>
<ol type="1">
<li><span class="math inline">\(\sublist(\cat(z,x),\cat(z,y)) = \sublist(x,y)\)</span>.</li>
<li><span class="math inline">\(\sublist(\cat(x,z),\cat(y,z)) = \sublist(x,y)\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>We proceed by list induction on <span class="math inline">\(z\)</span>. For the base case <span class="math inline">\(z = \nil\)</span>, of course <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cat(\nil,x),\cat(\nil,y)) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> for some <span class="math inline">\(z\)</span>, and let <span class="math inline">\(a \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cat(\cons(a,z),x),\cat(\cons(a,z),y)) \\
 &amp; = &amp; \sublist(\cons(a,\cat(z,x)),\cons(a,\cat(z,y))) \\
 &amp; = &amp; \bif{\beq(a,a)}{\sublist(x,y)}{\sublist(\cons(a,x),y)} \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed.</li>
<li>We proceed by snoc induction on <span class="math inline">\(z\)</span>. For the base case <span class="math inline">\(z = \nil\)</span>, of course <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cat(x,\nil),\cat(y,\nil)) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> for some <span class="math inline">\(z\)</span>, and let <span class="math inline">\(a \in A\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cat(x,\snoc(a,z)),\cat(y,\snoc(a,z))) \\
 &amp; = &amp; \sublist(\snoc(a,\cat(x,z)),\snoc(a,\cat(y,z))) \\
 &amp; = &amp; \sublist(\cat(x,z),\cat(y,z)) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">_test_sublist_cat_left_cancel ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">_test_sublist_cat_left_cancel _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  testName <span class="st">&quot;sublist(cat(z,x),cat(z,y)) == sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  \x y z <span class="ot">-&gt;</span> eq (sublist (cat z x) (cat z y)) (sublist x y)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">_test_sublist_cat_right_cancel ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">_test_sublist_cat_right_cancel _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  testName <span class="st">&quot;sublist(cat(x,z),cat(y,z)) == sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  \x y z <span class="ot">-&gt;</span> eq (sublist (cat x z) (cat y z)) (sublist x y)</a></code></pre></div>
</div>
</div>
<p>Sublist conditionally interacts with <span class="math inline">\(\cons\)</span>. This one seems like it should be obvious, but the only proof I could find was kind of complicated – nested induction of two statements at once.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(a,b \in A\)</span> and <span class="math inline">\(x,y \in \lists{A}\)</span>. Then we have the following.</p>
<ol type="1">
<li>If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,\cons(b,y)) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\sublist(\cons(a,x),y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,y) = \btrue\)</span>.</li>
</ol>
<div class="proof">
<p>This proof is a little different: we will prove both (1) and (2) simultaneously by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, to see (1), note that for all <span class="math inline">\(b \in A\)</span> and <span class="math inline">\(y \in \lists{A}\)</span> we have <span class="math display">\[\sublist(\nil,y) = \btrue = \sublist(\nil,\cons(b,y))\]</span> as needed. To see (2), note that <span class="math inline">\(\sublist(\nil,y)\)</span>, so the implication holds regardless of the values of <span class="math inline">\(a\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>For the inductive step, suppose both (1) and (2) hold for all <span class="math inline">\(a,b \in A\)</span> and <span class="math inline">\(y \in \lists{A}\)</span> for some <span class="math inline">\(x \in \lists{A}\)</span>, and let <span class="math inline">\(c \in A\)</span>.</p>
<p>Now we claim that (1) holds with <span class="math inline">\(x\)</span> replaced by <span class="math inline">\(\cons(c,x)\)</span>; that is, for all <span class="math inline">\(b \in A\)</span> and <span class="math inline">\(y \in \lists{A}\)</span>, if <span class="math inline">\(\sublist(\cons(c,x),y) = \btrue\)</span> then <span class="math inline">\(\sublist(\cons(c,x),\cons(b,y)) = \btrue\)</span>. To this end, suppose we have <span class="math inline">\(\sublist(\cons(c,x),y) = \btrue\)</span>. Using part (2) of the induction hypothesis, we have <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(c,x),\cons(b,y)) \\
 &amp; = &amp; \bif{\beq(c,b)}{\sublist(x,y)}{\sublist(\cons(c,x),y)} \\
 &amp; = &amp; \bif{\beq(c,b)}{\btrue}{\btrue} \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
<p>Next we claim that (2) holds with <span class="math inline">\(x\)</span> replaced by <span class="math inline">\(\cons(c,x)\)</span>. That is, for all <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(y \in \lists{A}\)</span>, if <span class="math inline">\(\sublist(\cons(a,\cons(c,x)),y) = \btrue\)</span> then <span class="math inline">\(\sublist(\cons(c,x),y) = \btrue\)</span>. We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(a,\cons(c,x)),y) \\
 &amp; = &amp; \sublist(\cons(a,\cons(c,x)),\nil) \\
 &amp; = &amp; \isnil(\cons(a,\cons(c,x))) \\
 &amp; = &amp; \bfalse;
\end{eqnarray*}\]</span> thus the implication (2) holds vacuously.</p>
<p>For the inductive step, suppose we have <span class="math inline">\(y \in \lists{A}\)</span> such that, for all <span class="math inline">\(a \in A\)</span>, if <span class="math inline">\(\sublist(\cons(a,\cons(c,x)),y) = \btrue\)</span> then <span class="math inline">\(\sublist(\cons(c,x),y) = \btrue\)</span>. Let <span class="math inline">\(d \in A\)</span>, and suppose <span class="math display">\[\sublist(\cons(a,\cons(c,x)),\cons(d,y)) = \btrue.\]</span></p>
<p>We consider two possibilities. If <span class="math inline">\(a \neq d\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(a,\cons(c,x)),\cons(d,y)) \\
 &amp; = &amp; \sublist(\cons(a,\cons(c,x)),y).
\end{eqnarray*}\]</span> By the (nested) induction hypothesis, we have <span class="math display">\[\sublist(\cons(c,x),y) = \btrue.\]</span> We established above that this implies <span class="math display">\[\sublist(\cons(c,x),\cons(d,y)) = \btrue\]</span> as needed. Now suppose instead that <span class="math inline">\(a = d\)</span>. Then <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(a,\cons(c,x)),\cons(d,y)) \\
 &amp; = &amp; \sublist(\cons(c,x),y).
\end{eqnarray*}\]</span> By part (2) of the (outer) induction hypothesis, we have <span class="math display">\[\sublist(x,y) = \btrue.\]</span> Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(c,x),\cons(d,y)) \\
 &amp; = &amp; \bif{\beq(c,d)}{\sublist(x,y)}{\sublist(\cons(c,x),y)} \\
 &amp; = &amp; \bif{\beq(c,d)}{\btrue}{\btrue} \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">_test_sublist_cons_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">_test_sublist_cons_right _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  testName <span class="st">&quot;sublist(x,y) ==&gt; sublist(x,cons(a,y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  \a x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="kw">then</span> sublist x (cons a y)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">_test_sublist_cons_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">_test_sublist_cons_left _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  testName <span class="st">&quot;sublist(cons(a,x),y) ==&gt; sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  \a x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist (cons a x) y</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">    <span class="kw">then</span> sublist x y</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts with <span class="math inline">\(\length\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, with <span class="math inline">\(x,y \in \lists{A}\)</span>. If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\nleq(\length(x),\length(y))\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, note that <span class="math inline">\(\length(y) = \zero\)</span>. Now if <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,y) \\
 &amp; = &amp; \sublist(x,\nil) \\
 &amp; = &amp; \isnil(x),
\end{eqnarray*}\]</span> we have <span class="math inline">\(x = \nil\)</span>, so that <span class="math inline">\(\length(x) = \zero\)</span>. Thus <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nleq(\length(x),\length(y)) \\
 &amp; = &amp; \nleq(\zero,\zero) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span>, and let <span class="math inline">\(b \in A\)</span>. We consider two cases for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\nil,\cons(b,y)) \\
 &amp; = &amp; \btrue,
\end{eqnarray*}\]</span> and furthermore <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nleq(\length(x),\length(\cons(b,y))) \\
 &amp; = &amp; \nleq(\length(\nil),\length(\cons(b,y))) \\
 &amp; = &amp; \nleq(\zero,\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed. Suppose then that <span class="math inline">\(x = \cons(a,u)\)</span>, and suppose further that <span class="math inline">\(\sublist(x,\cons(b,y)) = \btrue\)</span>. We have two possibilities. If <span class="math inline">\(a = b\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,y)) \\
 &amp; = &amp; \sublist(u,y).
\end{eqnarray*}\]</span> By the induction hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \nleq(\length(u),\length(y)) \\
 &amp; = &amp; \nleq(\next(\length(u)),\next(\length(y))) \\
 &amp; = &amp; \nleq(\length(\cons(a,u)),\length(\cons(b,y))) \\
 &amp; = &amp; \nleq(\length(x),\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(a \neq b\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),y).
\end{eqnarray*}\]</span> By the induction hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \nleq(\length(\cons(a,u)),\length(y)) \\
 &amp; = &amp; \nleq(\length(x),\length(y)) \\
 &amp; = &amp; \nleq(\length(x),\next(\length(y))) \\
 &amp; = &amp; \nleq(\length(x),\length(\cons(b,y)))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">_test_sublist_length ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a), <span class="dt">Natural</span> n)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">_test_sublist_length _ k <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  testName <span class="st">&quot;if sublist(x,y) then leq(length(x),length(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="kw">then</span> leq ((length x) <span class="ot">`withTypeOf`</span> k) (length y)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> is antisymmetric.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, and <span class="math inline">\(x,y \in \lists{A}\)</span>. We have <span class="math inline">\(\sublist(x,y)\)</span> and <span class="math inline">\(\sublist(y,x)\)</span> if and only if <span class="math inline">\(x = y\)</span>.</p>
<div class="proof">
<p>The “if” direction is trivial. To see the “only if” direction we proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(y,x) \\
 &amp; = &amp; \sublist(y,\nil) \\
 &amp; = &amp; \isnil(y),
\end{eqnarray*}\]</span> so that <span class="math inline">\(y = \nil = x\)</span> as claimed. For the inductive step, suppose the implication holds for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. We now consider two possibilities for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\cons(a,x),y) \\
 &amp; = &amp; \sublist(\cons(a,x),\nil) \\
 &amp; = &amp; \isnil(\cons(a,x)) \\
 &amp; = &amp; \bfalse.
\end{eqnarray*}\]</span> Thus the implication holds vacuously. Suppose instead that <span class="math inline">\(y = \cons(b,v)\)</span>, and suppose further that <span class="math inline">\(\sublist(\cons(a,x),\cons(b,v))\)</span> and <span class="math inline">\(\sublist(\cons(b,v),\cons(a,x))\)</span> are both <span class="math inline">\(\btrue\)</span>. If <span class="math inline">\(a \neq b\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(b,v),\cons(a,x)) \\
 &amp; = &amp; \sublist(\cons(b,v),x) \\
 &amp; = &amp; \sublist(y,x).
\end{eqnarray*}\]</span> But now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \nleq(\length(\cons(a,x)),\length(y)) \\
 &amp; = &amp; \nleq(\next(\length(x)),\length(y))
\end{eqnarray*}\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \nleq(\length(y),\length(x));
\end{eqnarray*}\]</span> by transitivity, we thus also have <span class="math display">\[\nleq(\next(\length(x)),\length(x)),\]</span> a contradiction. So in fact <span class="math inline">\(a = b\)</span>. Thus we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(b,v),\cons(a,x)) \\
 &amp; = &amp; \sublist(v,x)
\end{eqnarray*}\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(a,x),\cons(b,v)) \\
 &amp; = &amp; \sublist(x,v),
\end{eqnarray*}\]</span> so that (by the induction hypothesis) we have <span class="math inline">\(x = v\)</span>, and so <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \cons(a,x) \\
 &amp; = &amp; \cons(b,v) \\
 &amp; = &amp; y
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">_test_sublist_antisymmetric ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">_test_sublist_antisymmetric _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  testName <span class="st">&quot;and(sublist(x,y),sublist(y,x)) == eq(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> eq (and (sublist x y) (sublist y x)) (eq x y)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> is transitive.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, with <span class="math inline">\(x,y,z \in \lists{A}\)</span>. If <span class="math inline">\(\sublist(x,y)\)</span> and <span class="math inline">\(\sublist(y,z)\)</span>, then <span class="math inline">\(\sublist(x,z)\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(z\)</span>. For the base case <span class="math inline">\(z = \nil\)</span>, note that if <span class="math inline">\(\sublist(y,z) = \btrue\)</span> we have <span class="math inline">\(y = \nil\)</span>, and then if <span class="math inline">\(\sublist(x,y) = \btrue\)</span> we also have <span class="math inline">\(x = \nil\)</span>. In particular, <span class="math inline">\(\sublist(x,z) = \btrue\)</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> for some <span class="math inline">\(z\)</span>, and let <span class="math inline">\(c \in A\)</span>. Suppose further that <span class="math inline">\(\sublist(x,y)\)</span> and <span class="math inline">\(\sublist(y,\cons(c,z))\)</span>. We consider two cases for <span class="math inline">\(y\)</span>. If <span class="math inline">\(y = \nil\)</span>, note that <span class="math inline">\(x = \nil\)</span>, so we have <span class="math inline">\(\sublist(x,\cons(c,z))\)</span> as claimed. Suppose instead that <span class="math inline">\(y = \cons(b,v)\)</span>. If <span class="math inline">\(b \neq c\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(b,v),\cons(c,z)) \\
 &amp; = &amp; \sublist(\cons(b,v),z);
\end{eqnarray*}\]</span> by the inductive hypothesis, we have <span class="math inline">\(\sublist(x,z)\)</span>, so that <span class="math inline">\(\sublist(x,\cons(c,z))\)</span> as claimed. Suppose instead that <span class="math inline">\(b = c\)</span>; then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(b,v),\cons(c,z)) \\
 &amp; = &amp; \sublist(v,z).
\end{eqnarray*}\]</span> We consider two cases for <span class="math inline">\(x\)</span>; if <span class="math inline">\(x = \nil\)</span>, then <span class="math inline">\(\sublist(x,\cons(c,z))\)</span> as claimed. Suppose instead that <span class="math inline">\(x = \cons(a,u)\)</span>. If <span class="math inline">\(a \neq b\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,v)) \\
 &amp; = &amp; \sublist(\cons(a,u),v),
\end{eqnarray*}\]</span> and by the inductive hypothesis, <span class="math inline">\(\sublist(x,z)\)</span>, so that <span class="math inline">\(\sublist(x,\cons(c,z))\)</span> as claimed. If <span class="math inline">\(a = b\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,v)) \\
 &amp; = &amp; \sublist(u,v).
\end{eqnarray*}\]</span> By the inductive hypothesis, <span class="math inline">\(\sublist(u,z)\)</span>, so that <span class="math inline">\(\sublist(x,\cons(c,z))\)</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">_test_sublist_transitive ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">_test_sublist_transitive _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  testName <span class="st">&quot;if and(sublist(x,y),sublist(y,z)) then sublist(x,z)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  \x y z <span class="ot">-&gt;</span> <span class="kw">if</span> and (sublist x y) (sublist y z)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="kw">then</span> sublist x z</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> is compatible with <span class="math inline">\(\cat\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. The following hold for all <span class="math inline">\(x,y,u,v \in \lists{A}\)</span>. If <span class="math inline">\(\sublist(x,u)\)</span> and <span class="math inline">\(\sublist(y,v)\)</span>, then <span class="math inline">\(\sublist(\cat(x,y),\cat(u,v))\)</span>.</p>
<div class="proof">
<p>If <span class="math inline">\(\sublist(x,u) = \btrue\)</span>, then <span class="math inline">\(\sublist(\cat(x,y),\cat(u,y)) = \btrue\)</span>. Similarly, if <span class="math inline">\(\sublist(y,v) = \btrue\)</span>, then <span class="math inline">\(\sublist(\cat(u,y),\cat(u,v)) = \btrue\)</span>. By transitivity, we have <span class="math display">\[\sublist(\cat(x,y),cat(u,v)) = \btrue\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_test_sublist_cat_compatible ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">_test_sublist_cat_compatible _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  testName <span class="st">&quot;if and(sublist(x,y),sublist(u,v)) then sublist(cat(x,u),cat(y,v))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  \x y u v <span class="ot">-&gt;</span> <span class="kw">if</span> and (sublist x y) (sublist u v)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="kw">then</span> sublist (cat x u) (cat y v)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts with <span class="math inline">\(\snoc\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(a,b \in A\)</span> and <span class="math inline">\(x,y \in \lists{A}\)</span> we have <span class="math display">\[\sublist(\snoc(a,x),\snoc(b,y)) = \bif{\beq(a,b)}{\sublist(x,y)}{\sublist(\snoc(a,x),y)}.\]</span></p>
<div class="proof">
<p>We’ve already seen that <span class="math display">\[\sublist(\snoc(a,x),\snoc(a,y)) = \sublist(x,y).\]</span> So it suffices to show that if <span class="math inline">\(a \neq b\)</span> we have <span class="math display">\[\sublist(\snoc(a,x),\snoc(b,y)) = \sublist(\snoc(a,x),y).\]</span> We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,x),y) \\
 &amp; = &amp; \sublist(\snoc(a,x),\nil) \\
 &amp; = &amp; \isnil(\snoc(a,x)) \\
 &amp; = &amp; \bfalse.
\end{eqnarray*}\]</span> We will now show that <span class="math inline">\(\sublist(\snoc(a,x),\snoc(b,\nil)) = \bfalse\)</span> by considering two cases for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,x),\snoc(b,\nil)) \\
 &amp; = &amp; \sublist(\snoc(a,\nil),\snoc(b,\nil)) \\
 &amp; = &amp; \sublist(\cons(a,\nil),\cons(b,\nil)) \\
 &amp; = &amp; \sublist(\cons(a,\nil),\nil) \\
 &amp; = &amp; \isnil(\cons(a,\nil)) \\
 &amp; = &amp; \bfalse
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(x = \cons(c,u)\)</span> and <span class="math inline">\(\sublist(\snoc(a,x),\snoc(b,\nil)) = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \nleq(\length(\snoc(a,x)),\length(\snoc(b,\nil))) \\
 &amp; = &amp; \nleq(\next(\length(x)),\next(\length(\nil))) \\
 &amp; = &amp; \nleq(\next(\length(\cons(c,u))),\next(\zero)) \\
 &amp; = &amp; \nleq(\next(\next(\length(u))),\next(\zero)) \\
 &amp; = &amp; \bfalse,
\end{eqnarray*}\]</span> a contradiction.</p>
<p>Now for the inductive step, suppose the equality holds for some <span class="math inline">\(y\)</span>. That is, for all <span class="math inline">\(a \neq b\)</span> and all <span class="math inline">\(x\)</span> we have <span class="math display">\[\sublist(\snoc(a,x),\snoc(b,y)) = \sublist(\snoc(a,x),y).\]</span> Let <span class="math inline">\(d \in A\)</span>. We consider two possibilities for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,x),\snoc(b,\cons(d,y))) \\
 &amp; = &amp; \sublist(\snoc(a,\nil),\snoc(b,\cons(d,y))) \\
 &amp; = &amp; \sublist(\cons(a,\nil),\cons(d,\snoc(b,y))) \\
 &amp; = &amp; \bif{\beq(a,d)}{\sublist(\nil,\snoc(b,y))}{\sublist(\cons(a,\nil),\snoc(b,y))} \\
 &amp; = &amp; \bif{\beq(a,d)}{\btrue}{\sublist(\snoc(a,\nil),\snoc(b,y))} \\
 &amp; = &amp; \bif{\beq(a,d)}{\btrue}{\sublist(\snoc(a,\nil),y)} \\
 &amp; = &amp; \bif{\beq(a,d)}{\sublist(\nil,y)}{\sublist(\cons(a,\nil),y)} \\
 &amp; = &amp; \sublist(\cons(a,\nil),\cons(d,y)) \\
 &amp; = &amp; \sublist(\snoc(a,\nil),\cons(d,y))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(x = \cons(c,u)\)</span>. Now we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\snoc(a,x),\snoc(b,\cons(d,y))) \\
 &amp; = &amp; \sublist(\snoc(a,\cons(c,u)),\snoc(b,\cons(d,y))) \\
 &amp; = &amp; \sublist(\cons(c,\snoc(a,u)),\cons(d,\snoc(b,y))) \\
 &amp; = &amp; \bif{\beq(c,d)}{\sublist(\snoc(a,u),\snoc(b,y))}{\sublist(\cons(c,\snoc(a,u)),\snoc(b,y))} \\
 &amp; = &amp; \bif{\beq(c,d)}{\sublist(\snoc(a,u),y)}{\sublist(\snoc(a,\cons(c,u)),\snoc(b,y))} \\
 &amp; = &amp; \bif{\beq(c,d)}{\sublist(\snoc(a,u),y)}{\sublist(\snoc(a,\cons(c,u)),y)} \\
 &amp; = &amp; \bif{\beq(c,d)}{\sublist(\snoc(a,u),y)}{\sublist(\cons(c,\snoc(a,u)),y)} \\
 &amp; = &amp; \sublist(\cons(c,\snoc(a,u)),\cons(d,y)) \\
 &amp; = &amp; \sublist(\snoc(a,\cons(c,u)),\cons(d,y)) \\
 &amp; = &amp; \sublist(\snoc(a,x),\cons(d,y))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">_test_sublist_snoc_snoc ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">_test_sublist_snoc_snoc _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  testName <span class="st">&quot;sublist(snoc(a,x),snoc(b,y)) == if(eq(a,b),sublist(x,y),sublist(snoc(a,x),y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  \a b x y <span class="ot">-&gt;</span> eq</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    (sublist (snoc a x) (snoc b y))</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    (<span class="kw">if</span> eq a b <span class="kw">then</span> sublist x y <span class="kw">else</span> sublist (snoc a x) y)</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts with <span class="math inline">\(\rev\)</span>:</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set. For all <span class="math inline">\(x,y \in \lists{A}\)</span> we have <span class="math display">\[\sublist(x,y) = \sublist(\rev(x),\rev(y)).\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(x,y) \\
 &amp; = &amp; \sublist(x,\nil) \\
 &amp; = &amp; \isnil(x) \\
 &amp; = &amp; \isnil(\rev(x)) \\
 &amp; = &amp; \sublist(\rev(x),\nil) \\
 &amp; = &amp; \sublist(\rev(x),\rev(\nil)) \\
 &amp; = &amp; \sublist(\rev(x),\rev(y))
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span> and let <span class="math inline">\(b \in A\)</span>. We consider two possibilities for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\nil,\cons(b,y)) \\
 &amp; = &amp; \btrue \\
 &amp; = &amp; \sublist(\nil,\rev(\cons(b,y))) \\
 &amp; = &amp; \sublist(\rev(\nil),\rev(\cons(b,y))) \\
 &amp; = &amp; \sublist(\rev(x),\rev(\cons(b,y)))
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(x = \cons(a,w)\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp; = &amp; \sublist(\rev(x),\rev(\cons(b,y))) \\
 &amp; = &amp; \sublist(\rev(\cons(a,w)),\rev(\cons(b,y))) \\
 &amp; = &amp; \sublist(\snoc(a,\rev(w)),\snoc(b,\rev(y))) \\
 &amp; = &amp; \bif{\beq(a,b)}{\sublist(\rev(w),\rev(y))}{\sublist(\snoc(a,\rev(w)),\rev(y))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\sublist(w,y)}{\sublist(\rev(\cons(a,w)),\rev(y))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\sublist(w,y)}{\sublist(\cons(a,w),y)} \\
 &amp; = &amp; \sublist(\cons(a,w),\cons(b,y)) \\
 &amp; = &amp; \sublist(x,\cons(b,y))
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_test_sublist_rev ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">_test_sublist_rev _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  testName <span class="st">&quot;sublist(x,y) == sublist(rev(x),rev(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  \x y <span class="ot">-&gt;</span> eq (sublist x y) (sublist (rev x) (rev y))</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts conditionally with <span class="math inline">\(\snoc\)</span> in one argument.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(x,y \in \lists{A}\)</span>. Then we have the following.</p>
<ol type="1">
<li>If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,\snoc(a,y)) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\sublist(\snoc(a,x),y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,y) = \btrue\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>Suppose <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,y) \\
 &amp; = &amp; \sublist(\rev(x),\rev(y)) \\
 &amp; = &amp; \sublist(\rev(x),\cons(a,\rev(y))) \\
 &amp; = &amp; \sublist(\rev(x),\rev(\snoc(a,y))) \\
 &amp; = &amp; \sublist(x,\snoc(a,y))
\end{eqnarray*}\]</span> as claimed.</li>
<li>Suppose <span class="math inline">\(\sublist(\snoc(a,x),y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\snoc(a,x),y) \\
 &amp; = &amp; \sublist(\rev(\snoc(a,x)),\rev(y)) \\
 &amp; = &amp; \sublist(\cons(a,\rev(x)),\rev(y)) \\
 &amp; = &amp; \sublist(\rev(x),\rev(y)) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">_test_sublist_snoc_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">_test_sublist_snoc_right _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  testName <span class="st">&quot;sublist(x,y) ==&gt; sublist(x,snoc(a,y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  \a x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="kw">then</span> sublist x (snoc a y)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="ot">_test_sublist_snoc_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">_test_sublist_snoc_left _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">  testName <span class="st">&quot;sublist(snoc(a,x),y) ==&gt; sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">  \a x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist (snoc a x) y</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">    <span class="kw">then</span> sublist x y</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts conditionally with <span class="math inline">\(\cat\)</span> in one argument.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, with <span class="math inline">\(x,y,z \in \lists{A}\)</span>.</p>
<ol type="1">
<li>If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,\cat(z,y)) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,\cat(y,z)) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\sublist(\cat(z,x),y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,y) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\sublist(\cat(x,z),y) = \btrue\)</span>, then <span class="math inline">\(\sublist(x,y) = \btrue\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>We proceed by list induction on <span class="math inline">\(z\)</span>. For the base case <span class="math inline">\(z = \nil\)</span>, suppose <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Then <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(x,\cat(z,y)) \\
 &amp; = &amp; \sublist(x,\cat(\nil,y)) \\
 &amp; = &amp; \sublist(x,y) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for some <span class="math inline">\(z\)</span> and let <span class="math inline">\(a \in A\)</span>. Suppose further that <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,y) \\
 &amp; = &amp; \sublist(x,\cat(z,y)) \\
 &amp; = &amp; \sublist(x,\cons(a,\cat(z,y))) \\
 &amp; = &amp; \sublist(x,\cat(\cons(a,z),y))
\end{eqnarray*}\]</span> as needed.</li>
<li>Suppose <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,y) \\
 &amp; = &amp; \sublist(\rev(x),\rev(y)) \\
 &amp; = &amp; \sublist(\rev(x),\cat(\rev(z),\rev(y))) \\
 &amp; = &amp; \sublist(\rev(x),\rev(\cat(y,z))) \\
 &amp; = &amp; \sublist(x,\cat(y,z))
\end{eqnarray*}\]</span> as claimed.</li>
<li>We proceed by list induction on <span class="math inline">\(z\)</span>. For the base case <span class="math inline">\(z = \nil\)</span>, suppose <span class="math inline">\(\sublist(\cat(z,x),y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cat(z,x),y) \\
 &amp; = &amp; \sublist(\cat(\nil,x),y) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> for some <span class="math inline">\(z\)</span> and let <span class="math inline">\(a \in A\)</span>. Suppose further that <span class="math inline">\(\sublist(\cat(\cons(a,z),x),y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cat(\cons(a,z),x),y) \\
 &amp; = &amp; \sublist(\cons(a,\cat(z,x)),y) \\
 &amp; = &amp; \sublist(\cat(z,x),y) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed.</li>
<li>Suppose <span class="math inline">\(\sublist(\cat(x,z),y) = \btrue\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(\cat(x,z),y) \\
 &amp; = &amp; \sublist(\rev(\cat(x,z)),\rev(y)) \\
 &amp; = &amp; \sublist(\cat(\rev(z),\rev(x)),\rev(y)) \\
 &amp; = &amp; \sublist(\rev(x),\rev(y)) \\
 &amp; = &amp; \sublist(x,y)
\end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">_test_sublist_left_cat_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">_test_sublist_left_cat_right _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  testName <span class="st">&quot;if sublist(x,y) then sublist(x,cat(z,y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  \x y z <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="kw">then</span> sublist x (cat z y)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="ot">_test_sublist_right_cat_right ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">_test_sublist_right_cat_right _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  testName <span class="st">&quot;if sublist(x,y) then sublist(x,cat(y,z))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">  \x y z <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">    <span class="kw">then</span> sublist x (cat y z)</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb15-17" data-line-number="17"></a>
<a class="sourceLine" id="cb15-18" data-line-number="18"></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="ot">_test_sublist_left_cat_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">_test_sublist_left_cat_left _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-22" data-line-number="22">  testName <span class="st">&quot;if sublist(cat(z,x),y) then sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-23" data-line-number="23">  \x y z <span class="ot">-&gt;</span> <span class="kw">if</span> sublist (cat z x) y</a>
<a class="sourceLine" id="cb15-24" data-line-number="24">    <span class="kw">then</span> sublist x y</a>
<a class="sourceLine" id="cb15-25" data-line-number="25">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb15-26" data-line-number="26"></a>
<a class="sourceLine" id="cb15-27" data-line-number="27"></a>
<a class="sourceLine" id="cb15-28" data-line-number="28"><span class="ot">_test_sublist_right_cat_left ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb15-29" data-line-number="29">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> (t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb15-30" data-line-number="30">_test_sublist_right_cat_left _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-31" data-line-number="31">  testName <span class="st">&quot;if sublist(cat(x,z),y) then sublist(x,y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-32" data-line-number="32">  \x y z <span class="ot">-&gt;</span> <span class="kw">if</span> sublist (cat x z) y</a>
<a class="sourceLine" id="cb15-33" data-line-number="33">    <span class="kw">then</span> sublist x y</a>
<a class="sourceLine" id="cb15-34" data-line-number="34">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts with <span class="math inline">\(\map\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets with <span class="math inline">\(x,y \in \lists{A}\)</span> and <span class="math inline">\(f : A \rightarrow B\)</span> injective. If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then <span class="math inline">\(\sublist(\map(f)(x),\map(f)(y)) = \btrue\)</span>.</p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, suppose <span class="math inline">\(\sublist(x,y) = \btrue\)</span>. Then in fact <span class="math inline">\(x = \nil\)</span>. In this case we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\map(f)(x),\map(f)(y)) \\
 &amp; = &amp; \sublist(\map(f)(\nil),\map(f)(\nil)) \\
 &amp; = &amp; \sublist(\nil,\nil) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the implication holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span> and let <span class="math inline">\(b \in A\)</span>. Suppose further that <span class="math inline">\(\sublist(x,\cons(a,y)) = \btrue\)</span>. We have two possibilities for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\map(f)(x),\map(f)(\cons(a,y))) \\
 &amp; = &amp; \sublist(\map(f)(\nil),\map(f)(\cons(a,y))) \\
 &amp; = &amp; \sublist(\nil,\map(f)(\cons(a,y))) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. Suppose instead that <span class="math inline">\(x = \cons(a,u)\)</span>. Note that if <span class="math inline">\(f(a) = f(b)\)</span> then <span class="math inline">\(a = b\)</span> (since <span class="math inline">\(f\)</span> is injective) and we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,y)) \\
 &amp; = &amp; \sublist(u,y),
\end{eqnarray*}\]</span> and if <span class="math inline">\(f(a) \neq f(b)\)</span>, then <span class="math inline">\(a \neq b\)</span> (since <span class="math inline">\(f\)</span> is injective), and we have <span class="math display">\[\begin{eqnarray*}
 &amp; = &amp; \btrue \\
 &amp; = &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),y) \\
 &amp; = &amp; \sublist(x,y).
\end{eqnarray*}\]</span> In either case, using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\map(f)(x),\map(f)(\cons(b,y))) \\
 &amp; = &amp; \sublist(\map(f)(\cons(a,u)),\map(f)(\cons(b,y))) \\
 &amp; = &amp; \sublist(\cons(f(a),\map(f)(u)),\cons(f(b),\map(f)(y))) \\
 &amp; = &amp; \bif{\beq(f(a),f(b))}{\sublist(\map(f)(u),\map(f)(y))}{\sublist(\cons(f(a),\map(f)(u)),\map(f)(y))} \\
 &amp; = &amp; \bif{\beq(f(a),f(b))}{\sublist(\map(f)(u),\map(f)(y))}{\sublist(\map(f)(\cons(a,u)),\map(f)(y))} \\
 &amp; = &amp; \bif{\beq(f(a),f(b))}{\sublist(\map(f)(u),\map(f)(y))}{\sublist(\map(f)(x),\map(f)(y))} \\
 &amp; = &amp; \bif{\beq(f(a),f(b))}{\btrue}{\btrue} \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_test_sublist_map ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">_test_sublist_map _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  testName <span class="st">&quot;if sublist(x,y) then sublist(map(f)(x),map(f)(y))&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  \f x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y <span class="kw">then</span> sublist (map f x) (map f y) <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts with <span class="math inline">\(\filter\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, let <span class="math inline">\(p : A \rightarrow \bool\)</span>, and let <span class="math inline">\(x \in \lists{A}\)</span>. Then we have <span class="math display">\[\sublist(\filter(p,x),x) = \btrue.\]</span></p>
<div class="proof">
<p>We proceed by list induction on <span class="math inline">\(x\)</span>. For the base case <span class="math inline">\(x = \nil\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\filter(p,x),x) \\
 &amp; = &amp; \sublist(\filter(p,\nil),\nil) \\
 &amp; = &amp; \sublist(\nil,\nil) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. For the inductive step, suppose the equality holds for all <span class="math inline">\(p\)</span> for some <span class="math inline">\(x\)</span> and let <span class="math inline">\(a \in A\)</span>. We consider two possibilities. If <span class="math inline">\(p(a) = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\filter(p,\cons(a,x)),\cons(a,x)) \\
 &amp; = &amp; \sublist(\bif{p(a)}{\cons(a,\filter(p,x))}{\filter(p,x)},\cons(a,x)) \\
 &amp; = &amp; \sublist(\cons(a,\filter(p,x)),\cons(a,x)) \\
 &amp; = &amp; \sublist(\filter(p,x),x) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(p(a) = \bfalse\)</span>, note that <span class="math display">\[\sublist(\filter(p,x),x) = \btrue,\]</span> so that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sublist(\filter(p,\cons(a,x)),\cons(a,x)) \\
 &amp; = &amp; \sublist(\bif{p(a)}{\cons(a,\filter(p,x))}{\filter(p,x)},\cons(a,x)) \\
 &amp; = &amp; \sublist(\filter(p,x),\cons(a,x)) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">_test_sublist_filter ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">_test_sublist_filter _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  testName <span class="st">&quot;sublist(filter(p)(x),x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  \p x <span class="ot">-&gt;</span> sublist (filter p x) x</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> interacts conditionally with <span class="math inline">\(\any\)</span> and <span class="math inline">\(\all\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set, let <span class="math inline">\(x,y \in \lists{A}\)</span>, and let <span class="math inline">\(p : A \rightarrow \bool\)</span>. If <span class="math inline">\(\sublist(x,y) = \btrue\)</span>, then we have the following.</p>
<ol type="1">
<li>If <span class="math inline">\(\all(p,y) = \btrue\)</span> then <span class="math inline">\(\all(p,x) = \btrue\)</span>.</li>
<li>If <span class="math inline">\(\any(p,x) = \btrue\)</span> then <span class="math inline">\(\any(p,y) = \btrue\)</span>.</li>
</ol>
<div class="proof">
<ol type="1">
<li>We proceed by list induction on <span class="math inline">\(y\)</span>. For the base case <span class="math inline">\(y = \nil\)</span>, since <span class="math inline">\(\sublist(x,y) = \btrue\)</span> we have <span class="math inline">\(x = \nil\)</span>. Now <span class="math display">\[\all(p,y) = \all(p,\nil) = \btrue\]</span> and <span class="math display">\[\all(p,x) = \all(p,\nil) = \btrue\]</span> as needed. For the inductive step, suppose the result holds for all <span class="math inline">\(x\)</span> for some <span class="math inline">\(y\)</span>, and let <span class="math inline">\(b \in A\)</span>. Suppose <span class="math inline">\(\sublist(x,\cons(b,y)) = \btrue\)</span>, and further suppose that <span class="math inline">\(\all(p,\cons(b,y)) = \btrue\)</span>. In particular, note that <span class="math inline">\(p(b) = \btrue\)</span>. We consider two possibilities for <span class="math inline">\(x\)</span>. If <span class="math inline">\(x = \nil\)</span>, note that <span class="math display">\[\all(p,x) = \all(p,\nil) = \btrue,\]</span> so the implication holds regardless of <span class="math inline">\(y\)</span>. Suppose instead that <span class="math inline">\(x = \cons(a,u)\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \sublist(x,\cons(b,y)) \\
 &amp; = &amp; \sublist(\cons(a,u),\cons(b,y)) \\
 &amp; = &amp; \bif{\beq(a,b)}{\sublist(u,y)}{\sublist(\cons(a,u),y)} \\
 &amp; = &amp; \bif{\beq(a,b)}{\all(p,u)}{\all(p,\cons(a,u))} \\
 &amp; = &amp; \bif{\beq(a,b)}{\all(p,\cons(a,u))}{\all(p,\cons(a,u))} \\
 &amp; = &amp; \all(p,\cons(a,u)) \\
 &amp; = &amp; \all(p,x)
\end{eqnarray*}\]</span> as needed.</li>
<li>We prove this implication by contraposition. Suppose <span class="math inline">\(\any(p,y) = \bfalse\)</span>; then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \btrue \\
 &amp; = &amp; \bnot(\bfalse) \\
 &amp; = &amp; \bnot(\any(p,y)) \\
 &amp; = &amp; \all(\bnot \circ p, y).
\end{eqnarray*}\]</span> Using (1), we thus have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bfalse \\
 &amp; = &amp; \bnot(\btrue) \\
 &amp; = &amp; \bnot(\all(\bnot \circ p,x)) \\
 &amp; = &amp; \bnot(\bnot(\any(p,x))) \\
 &amp; = &amp; \any(p,x)
\end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
<div class="test">
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">_test_sublist_all ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">_test_sublist_all _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  testName <span class="st">&quot;if sublist(x,y) then if all(p)(y) then all(p)(x)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  \p x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">then</span> <span class="kw">if</span> all p y <span class="kw">then</span> all p x <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"><span class="ot">_test_sublist_any ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">_test_sublist_any _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  testName <span class="st">&quot;if sublist(x,y) then if any(p)(x) then any(p)(y)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  \p x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">    <span class="kw">then</span> <span class="kw">if</span> any p x <span class="kw">then</span> any p y <span class="kw">else</span> true</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<p><span class="math inline">\(\sublist\)</span> is destroyed by <span class="math inline">\(\cons\)</span>.</p>
<div class="theorem">
<p>Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(x,y \in \lists{A}\)</span>. If <span class="math inline">\(\sublist(x,y)\)</span>, then <span class="math inline">\(\sublist(\cons(a,y),x) = \bfalse\)</span>.</p>
<div class="proof">
<p>Suppose to the contrary that <span class="math inline">\(\sublist(\cons(a,y),x) = \btrue\)</span>. By transitivity we have <span class="math inline">\(\sublist(\cons(a,y),y)\)</span>, and we also have <span class="math inline">\(\sublist(y,\cons(a,y))\)</span>, so by antisymmetry we have <span class="math inline">\(y = \cons(a,y)\)</span> – a contradiction.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">_test_sublist_cons_not ::</span> (<span class="dt">List</span> t, <span class="dt">Equal</span> a, <span class="dt">Equal</span> (t a))</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">_test_sublist_cons_not _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  testName <span class="st">&quot;if sublist(x,y) then eq(sublist(cons(a,y),x),false)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  \p a x y <span class="ot">-&gt;</span> <span class="kw">if</span> sublist x y</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    <span class="kw">then</span> eq (sublist (cons a y) x) false</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    <span class="kw">else</span> true</a></code></pre></div>
</div>
</div>
<h2 id="testing">Testing</h2>
<p>Suite:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">_test_sublist ::</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  ( <span class="dt">TypeName</span> a, <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  , <span class="dt">TypeName</span> (t a), <span class="dt">List</span> t</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  , <span class="dt">Show</span> (t a), <span class="dt">Equal</span> (t a), <span class="dt">Arbitrary</span> (t a), <span class="dt">Equal</span> (t (a,a))</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  , <span class="dt">Natural</span> n</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  ) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">_test_sublist t n maxSize numCases <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  testLabel1 <span class="st">&quot;sublist&quot;</span> t</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    args <span class="fu">=</span> stdArgs</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">      { maxSuccess <span class="fu">=</span> numCases</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">      , maxSize    <span class="fu">=</span> maxSize</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">      }</a>
<a class="sourceLine" id="cb20-15" data-line-number="15"></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">  runTest args (_test_sublist_list_nil t)</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  runTest args (_test_sublist_nil_cons t)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">  runTest args (_test_sublist_cons_cons t)</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">  runTest args (_test_sublist_reflexive t)</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">  runTest args (_test_sublist_nil_snoc t)</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">  runTest args (_test_sublist_snoc_cancel t)</a>
<a class="sourceLine" id="cb20-22" data-line-number="22">  runTest args (_test_sublist_cat_left_cancel t)</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">  runTest args (_test_sublist_cat_right_cancel t)</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">  runTest args (_test_sublist_cons_right t)</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">  runTest args (_test_sublist_cons_left t)</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  runTest args (_test_sublist_length t n)</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">  runTest args (_test_sublist_antisymmetric t)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28">  runTest args (_test_sublist_transitive t)</a>
<a class="sourceLine" id="cb20-29" data-line-number="29">  runTest args (_test_sublist_cat_compatible t)</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">  runTest args (_test_sublist_snoc_snoc t)</a>
<a class="sourceLine" id="cb20-31" data-line-number="31">  runTest args (_test_sublist_rev t)</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">  runTest args (_test_sublist_snoc_right t)</a>
<a class="sourceLine" id="cb20-33" data-line-number="33">  runTest args (_test_sublist_snoc_left t)</a>
<a class="sourceLine" id="cb20-34" data-line-number="34">  runTest args (_test_sublist_left_cat_right t)</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">  runTest args (_test_sublist_right_cat_right t)</a>
<a class="sourceLine" id="cb20-36" data-line-number="36">  runTest args (_test_sublist_left_cat_left t)</a>
<a class="sourceLine" id="cb20-37" data-line-number="37">  runTest args (_test_sublist_right_cat_left t)</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">  runTest args (_test_sublist_map t)</a>
<a class="sourceLine" id="cb20-39" data-line-number="39">  runTest args (_test_sublist_filter t)</a>
<a class="sourceLine" id="cb20-40" data-line-number="40">  runTest args (_test_sublist_all t)</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">  runTest args (_test_sublist_any t)</a>
<a class="sourceLine" id="cb20-42" data-line-number="42">  runTest args (_test_sublist_cons_not t)</a></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">main_sublist ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">main_sublist <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  _test_sublist (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Bool</span>)  (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">50</span> <span class="dv">200</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  _test_sublist (<span class="ot">nil ::</span> <span class="dt">ConsList</span> <span class="dt">Unary</span>) (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">50</span> <span class="dv">200</span></a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
