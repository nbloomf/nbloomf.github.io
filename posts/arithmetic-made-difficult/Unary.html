<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - From Arrows to Programs</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>From Arrows to Programs</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2014-05-07 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}[2]{\mathsf{natrec}(#1,#2)}\)
\(\newcommand{\simprec}[2]{\mathsf{simprec}(#1,#2)}\)
\(\newcommand{\bailrec}[4]{\mathsf{bailrec}(#1,#2,#3,#4)}\)
\(\newcommand{\mutrec}[3]{\mathsf{mutrec}(#1,#2,#3)}\)
\(\newcommand{\dnatrec}[3]{\mathsf{dnatrec}(#1,#2,#3)}\)
\(\newcommand{\normrec}[3]{\mathsf{normrec}(#1,#2,#3)}\)
\(\newcommand{\findsmallest}[1]{\mathsf{findsmallest}(#1)}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\foldl}[1]{\mathsf{foldl}(#1)}\)
\(\newcommand{\tacunfoldN}[1]{\mathsf{tacunfoldN}(#1)}\)
\(\newcommand{\unfoldN}[1]{\mathsf{unfoldN}(#1)}\)
\(\newcommand{\dfoldr}[3]{\mathsf{dfoldr}(#1,#2,#3)}\)
\(\newcommand{\cfoldr}[2]{\mathsf{cfoldr}(#1,#2)}\)
\(\newcommand{\bfoldr}[4]{\mathsf{bfoldr}(#1,#2,#3,#4)}\)
\(\newcommand{\dbfoldr}[5]{\mathsf{dbfoldr}(#1,#2,#3,#4,#5)}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Unary.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Unary</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ( <span class="dt">Unary</span>(<span class="dt">Z</span>,<span class="dt">N</span>), mkUnary, natRec</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Integer</span>, (-), (&lt;=))</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Test.QuickCheck.Modifiers</span> (<span class="dt">NonNegative</span>(..))</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Booleans</span></a></code></pre></div>
<p>A nice consequence of wrapping up recursion in the <span class="math inline">\(\natrec{\ast}{\ast}\)</span> function is that it allows us to write programs, independent of any implementation, and prove things about them. We’ll see lots of examples of this, but first we need to establish some structural results.</p>
<div class="result">
<div class="defn">
<p>Let <span class="math inline">\(1 = \{\ast\}\)</span>, and define <span class="math inline">\(\varphi : 1 + \nats \rightarrow 1 + \nats\)</span> by <span class="math display">\[\varphi = \rgt \circ \either(\const(\zero),\next).\]</span> In this post we consider <span class="math display">\[(1 + \nats, \lft(\ast), \varphi)\]</span> as an inductive set.</p>
</div>
</div>
<p>It turns out that <span class="math inline">\(1 + \nats\)</span> is isomorphic to <span class="math inline">\(\nats\)</span>, and the map that achieves this is useful.</p>
<div class="result">
<div class="thm">
<p>The natural recursion map <span class="math inline">\(\Theta : \nats \rightarrow 1 + \nats\)</span> is an isomorphism; in particular, the inverse of <span class="math inline">\(\Theta\)</span> is <span class="math display">\[\Omega = \either(\const(\zero),\next).\]</span> We denote this <span class="math inline">\(\Theta\)</span> by <span class="math inline">\(\unnext\)</span>.</p>
</div>
<div class="proof">
<p>
<p>We need to show two results: first that <span class="math inline">\(\Omega\)</span> is an inductive set homomorphism, and second that <span class="math inline">\(\Omega\)</span> and <span class="math inline">\(\Theta\)</span> are mutual inverses. To the first point, note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \Omega(\lft(\ast)) \\
 &amp; = &amp; \either(\const(\zero),\id)(\lft(\ast)) \\
 &amp; = &amp; \const(\zero)(\ast) \\
 &amp; = &amp; \zero
\end{eqnarray*}\]</span> and if <span class="math inline">\(x \in 1 + \nats\)</span>, we have two possibilities. If <span class="math inline">\(x = \lft(\ast)\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \Omega(\varphi(\lft(\ast))) \\
 &amp; = &amp; \Omega((\rgt \circ \either(\const(\zero),\next))(\lft(\ast))) \\
 &amp; = &amp; \Omega(\rgt(\either(\const(\zero),\next)(\lft(\ast)))) \\
 &amp; = &amp; \Omega(\rgt(\const(\zero)(\ast))) \\
 &amp; = &amp; \Omega(\rgt(\zero)) \\
 &amp; = &amp; \either(\const(\zero),\next)(\rgt(\zero)) \\
 &amp; = &amp; \next(\zero) \\
 &amp; = &amp; \next(\Omega(\lft(\ast)))
\end{eqnarray*}\]</span> and if <span class="math inline">\(x = \rgt(n)\)</span>, with <span class="math inline">\(n \in \nats\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \Omega(\varphi(\rgt(n))) \\
 &amp; = &amp; \Omega((\rgt \circ \either(\const(\zero),\next))(\rgt(n))) \\
 &amp; = &amp; \Omega(\rgt(\either(\const(\zero),\next)(\rgt(n)))) \\
 &amp; = &amp; \Omega(\rgt(\next(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)(\rgt(\next(n))) \\
 &amp; = &amp; \next(\next(n)) \\
 &amp; = &amp; \next(\either(\const(\zero),\next)(\rgt(n))) \\
 &amp; = &amp; \next(\Omega(\rgt(n)))
\end{eqnarray*}\]</span> as needed.</p>
Next to see that <span class="math inline">\(\Omega\)</span> and <span class="math inline">\(\Theta\)</span> are mutual inverses. First we show that <span class="math inline">\((\Omega \circ \Theta)(n) = \id(n)\)</span> for all <span class="math inline">\(n \in \nats\)</span>, proceeding by induction. For the base case <span class="math inline">\(n = \zero\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\Omega \circ \Theta)(n) \\
 &amp; = &amp; \Omega(\Theta(\zero)) \\
 &amp; = &amp; \either(\const(\zero),\next)(\natrec{\lft(\ast)}{\varphi}(\zero)) \\
 &amp; = &amp; \either(\const(\zero),\next)(\lft(\ast)) \\
 &amp; = &amp; \const(\zero)(\ast) \\
 &amp; = &amp; \zero \\
 &amp; = &amp; n,
\end{eqnarray*}\]</span> and if the equality holds for <span class="math inline">\(n\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\Omega \circ \Theta)(\next(n)) \\
 &amp; = &amp; \Omega(\Theta(\next(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)(\natrec{\lft(\ast)}{\varphi}(\next(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)(\varphi(\natrec{\lft(\ast)}{\varphi}(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)(\varphi(\Theta(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)((\rgt \circ \either(\const(\zero),\next))(\Theta(n))) \\
 &amp; = &amp; \either(\const(\zero),\next)(\rgt(\either(\const(\zero),\next)(\Theta(n)))) \\
 &amp; = &amp; \next(\either(\const(\zero),\next)(\Theta(n))) \\
 &amp; = &amp; \next(\Omega(\Theta(n))) \\
 &amp; = &amp; \next((\Omega \circ \Theta)(n)) \\
 &amp; = &amp; \next(n)
\end{eqnarray*}\]</span> as needed. Now to see that <span class="math inline">\(\Theta \circ \Omega = \id\)</span>, we consider two possibilities. First note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\Theta \circ \Omega)(\lft(\ast)) \\
 &amp; = &amp; \Theta(\Omega(\lft(\ast))) \\
 &amp; = &amp; \Theta(\either(\const(\zero),\next)(\lft(\ast))) \\
 &amp; = &amp; \Theta(\const(\zero)(\ast)) \\
 &amp; = &amp; \Theta(\zero) \\
 &amp; = &amp; \lft(\ast).
\end{eqnarray*}\]</span> To see that <span class="math inline">\((\Theta \circ \Omega)(\rgt(n)) = \rgt(n)\)</span> for all <span class="math inline">\(n \in \nats\)</span>, we proceed by induction. For the base case <span class="math inline">\(n = \zero\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\Theta \circ \Omega)(\rgt(n)) \\
 &amp; = &amp; \Theta(\Omega(\rgt(\zero))) \\
 &amp; = &amp; \Theta(\either(\const(\zero),\next)(\rgt(\zero))) \\
 &amp; = &amp; \Theta(\next(\zero)) \\
 &amp; = &amp; \natrec{\lft(\ast)}{\varphi}(\next(\zero)) \\
 &amp; = &amp; \varphi(\natrec{\lft(\ast)}{\varphi}(\zero)) \\
 &amp; = &amp; \varphi(\lft(\ast)) \\
 &amp; = &amp; (\rgt \circ \either(\const(\zero),\next))(\lft(\ast)) \\
 &amp; = &amp; \rgt(\either(\const(\zero),\next)(\lft(\ast))) \\
 &amp; = &amp; \rgt(\const(\zero)(\ast)) \\
 &amp; = &amp; \rgt(\zero) \\
 &amp; = &amp; \rgt(n)
\end{eqnarray*}\]</span> as needed. For the inductive step, if the equality holds for some <span class="math inline">\(n\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\Theta \circ \Omega)(\rgt(\next(n))) \\
 &amp; = &amp; \Theta(\Omega(\rgt(\next(n)))) \\
 &amp; = &amp; \Theta(\either(\const(\zero),\next)(\rgt(\next(n)))) \\
 &amp; = &amp; \Theta(\next(\next(n))) \\
 &amp; = &amp; \natrec{\lft(\ast)}{\varphi}(\next(\next(n))) \\
 &amp; = &amp; \varphi(\natrec{\lft(\ast)}{\varphi}(\next(n))) \\
 &amp; = &amp; \varphi(\Theta(\next(n))) \\
 &amp; = &amp; \varphi(\Theta(\either(\const(\zero),\next)(\rgt(n)))) \\
 &amp; = &amp; \varphi((\Theta \circ \Omega)(\rgt(n))) \\
 &amp; = &amp; \varphi(\rgt(n)) \\
 &amp; = &amp; (\rgt \circ \either(\const(\zero),\next))(\rgt(n)) \\
 &amp; = &amp; \rgt(\either(\const(\zero),\next)(\rgt(n))) \\
 &amp; = &amp; \rgt(\next(n))
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>From <span class="math inline">\(\unnext\)</span> we define two helper functions.</p>
<div class="result">
<div class="defn">
<p>We define <span class="math inline">\(\prev : \nats \rightarrow \nats\)</span> by <span class="math display">\[\prev = \either(\const(\zero),\id) \circ \unnext\]</span> and <span class="math inline">\(\iszero : \nats \rightarrow \bool\)</span> by <span class="math display">\[\iszero = \either(\const(\btrue),\const(\bfalse)) \circ \unnext.\]</span></p>
</div>
</div>
<p>Now <span class="math inline">\(\unnext\)</span>, <span class="math inline">\(\prev\)</span>, and <span class="math inline">\(\iszero\)</span> have some useful properties.</p>
<div class="result">
<div class="thm">
<p>
<ol type="1">
<li><span class="math inline">\(\unnext(\zero) = \lft(\ast)\)</span>.</li>
<li><span class="math inline">\(\unnext(\next(n)) = \rgt(n)\)</span>.</li>
<li><span class="math inline">\(\prev(\zero) = \zero\)</span>.</li>
<li><span class="math inline">\(\prev(\next(n)) = n\)</span>.</li>
<li><span class="math inline">\(\iszero(\zero) = \btrue\)</span>.</li>
<li><span class="math inline">\(\iszero(\next(n)) = \bfalse\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol type="1">
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unnext(\zero) \\
 &amp; = &amp; \natrec{\lft(\ast)}{\varphi}(\zero) \\
 &amp; = &amp; \lft(\ast)
\end{eqnarray*}\]</span> as claimed.</li>
<li>Letting <span class="math inline">\(\Omega\)</span> be the inverse of <span class="math inline">\(\unnext\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \unnext(\next(n)) \\
 &amp; = &amp; \unnext(\either(\const(\zero),\next)(\rgt(n))) \\
 &amp; = &amp; \unnext(\Omega(\rgt(n))) \\
 &amp; = &amp; (\unnext \circ \Omega)(\rgt(n)) \\
 &amp; = &amp; \rgt(n)
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prev(\zero) \\
 &amp; = &amp; (\either(\const(\zero),\id) \circ \unnext)(\zero) \\
 &amp; = &amp; \either(\const(\zero),\id)(\unnext(\zero)) \\
 &amp; = &amp; \either(\const(\zero),\id)(\lft(\ast)) \\
 &amp; = &amp; \const(\zero)(\ast) \\
 &amp; = &amp; \zero
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \prev(\next(n)) \\
 &amp; = &amp; (\either(\const(\zero),\id) \circ \unnext)(\next(n)) \\
 &amp; = &amp; \either(\const(\zero),\id)(\unnext(\next(n))) \\
 &amp; = &amp; \either(\const(\zero),\id)(\rgt(n)) \\
 &amp; = &amp; \id(n) \\
 &amp; = &amp; n
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \iszero(\zero) \\
 &amp; = &amp; (\either(\const(\btrue),\const(\bfalse)) \circ \unnext)(\zero) \\
 &amp; = &amp; \either(\const(\btrue),\const(\bfalse))(\unnext(\zero)) \\
 &amp; = &amp; \either(\const(\btrue),\const(\bfalse))(\lft(\ast)) \\
 &amp; = &amp; \const(\btrue)(\ast) \\
 &amp; = &amp; \btrue
\end{eqnarray*}\]</span> as claimed.</li>
<li>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \iszero(\next(n)) \\
 &amp; = &amp; (\either(\const(\btrue),\const(\bfalse)) \circ \unnext)(\next(n)) \\
 &amp; = &amp; \either(\const(\btrue),\const(\bfalse))(\unnext(\next(n))) \\
 &amp; = &amp; \either(\const(\btrue),\const(\bfalse))(\rgt(n)) \\
 &amp; = &amp; \const(\bfalse)(n) \\
 &amp; = &amp; \bfalse
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>We’re now ready to finish off the Peano axioms.</p>
<div class="result">
<div class="thm">
<p>
<ol type="1">
<li>Every natural number is either <span class="math inline">\(\zero\)</span> or of the form <span class="math inline">\(\next(m)\)</span> for some natural number <span class="math inline">\(m\)</span>,</li>
<li>No natural number is both <span class="math inline">\(\zero\)</span> and <span class="math inline">\(\next(m)\)</span> for some <span class="math inline">\(m\)</span>, and</li>
<li><span class="math inline">\(\next(n) = \next(m)\)</span> if and only if <span class="math inline">\(n = m\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol type="1">
<li>Let <span class="math inline">\(n \in \nats\)</span> and let <span class="math inline">\(\Omega\)</span> be the inverse of <span class="math inline">\(\unnext\)</span>. Consider <span class="math inline">\(\unnext(n) \in 1 + \nats\)</span>; we have either <span class="math inline">\(\unnext(n) = \lft(\ast)\)</span> or <span class="math inline">\(\unnext(n) = \rgt(m)\)</span> for some <span class="math inline">\(m \in \nats\)</span>. In the first case we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; n \\
 &amp; = &amp; \Omega(\unnext(n)) \\
 &amp; = &amp; \Omega(\lft(\ast)) \\
 &amp; = &amp; \const(\zero)(\ast) \\
 &amp; = &amp; \zero,
\end{eqnarray*}\]</span> and in the second case we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; n \\
 &amp; = &amp; \Omega(\unnext(n)) \\
 &amp; = &amp; \Omega(\rgt(m)) \\
 &amp; = &amp; \next(m)
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(\zero = \next(n)\)</span>, we have <span class="math display">\[\btrue = \iszero(\zero) = \iszero(\next(n)) = \bfalse,\]</span> which is absurd.</li>
<li>The “if” part is trivial. To see the “only if” part, suppose we have <span class="math inline">\(\next(n) = \next(m)\)</span>; then <span class="math display">\[n = \prev(\next(n)) = \prev(\next(m)) = m\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>Establishing that every natural number is either <span class="math inline">\(\zero\)</span> or of the form <span class="math inline">\(\next(m)\)</span> for some <span class="math inline">\(m\)</span> also justifies our use of the following Haskell type to model the natural numbers.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Unary</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">N</span> <span class="dt">Unary</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Unary</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  show  <span class="dt">Z</span>    <span class="fu">=</span> <span class="st">&quot;O&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  show (<span class="dt">N</span> k) <span class="fu">=</span> <span class="ch">'I'</span> <span class="fu">:</span> show k</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">TypeName</span> <span class="dt">Unary</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  typeName _ <span class="fu">=</span> <span class="st">&quot;Unary&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Equal</span> <span class="dt">Unary</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  eq <span class="dt">Z</span>     <span class="dt">Z</span>     <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  eq <span class="dt">Z</span>     (<span class="dt">N</span> _) <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  eq (<span class="dt">N</span> _) <span class="dt">Z</span>     <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  eq (<span class="dt">N</span> x) (<span class="dt">N</span> y) <span class="fu">=</span> eq x y</a></code></pre></div>
<p>(That <code>show</code> instance is so we can display elements of <code>Nat</code> without too many parentheses.) We also define a helper function to convert integers into <code>Nat</code>s as follows.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mkUnary ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Unary</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mkUnary k <span class="fu">=</span> <span class="kw">if</span> k <span class="fu">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">then</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">else</span> <span class="dt">N</span> (mkUnary (k<span class="fu">-</span><span class="dv">1</span>))</a></code></pre></div>
<p>So calling <code>mkUnary 7</code> in <code>ghci</code>, for instance, prints</p>
<pre><code>NNNNNNNZ</code></pre>
<p>And we can also give a straightforward implementation of <span class="math inline">\(\natrec{\ast}{\ast}\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">natRec' ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Unary</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">natRec' e _    <span class="dt">Z</span>    <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">natRec' e phi (<span class="dt">N</span> n) <span class="fu">=</span> phi (natRec' e phi n)</a></code></pre></div>
<p>For example:</p>
<pre><code>let theta' = natRec' True not</code></pre>
<p>and we can test out this map by evaluating it on several natural numbers:</p>
<pre><code>&gt; theta' $ mkUnary 10
True
&gt; theta' $ mkUnary 11
False</code></pre>
<p>Now this <code>theta'</code> is pretty silly (though not <em>that</em> silly, it detects the parity of a natural number, which we haven’t defined yet). But in the next section we’ll define a more interesting recursive function.</p>
<h2 id="but">But…</h2>
<p>There is a practical problem with this implementation of <code>natRec'</code>. If we evaluate on a natural number like <code>NNNZ</code>, the “stack” of function calls expands to something like this:</p>
<pre><code>   natRec' e phi (N $ N $ N Z)
== phi $ natRec' e phi (N $ N Z)
== phi $ phi $ natRec' e phi (N Z)
== phi $ phi $ phi $ natRec' e phi Z
== phi $ phi $ phi $ e
== phi $ phi $ e'
== phi $ e''
== e'''</code></pre>
<p>So we generate a tower of unevaluated calls to <code>phi</code>, <span class="math inline">\(n\)</span> tall, before collapsing it down again. In the meantime all those unevaluated <code>phi</code>s are sitting in memory. It is not difficult to see that if we evaluate <code>natRec'</code> on a “larger” number (whatever that means) we will quickly run out of actual memory. To help with this, we can try rewriting <code>natRec</code> in so-called “tail call” recursive form like so.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">natRec ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Unary</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">natRec e phi n <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    tau <span class="fu">!</span>x k <span class="fu">=</span> <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      <span class="dt">Z</span>   <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      <span class="dt">N</span> m <span class="ot">-&gt;</span> tau (phi x) m</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">in</span> tau e n</a></code></pre></div>
<p>Now <code>natRec</code> does not leave a bunch of unevaluated functions in memory. It is effectively a loop, iterating “up” from 0 (again with the scare quotes because we don’t have an order on <span class="math inline">\(\nats\)</span> yet but of course you know what it means) rather than “down” from <span class="math inline">\(n\)</span>. So this version expands to something like this:</p>
<pre><code>   natRec e phi (N $ N $ N Z)
== tau e (N $ N $ N Z)
== tau e' (N $ N Z)
== tau e'' (N Z)
== tau e''' Z
== e'''</code></pre>
<p>It deconstructs its natural number argument and evaluates <code>phi</code> strictly at each step. (That is what the bang pattern and <code>$!</code> are for.) At least I think that’s what it does; my simple testing shows that <code>natRec'</code> easily falls down while <code>natRec</code> does not. But profiling Haskell seems like a bit of dark art to me still. I am open to being wrong here.</p>
<p>We can see that <code>natRec</code> has better performance than <code>natRec'</code>, but there is a hitch. <code>natRec'</code> is obviously an implementation of <span class="math inline">\(\natrec{\ast}{\ast}\)</span>. But it is <strong>not</strong> obvious that <code>natRec</code> and <code>natRec'</code> are the same function! This is where the universal property of natural recursion comes in: if we can show that both functions satisfy the universal property, then <em>they must be the same</em>. And we can do this using induction.</p>
<p>First, we claim that for all <code>n :: Nat</code>,</p>
<pre><code>natRec' (phi e) phi n == phi $ natRec' e phi n</code></pre>
<p>Using induction, it suffices to note that</p>
<pre><code>   natRec' (phi e) phi Z
== phi e
== phi $ natRec' e phi Z</code></pre>
<p>and that if the equation holds for <code>n</code>, then</p>
<pre><code>   natRec' (phi e) phi (N n)
== phi $ natRec' (phi e) phi n
== phi $ phi $ natRec' e phi n
== phi $ natRec' e phi (N n)</code></pre>
<p>Now, again using induction, we have</p>
<pre><code>   natRec e phi Z
== tau e Z
== e
== natRec' e phi Z</code></pre>
<p>and if <code>natRec e phi n == natRec' e phi n</code>, then</p>
<pre><code>   natRec e phi (N n)
== tau e (N n)
== tau (phi e) n
== natRec (phi e) phi n
== natRec' (phi e) phi n
== phi $ natRec' e phi n
== natRec' e phi (N n)</code></pre>
<p>Since <code>natRec e phi</code> and <code>natRec' e phi</code> are both functions with signature <code>Unary -&gt; a</code> which satisfy the universal property of <span class="math inline">\(\nats\)</span>, they must be the same function: equal on all inputs.</p>
<p>This is a powerful idea. We’ve effectively written a slow but obviously correct program, and then proven it is equivalent to a more efficient one. We’ll be doing more of this later.</p>
<h2 id="testing">Testing</h2>
<p>Along the way we’ll be writing some proofs involving <code>Nat</code>s, but it is also useful to do some automated testing. I’ll toss in an <code>Arbitrary</code> instance here.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Unary</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">NonNegative</span> k <span class="ot">&lt;-</span> arbitrary</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    return (mkUnary k)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  shrink  <span class="dt">Z</span>    <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  shrink (<span class="dt">N</span> k) <span class="fu">=</span> [k]</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">CoArbitrary</span> <span class="dt">Unary</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">  coarbitrary <span class="dt">Z</span> <span class="fu">=</span> variant <span class="dv">0</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  coarbitrary (<span class="dt">N</span> x) <span class="fu">=</span> variant <span class="dv">1</span> <span class="fu">.</span> coarbitrary x</a></code></pre></div>
<p>We can try out this instance with the following command.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="fu">$&gt;</span> generate (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Unary</span>)</a></code></pre></div>



<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
