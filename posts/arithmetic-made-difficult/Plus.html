<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Addition</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../pages/contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Addition</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2014-06-01 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\swap}{\mathsf{swap}}\)
\(\newcommand{\pair}{\mathsf{pair}}\)
\(\newcommand{\assocL}{\mathsf{assocL}}\)
\(\newcommand{\assocR}{\mathsf{assocR}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\simprec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)
\(\newcommand{\bailrec}[4]{\left(\!\left[ #1, #2, #3, #4 \right]\!\right)}\)

<!--- natural number arithmetic ---->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- list -->
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\foldl}[2]{\mathsf{foldl}(#1,#2)}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\count}{\mathsf{count}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p>This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Plus.lhs">the source</a> into GHCi and play along.</p>

<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Plus</span>
<span class="ot">&gt;</span>   ( plus, _test_plus, main_plus
<span class="ot">&gt;</span>   ) <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Booleans</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">NaturalNumbers</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> (id)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck.Test</span></code></pre></div>
<p>So far we’ve characterized the natural numbers via a unique mapping <span class="math display">\[\natrec{\ast}{\ast} : \nats \rightarrow A,\]</span> and we defined another parameterized mapping <span class="math display">\[\simprec{\ast}{\ast} : \nats \times A \rightarrow B.\]</span> From now on, when we want to define a mapping with one of these signatures, these prepackaged recursive maps may come in handy. What’s more, we can use the universal properties of these maps to define them in terms of <em>desired behavior</em>.</p>
<p>Natural number addition has signature <span class="math inline">\(\nats \times \nats \rightarrow \nats\)</span>, so we might hope to define addition in terms of <span class="math inline">\(\simprec{\ast}{\ast}\)</span>. To do this, we need to find mappings <span class="math inline">\(\varphi : \nats \rightarrow \nats\)</span> and <span class="math inline">\(\mu : \nats \times \nats \times \nats \rightarrow \nats\)</span> that make <span class="math inline">\(\simprec{\varphi}{\mu}\)</span> act like addition. For example, we want <span class="math inline">\(\next\)</span> to act like <span class="math inline">\(+1\)</span>, and <span class="math display">\[n = \zero + n = \simprec{\varphi}{\mu}(\zero,n) = \varphi(n),\]</span> and</p>
<p><span class="math display">\[\begin{eqnarray*}
(m+n)+1
 &amp; = &amp; (m+1)+n \\
 &amp; = &amp; \simprec{\varphi}{\mu}(\next(m),n) \\
 &amp; = &amp; \mu(m,n,\simprec{\varphi}{\mu}(m,n)) \\
 &amp; = &amp; \mu(m,n,m+n).
\end{eqnarray*}\]</span></p>
<p>With this in mind, we define a binary operation <span class="math inline">\(\nplus\)</span> on <span class="math inline">\(\nats\)</span> as follows.</p>
<div class="result">
<div class="defn">
<p>
Let <span class="math inline">\(\mu : \nats \times \nats \times \nats \rightarrow \nats\)</span> be given by <span class="math inline">\(\mu(k,a,b) = \next(b)\)</span>. We then define <span class="math inline">\(\nplus : \nats \times \nats \rightarrow \nats\)</span> by <span class="math display">\[\nplus = \simprec{\id}{\mu}.\]</span>
</p>
</div>
</div>
<p>Showing that <span class="math inline">\(\nplus\)</span> has the familiar properties of addition then comes down to a few applications of induction.</p>
<div class="result">
<div class="thm">
<p>The following hold for all natural numbers <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\nplus(\zero,a) = a = \nplus(a,\zero)\)</span>.</li>
<li><span class="math inline">\(\nplus(\next(a),b) = \next(\nplus(a,b)) = \nplus(a,\next(b))\)</span>.</li>
<li><span class="math inline">\(\nplus(\nplus(a,b),c) = \nplus(a,\nplus(b,c))\)</span>.</li>
<li><span class="math inline">\(\nplus(a,b) = \nplus(b,a)\)</span>.</li>
<li>If <span class="math inline">\(\nplus(c,a) = \nplus(c,b)\)</span> then <span class="math inline">\(a = b\)</span>.</li>
<li>If <span class="math inline">\(\nplus(a,c) = \nplus(b,c)\)</span> then <span class="math inline">\(a = b\)</span>.</li>
</ol>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>Note that <span class="math display">\[\nplus(\zero,a) = \simprec{\id}{\mu}(\zero,a) = \id(a) = a.\]</span> We show the second equality by induction on <span class="math inline">\(a\)</span>. For the base case, we have <span class="math inline">\(\nplus(\zero,\zero) = \zero\)</span> by the first equality. For the inductive step, suppose we have <span class="math inline">\(\nplus(a,\zero) = a\)</span> for some <span class="math inline">\(a\)</span>. Then <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nplus(\next(a),\zero) \\
 &amp; = &amp; \simprec{\id}{\mu}(\next(a),\zero) \\
 &amp; = &amp; \mu(a, \zero, \simprec{\id}{\mu}(a,\zero)) \\
 &amp; = &amp; \mu(a, \zero, \nplus(a, \zero)) \\
 &amp; = &amp; \mu(a,\zero,a) \\
 &amp; = &amp; \next(a)
\end{eqnarray*}\]</span> as needed.</li>
<li>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \nplus(\next(a),b) \\
 &amp; = &amp; \simprec{\id}{\mu}(\next(a),b) \\
 &amp; = &amp; \mu(a,b,\simprec{\id}{\mu}(a,b)) \\
 &amp; = &amp; \mu(a,b,\nplus(a,b)) \\
 &amp; = &amp; \next(\nplus(a,b)).
\end{eqnarray*}\]</span> We show the second equality by induction on <span class="math inline">\(a\)</span>. For the base case, note that <span class="math display">\[\begin{eqnarray*} &amp; &amp; \nplus(\zero,\next(b)) \\ &amp; = &amp; \simprec{\id}{\mu}(\zero,\next(b)) \\ &amp; = &amp; \id(\next(b)) \\ &amp; = &amp; \next(b). \end{eqnarray*}\]</span> For the inductive step, suppose we have <span class="math inline">\(\next(\nplus(a,b)) = \nplus(a,\next(b))\)</span> for some <span class="math inline">\(a\)</span>. Then <span class="math display">\[\begin{eqnarray*} &amp; &amp; \nplus(\next(a),\next(b)) \\ &amp; = &amp; \simprec{\id}{\mu}(\next(a),\next(b)) \\ &amp; = &amp; \mu(a, \next(b), \simprec{\id}{\mu}(a, \next(b))) \\ &amp; = &amp; \mu(a, \next(b), \nplus(a, \next(b))) \\ &amp; = &amp; \mu(a, \next(b), \next(\nplus(a,b))) \\ &amp; = &amp; \next(\next(\nplus(a,b))) \\ &amp; = &amp; \next(\nplus(\next(a),b)) \end{eqnarray*}\]</span> as needed.</li>
<li>We will show this by induction on <span class="math inline">\(a\)</span>. For the base case, note that <span class="math display">\[\nplus(\nplus(\zero,b),c) = \nplus(b,c) = \nplus(\zero,\nplus(b,c)).\]</span> For the inductive step, suppose the result holds for some <span class="math inline">\(a\)</span>. Then <span class="math display">\[\begin{eqnarray*} &amp; &amp; \nplus(\nplus(\next(a),b),c) \\ &amp; = &amp; \nplus(\next(\nplus(a,b)),c) \\ &amp; = &amp; \next(\nplus(\nplus(a,b),c)) \\ &amp; = &amp; \next(\nplus(a, \nplus(b,c))) \\ &amp; = &amp; \nplus(\next(a), \nplus(b,c)) \end{eqnarray*}\]</span> as needed.</li>
<li>We proceed by induction on <span class="math inline">\(a\)</span>. For the base case, note that <span class="math display">\[\nplus(\zero,b) = b = \nplus(b,\zero).\]</span> For the inductive step, suppose the result holds for some <span class="math inline">\(a\)</span>. Then we have <span class="math display">\[\begin{eqnarray*} &amp; &amp; \nplus(\next(a),b) \\ &amp; = &amp; \next(\nplus(a,b)) \\ &amp; = &amp; \next(\nplus(b,a)) \\ &amp; = &amp; \nplus(b, \next(a))\end{eqnarray*}\]</span> as needed.</li>
<li>We proceed by induction on <span class="math inline">\(c\)</span>. For the base case, note that if <span class="math inline">\(\nplus(\zero,a) = \nplus(\zero,b)\)</span>, then we have <span class="math display">\[a = \nplus(\zero,a) = \nplus(\zero,b) = b.\]</span> For the inductive step, suppose the result holds for some <span class="math inline">\(c\)</span>. Now if <span class="math display">\[\nplus(\next(c),a)) = \nplus(\next(c),b),\]</span> then <span class="math display">\[\next(\nplus(c,a)) = \next(\nplus(c,b))\]</span> so that <span class="math display">\[\nplus(c,a) = \nplus(c,b)\]</span> and thus <span class="math inline">\(a = b\)</span> as needed.</li>
<li>Follows from (5) and (4).</li>
</ol>
</p>
</div>
</div>
<p>Of course we will eventually prefer to say <span class="math inline">\(a + b\)</span> instead of <span class="math inline">\(\nplus(a,b)\)</span>. But we’ll avoid the more familiar notation until we’re convinced that <span class="math inline">\(\nplus\)</span> really does act just like the familiar <span class="math inline">\(+\)</span>, since familiar notation can easily lull us into using theorems we haven’t proven yet.</p>
<h2 id="implementation-and-testing">Implementation and Testing</h2>
<p>Here’s <code>plus</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; plus ::</span> (<span class="dt">Natural</span> t) <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t
<span class="ot">&gt;</span> plus <span class="fu">=</span> simpleRec id mu
<span class="ot">&gt;</span>   <span class="kw">where</span> mu _ _ b <span class="fu">=</span> next b</code></pre></div>
<p>We’ve proved a bunch of properties for <code>plus</code>, but it’s still a good idea to verify them. We can do this with <code>QuickCheck</code>. First we express each property to be tested as a boolean function. Note that each one takes an “extra” argument; this is just to fix the type of the function being tested. (There may be a better way to do this.)</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- a == plus(a,0) and a == plus(0,a)</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus_zero ::</span> (<span class="dt">Natural</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Nat</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_plus_zero _ a <span class="fu">=</span>
<span class="ot">&gt;</span>   (a <span class="fu">====</span> plus a zero) <span class="fu">&amp;&amp;&amp;</span> (a <span class="fu">====</span> plus zero a)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- next(plus(a,b)) == plus(next(a),b)</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus_next_left ::</span> (<span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_plus_next_left _ a b <span class="fu">=</span>
<span class="ot">&gt;</span>   (next (plus a b)) <span class="fu">====</span> (plus (next a) b)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- next(plus(a,b)) == plus(a,next(b))</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus_next_right ::</span> (<span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_plus_next_right _ a b <span class="fu">=</span>
<span class="ot">&gt;</span>   (next (plus a b)) <span class="fu">====</span> (plus a (next b))
<span class="ot">&gt;</span>   
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- plus(plus(a,b),c) == plus(a,plus(b,c))</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus_associative ::</span> (<span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_plus_associative _ a b c <span class="fu">=</span>
<span class="ot">&gt;</span>   (plus (plus a b) c) <span class="fu">====</span> (plus a (plus b c))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- plus(a,b) == plus(b,a)</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus_commutative ::</span> (<span class="dt">Natural</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> _test_plus_commutative _ a b <span class="fu">=</span>
<span class="ot">&gt;</span>   (plus a b) <span class="fu">====</span> (plus b a)</code></pre></div>
<p>We’ll wrap all these tests behind a single function, <code>_test_plus</code>, which takes the number of cases to check as an argument.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- run all tests for plus</span>
<span class="ot">&gt;</span> _<span class="ot">test_plus ::</span> (<span class="dt">Natural</span> n, <span class="dt">Show</span> n, <span class="dt">Arbitrary</span> n)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> _test_plus label n maxSize numCases <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   testLabel (<span class="st">&quot;plus: &quot;</span> <span class="fu">++</span> label)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     args <span class="fu">=</span> stdArgs
<span class="ot">&gt;</span>       { maxSuccess <span class="fu">=</span> numCases
<span class="ot">&gt;</span>       , maxSize    <span class="fu">=</span> maxSize
<span class="ot">&gt;</span>       }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args (_test_plus_zero n)
<span class="ot">&gt;</span>   runTest args (_test_plus_next_left n)
<span class="ot">&gt;</span>   runTest args (_test_plus_next_right n)
<span class="ot">&gt;</span>   runTest args (_test_plus_associative n)
<span class="ot">&gt;</span>   runTest args (_test_plus_commutative n)</code></pre></div>
<p>woo!</p>
<p>I will also provide a <code>main</code> function so my build scripts for this blog can automatically compile and run the tests.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main_plus ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main_plus <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   _test_plus <span class="st">&quot;Unary&quot;</span> (<span class="ot">zero ::</span> <span class="dt">Unary</span>) <span class="dv">100</span> <span class="dv">100</span></code></pre></div>


<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
