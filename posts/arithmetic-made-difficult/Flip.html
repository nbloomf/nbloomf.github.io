<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Flip</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Flip</h1>
<!-- BEGIN CONTENT -->


<div class="info">
Posted on 2018-02-17 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- proof structure -->
\(\newcommand{\hyp}[2]{\stackrel{\tiny\text{hyp}}{#2}}\)
\(\newcommand{\let}[2]{\stackrel{\tiny\text{let}}{#2}}\)
\(\newcommand{\a}{a}\)
\(\newcommand{\b}{b}\)
\(\newcommand{\c}{c}\)
\(\newcommand{\p}{p}\)
\(\newcommand{\q}{q}\)
\(\newcommand{\r}{r}\)
\(\newcommand{\s}{s}\)
\(\newcommand{\x}{x}\)
\(\newcommand{\y}{y}\)
\(\newcommand{\z}{z}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\bimpl}{\mathbin{\mathsf{impl}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- functions -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\compose}{\mathsf{compose}}\)
\(\newcommand{\const}{\mathsf{const}}\)
\(\newcommand{\apply}{\mathsf{apply}}\)
\(\newcommand{\flip}{\mathsf{flip}}\)
\(\newcommand{\flipB}{\mathsf{flip2}}\)
\(\newcommand{\flipC}{\mathsf{flip3}}\)
\(\newcommand{\flipD}{\mathsf{flip4}}\)
\(\newcommand{\flipE}{\mathsf{flip5}}\)
\(\newcommand{\clone}{\mathsf{clone}}\)
\(\newcommand{\cloneC}{\mathsf{clone3}}\)
\(\newcommand{\composeAonB}{\mathsf{compose1on2}}\)
\(\newcommand{\composeAonC}{\mathsf{compose1on3}}\)
\(\newcommand{\composeAonD}{\mathsf{compose1on4}}\)
\(\newcommand{\composeBonA}{\mathsf{compose2on1}}\)
\(\newcommand{\composeBonB}{\mathsf{compose2on2}}\)
\(\newcommand{\composeConA}{\mathsf{compose3on1}}\)


<!-- predicates -->
\(\newcommand{\ptrue}{\mathsf{ptrue}}\)
\(\newcommand{\pfalse}{\mathsf{pfalse}}\)
\(\newcommand{\pnot}{\mathsf{pnot}}\)
\(\newcommand{\pand}{\mathbin{\mathsf{pand}}}\)
\(\newcommand{\por}{\mathbin{\mathsf{por}}}\)
\(\newcommand{\pimpl}{\mathbin{\mathsf{pimpl}}}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\tup}{\mathsf{tup}}\)
\(\newcommand{\tSwap}{\mathsf{swap}_{\times}}\)
\(\newcommand{\tPair}{\mathsf{pair}_{\times}}\)
\(\newcommand{\tAssocL}{\mathsf{assocL}_{\times}}\)
\(\newcommand{\tAssocR}{\mathsf{assocR}_{\times}}\)
\(\newcommand{\tupL}{\mathsf{tupL}}\)
\(\newcommand{\tupR}{\mathsf{tupR}}\)
\(\newcommand{\uncurry}{\mathsf{uncurry}}\)
\(\newcommand{\curry}{\mathsf{curry}}\)

<!-- disjoint unions -->
\(\newcommand{\lft}{\mathsf{left}}\)
\(\newcommand{\rgt}{\mathsf{right}}\)
\(\newcommand{\either}{\mathsf{either}}\)
\(\newcommand{\uSwap}{\mathsf{swap}_{+}}\)
\(\newcommand{\uPair}{\mathsf{pair}_{+}}\)
\(\newcommand{\uAssocL}{\mathsf{assocL}_{+}}\)
\(\newcommand{\uAssocR}{\mathsf{assocR}_{+}}\)
\(\newcommand{\isLft}{\mathsf{isLeft}}\)
\(\newcommand{\isRgt}{\mathsf{isRight}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\unnext}{\mathsf{unnext}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)

<!-- natural number recursion -->
\(\newcommand{\natrec}{\mathsf{natrec}}\)
\(\newcommand{\simprec}{\mathsf{simprec}}\)
\(\newcommand{\bailrec}{\mathsf{bailrec}}\)
\(\newcommand{\mutrec}{\mathsf{mutrec}}\)
\(\newcommand{\dnatrec}{\mathsf{dnatrec}}\)
\(\newcommand{\normrec}{\mathsf{normrec}}\)
\(\newcommand{\findsmallest}{\mathsf{findsmallest}}\)
\(\newcommand{\mnormrec}{\mathsf{mnormrec}}\)

<!-- natural number arithmetic -->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- lists -->
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\head}{\mathsf{head}}\)

<!-- list recursion -->
\(\newcommand{\foldr}{\mathsf{foldr}}\)
\(\newcommand{\foldl}{\mathsf{foldl}}\)
\(\newcommand{\tacunfoldN}{\mathsf{tacunfoldN}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\dfoldr}{\mathsf{dfoldr}}\)
\(\newcommand{\cfoldr}{\mathsf{cfoldr}}\)
\(\newcommand{\bfoldr}{\mathsf{bfoldr}}\)
\(\newcommand{\dbfoldr}{\mathsf{dbfoldr}}\)
\(\newcommand{\lfoldr}{\mathsf{lfoldr}}\)

<!-- list arithmetic -->
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\revcat}{\mathsf{revcat}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\last}{\mathsf{last}}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\addlength}{\mathsf{addlength}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\addcount}{\mathsf{addcount}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\common}{\mathsf{common}}\)
\(\newcommand{\disjoint}{\mathsf{disjoint}}\)
\(\newcommand{\sublists}{\mathsf{sublists}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
\(\newcommand{\takeBut}{\mathsf{takeBut}}\)
\(\newcommand{\dropBut}{\mathsf{dropBut}}\)
\(\newcommand{\takeWhile}{\mathsf{takeWhile}}\)
\(\newcommand{\dropWhile}{\mathsf{dropWhile}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Flip.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Flip</span> (</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  flip, flip2, flip3, flip4, flip5, _test_flip, main_flip</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Testing</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Functions</span></a></code></pre></div>
<p>It turns out that equational proofs are much simpler to state and verify if we define new functions in the so-called <em>pointfree</em> style. A pointfree function definition is one that does not refer to its arguments explicitly; for example, suppose we have two functions <span class="math inline">\(f : A \rightarrow B\)</span> and <span class="math inline">\(g : B \rightarrow C\)</span>, and have defined a new function <span class="math inline">\(h : A \rightarrow C\)</span> by <span class="math display">\[h(x) = g(f(x)).\]</span> Of course this definition is equivalent to <span class="math display">\[h(x) = \compose(g)(f)(x).\]</span> But now the rightmost argument, <span class="math inline">\(x\)</span>, can be omitted, leaving <span class="math display">\[h = \compose(g)(f).\]</span> This final statement is written in the pointfree style. We’ll see later that definitions will cooperate better with equational reasoning if they are in pointfree form. To make this work, we’ll need a stable of operators for manipulating functions, like <span class="math inline">\(\compose\)</span> in the above example. In all cases the goal will be to move function arguments around; for instance, <span class="math inline">\(\compose\)</span> lets us move a rightmost argument “up” one level of parentheses.</p>
<p>In this post we’ll define a family of operators that rearrange the arguments of a multi-argument function. The first example is <span class="math inline">\(\flip\)</span>, which flips the arguments of a two-argument function.</p>
<div class="definition">
<p><span id="def-flip"></span> Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> be sets. Given <span class="math inline">\(f : A \rightarrow B \rightarrow C\)</span>, we define <span class="math inline">\(\flip(f) : B \rightarrow A \rightarrow C\)</span> by <span class="math display">\[\flip(f)(b)(a) = f(a)(b).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">flip<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">flip f b a <span class="fu">=</span> f a b</a></code></pre></div>
</div>
<p><span class="math inline">\(\flip\)</span> is an involution.</p>
<div class="theorem">
<p><span id="thm-flip-involution"></span> Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> be sets. For all <span class="math inline">\(f : A \rightarrow B \rightarrow C\)</span>, we have <span class="math display">\[\flip(\flip(f)) = f.\]</span></p>
<div class="proof">
<p>Let <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flip(\flip(f))(a)(b) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; \flip(f)(b)(a) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; f(a)(b)
\end{eqnarray*}\]</span> as needed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">_test_flip_involution</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Equal</span> c)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">_test_flip_involution _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  testName <span class="st">&quot;flip(flip(f)) == f&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  \f a b <span class="ot">-&gt;</span> eq (flip (flip f) a b) (f a b)</a></code></pre></div>
</div>
</div>
<p>Ostensibly, <span class="math inline">\(\flip\)</span> acts on functions of two arguments. But since the return type of such a function can be another function, a better way to think of <span class="math inline">\(\flip\)</span> is that it flips the <em>first two</em> arguments of a multi-argument function.</p>
<div class="theorem">
<p><span id="thm-flip-three"></span> Let <span class="math inline">\(f : A \rightarrow B \rightarrow C \rightarrow D\)</span>. Then we have <span class="math display">\[\flip(f)(b)(a)(c)(d) = f(a)(b)(c)(d).\]</span></p>
<div class="proof">
<p>Note that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flip(f)(b)(a)(c) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; f(a)(b)(c)
\end{eqnarray*}\]</span></p>
</div>
<div class="test">
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">_test_flip_3</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Equal</span> d)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">_test_flip_3 _ _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  testName <span class="st">&quot;flip(f)(a)(b)(c) == f(b)(a)(c)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  \f a b c <span class="ot">-&gt;</span> eq (flip f b a c) (f a b c)</a></code></pre></div>
</div>
</div>
<p>Okay- what about more general permutations of function arguments? Let’s start with flipping the second and third.</p>
<div class="definition">
<p><span id="def-flip2"></span> Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, and <span class="math inline">\(D\)</span> be sets. Given <span class="math inline">\(f : A \rightarrow B \rightarrow C \rightarrow D\)</span>, we define <span class="math inline">\(\flipB(f) : A \rightarrow C \rightarrow B \rightarrow D\)</span> by <span class="math display">\[\flipB = \compose(\flip).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">flip2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">flip2 <span class="fu">=</span> compose flip</a></code></pre></div>
</div>
<p>Now <span class="math inline">\(\flipB\)</span> permutes function arguments.</p>
<div class="theorem">
<p><span id="thm-flip2"></span> Let <span class="math inline">\(f : A \rightarrow B \rightarrow C \rightarrow D\)</span>. Then <span class="math display">\[\flipB(f)(a)(c)(b) = f(a)(b)(c).\]</span></p>
<div class="proof">
<p>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flipB(f)(a)(c)(b) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip2}
   = &amp; \compose(\flip)(f)(a)(c)(b) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \flip(f(a))(c)(b) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; f(a)(b)(c)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">_test_flip2</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Equal</span> d)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">_test_flip2 _ _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  testName <span class="st">&quot;flip2(f)(a)(b)(c) == f(a)(c)(b)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  \f a b c <span class="ot">-&gt;</span> eq (flip2 f a c b) (f a b c)</a></code></pre></div>
</div>
</div>
<p>And we can flip the third and fourth arguments.</p>
<div class="definition">
<p><span id="def-flip3"></span> Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, <span class="math inline">\(D\)</span>, and <span class="math inline">\(E\)</span> be sets. We define <span class="math display">\[\flipC : (A \rightarrow B \rightarrow C \rightarrow D \rightarrow E) \rightarrow A \rightarrow B \rightarrow D \rightarrow C \rightarrow E\]</span> by <span class="math display">\[\flipC = \compose(\compose(\flip)).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">flip3 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> e</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">flip3 <span class="fu">=</span> compose (compose flip)</a></code></pre></div>
</div>
<p><span class="math inline">\(\flipC\)</span> does the thing:</p>
<div class="theorem">
<p><span id="thm-flip3"></span> Let <span class="math inline">\(f : A \rightarrow B \rightarrow C \rightarrow D \rightarrow E\)</span>. Then <span class="math display">\[\flipC(f)(a)(b)(d)(c) = f(a)(b)(c)(d).\]</span></p>
<div class="proof">
<p>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flipC(f)(a)(b)(d)(c) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip3}
   = &amp; \compose(\compose(\flip))(f)(a)(b)(d)(c) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\flip)(f(a))(b)(d)(c) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \flip(f(a)(b))(d)(c) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; f(a)(b)(c)(d)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">_test_flip3</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Equal</span> e)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">_test_flip3 _ _ _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  testName <span class="st">&quot;flip3(f)(a)(b)(c)(d) == f(a)(b)(d)(c)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  \f a b c d <span class="ot">-&gt;</span> eq (flip3 f a b d c) (f a b c d)</a></code></pre></div>
</div>
</div>
<p>We’ll look at two more examples, to see the pattern emerging.</p>
<div class="definition">
<p><span id="def-flip4"></span> We define <span class="math inline">\(\flipD : (A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F) \rightarrow A \rightarrow B \rightarrow C \rightarrow E \rightarrow D \rightarrow F\)</span> by <span class="math display">\[\flipD = \compose(\compose(\compose(\flip))).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">flip4</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">flip4 <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  compose (compose (compose flip))</a></code></pre></div>
</div>
<p>And:</p>
<div class="theorem">
<p><span id="thm-flip4"></span> Let <span class="math inline">\(f : A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F\)</span>. Then <span class="math display">\[\flipD(f)(a)(b)(c)(e)(d) = f(a)(b)(c)(d)(e).\]</span></p>
<div class="proof">
<p>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flipD(f)(a)(b)(c)(e)(d) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip4}
   = &amp; \compose(\compose(\compose(\flip)))(f)(a)(b)(c)(e)(d) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\compose(\flip))(f(a))(b)(c)(e)(d) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\flip)(f(a)(b))(c)(e)(d) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \flip(f(a)(b)(c))(e)(d) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; f(a)(b)(c)(d)(e)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">_test_flip4 ::</span> (<span class="dt">Equal</span> f)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">_test_flip4 _ _ _ _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  testName <span class="st">&quot;flip4(f)(a)(b)(c)(d)(e) == f(a)(b)(c)(e)(d)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  \f a b c d e <span class="ot">-&gt;</span> eq (flip4 f a b c e d) (f a b c d e)</a></code></pre></div>
</div>
</div>
<p>One more.</p>
<div class="definition">
<p><span id="def-flip5"></span> We define <span class="math display">\[\flipE : (A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F \rightarrow G) \rightarrow A \rightarrow B \rightarrow C \rightarrow D \rightarrow F \rightarrow E \rightarrow G\]</span> by <span class="math display">\[\flipE = \compose(\compose(\compose(\compose(\flip)))).\]</span></p>
<p>In Haskell:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">flip5</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> g</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">flip5 <span class="fu">=</span> compose (compose (compose (compose flip)))</a></code></pre></div>
</div>
<p>And:</p>
<div class="theorem">
<p><span id="thm-flip5"></span> Let <span class="math inline">\(w : A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F \rightarrow G\)</span>. Then <span class="math display">\[\flipE(w)(a)(b)(c)(d)(f)(e) = w(a)(b)(c)(d)(e)(f).\]</span></p>
<div class="proof">
<p>We have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \flipE(w)(a)(b)(c)(d)(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip5}
   = &amp; \compose(\compose(\compose(\compose(\flip))))(w)(a)(b)(c)(d)(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\compose(\compose(\flip)))(w(a))(b)(c)(d)(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\compose(\flip))(w(a)(b))(c)(d)(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \compose(\flip)(w(a)(b)(c))(d)(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Functions.html#def-compose}
   = &amp; \flip(w(a)(b)(c)(d))(f)(e) \\
 &amp;     \href{/posts/arithmetic-made-difficult/Flip.html#def-flip}
   = &amp; w(a)(b)(c)(d)(e)(f)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
<div class="test">
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">_test_flip5</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Equal</span> g)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Test</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">_test_flip5 _ _ _ _ _ _ _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  testName <span class="st">&quot;flip5(w)(a)(b)(c)(d)(e)(f) == w(a)(b)(c)(d)(f)(e)&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  \w a b c d e f <span class="ot">-&gt;</span> eq (flip5 w a b c d f e) (w a b c d e f)</a></code></pre></div>
</div>
</div>
<p>Well that’s neat. This pattern continues, and we can define an operator that flips the <span class="math inline">\(n\)</span>th and <span class="math inline">\((n+1)\)</span>th argument, for any <span class="math inline">\(n\)</span>, using just <span class="math inline">\(\compose\)</span> and <span class="math inline">\(\flip\)</span>. And it turns out that this is enough to generate arbitrary permutations of the arguments of any function, by composing the flip operators in the right order. We won’t prove this in full generality here (not yet, anyway).</p>
<h2 id="testing">Testing</h2>
<p>Suite:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_test_flip ::</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  ( <span class="dt">Equal</span> a, <span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a, <span class="dt">TypeName</span> a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  , <span class="dt">Equal</span> b, <span class="dt">Show</span> b, <span class="dt">Arbitrary</span> b, <span class="dt">CoArbitrary</span> b, <span class="dt">TypeName</span> b</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  , <span class="dt">Equal</span> c, <span class="dt">Show</span> c, <span class="dt">Arbitrary</span> c, <span class="dt">CoArbitrary</span> c, <span class="dt">TypeName</span> c</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  , <span class="dt">Equal</span> d, <span class="dt">Show</span> d, <span class="dt">Arbitrary</span> d, <span class="dt">CoArbitrary</span> d, <span class="dt">TypeName</span> d</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  , <span class="dt">Equal</span> e, <span class="dt">Show</span> e, <span class="dt">Arbitrary</span> e, <span class="dt">CoArbitrary</span> e, <span class="dt">TypeName</span> e</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  , <span class="dt">Equal</span> f, <span class="dt">Show</span> f, <span class="dt">Arbitrary</span> f, <span class="dt">CoArbitrary</span> f, <span class="dt">TypeName</span> f</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  , <span class="dt">Equal</span> g, <span class="dt">Show</span> g, <span class="dt">Arbitrary</span> g, <span class="dt">CoArbitrary</span> g, <span class="dt">TypeName</span> g</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  ) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">_test_flip size cases a b c d e f g <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  testLabel0 <span class="st">&quot;flip&quot;</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  <span class="kw">let</span> args <span class="fu">=</span> testArgs size cases</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">  runTest args (_test_flip_involution a b c)</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">  runTest args (_test_flip_3 a b c d)</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">  runTest args (_test_flip2 a b c d)</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">  runTest args (_test_flip3 a b c d e)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">  runTest args (_test_flip4 a b c d e f)</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  runTest args (_test_flip5 a b c d e f g)</a></code></pre></div>
<p>Main:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">main_flip ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">main_flip <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  _test_flip <span class="dv">1</span> <span class="dv">1</span> () () () () () () ()</a></code></pre></div>



<!-- END CONTENT -->
</div>

<div id="footer"></div>
</body>
</html>
