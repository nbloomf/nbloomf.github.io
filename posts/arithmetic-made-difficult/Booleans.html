<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.blog - Booleans</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Booleans</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2014-04-01 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/arithmetic-made-difficult.html">arithmetic-made-difficult</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<!-- LaTeX Macros for Arithmetic Made Difficult -->
<div class="invisible">
<!-- basic maps -->
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

<!-- booleans -->
\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{true}}\)
\(\newcommand{\bfalse}{\mathsf{false}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathbin{\mathsf{and}}}\)
\(\newcommand{\bor}{\mathbin{\mathsf{or}}}\)
\(\newcommand{\beq}{\mathsf{eq}}\)
\(\newcommand{\bif}[3]{\mathsf{if}\left(#1,#2,#3\right)}\)

<!-- tuples -->
\(\newcommand{\fst}{\mathsf{first}}\)
\(\newcommand{\snd}{\mathsf{second}}\)
\(\newcommand{\dup}{\mathsf{dup}}\)
\(\newcommand{\swap}{\mathsf{swap}}\)
\(\newcommand{\pair}{\mathsf{pair}}\)
\(\newcommand{\assocL}{\mathsf{assocL}}\)
\(\newcommand{\assocR}{\mathsf{assocR}}\)

<!-- natural numbers -->
\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\iszero}{\mathsf{isZero}}\)
\(\newcommand{\prev}{\mathsf{prev}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\simprec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)
\(\newcommand{\bailrec}[4]{\left(\!\left[ #1, #2, #3, #4 \right]\!\right)}\)
\(\newcommand{\mutrec}[3]{\left\{\!\left[ #1, #2, #3 \right]\!\right\}}\)

<!--- natural number arithmetic ---->
\(\newcommand{\nequal}{\mathsf{eq}}\)
\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\nleq}{\mathsf{leq}}\)
\(\newcommand{\ngeq}{\mathsf{geq}}\)
\(\newcommand{\nminus}{\mathsf{minus}}\)
\(\newcommand{\nmax}{\mathsf{max}}\)
\(\newcommand{\nmin}{\mathsf{min}}\)
\(\newcommand{\ndivalg}{\mathsf{divalg}}\)
\(\newcommand{\nquo}{\mathsf{quo}}\)
\(\newcommand{\nrem}{\mathsf{rem}}\)
\(\newcommand{\ndiv}{\mathsf{div}}\)
\(\newcommand{\ngcd}{\mathsf{gcd}}\)
\(\newcommand{\ncoprime}{\mathsf{coprime}}\)
\(\newcommand{\nlcm}{\mathsf{lcm}}\)
\(\newcommand{\nmindiv}{\mathsf{mindiv}}\)
\(\newcommand{\nisprime}{\mathsf{isPrime}}\)
\(\newcommand{\npower}{\mathsf{power}}\)
\(\newcommand{\nchoose}{\mathsf{choose}}\)

<!-- categories -->
\(\newcommand{\dom}{\mathsf{dom}}\)
\(\newcommand{\cod}{\mathsf{cod}}\)

<!-- list -->
\(\newcommand{\nil}{\mathsf{nil}}\)
\(\newcommand{\cons}{\mathsf{cons}}\)
\(\newcommand{\lists}[1]{\mathsf{List}(#1)}\)
\(\newcommand{\foldr}[2]{\mathsf{foldr}(#1,#2)}\)
\(\newcommand{\uncons}{\mathsf{uncons}}\)
\(\newcommand{\isnil}{\mathsf{isNil}}\)
\(\newcommand{\tail}{\mathsf{tail}}\)
\(\newcommand{\snoc}{\mathsf{snoc}}\)
\(\newcommand{\rev}{\mathsf{rev}}\)
\(\newcommand{\foldl}[2]{\mathsf{foldl}(#1,#2)}\)
\(\newcommand{\cat}{\mathsf{cat}}\)
\(\newcommand{\length}{\mathsf{length}}\)
\(\newcommand{\head}{\mathsf{head}}\)
\(\newcommand{\at}{\mathsf{at}}\)
\(\newcommand{\map}{\mathsf{map}}\)
\(\newcommand{\unfoldN}{\mathsf{unfoldN}}\)
\(\newcommand{\range}{\mathsf{range}}\)
\(\newcommand{\zip}{\mathsf{zip}}\)
\(\newcommand{\zipPad}{\mathsf{zipPad}}\)
\(\newcommand{\unzip}{\mathsf{unzip}}\)
\(\newcommand{\prefix}{\mathsf{prefix}}\)
\(\newcommand{\suffix}{\mathsf{suffix}}\)
\(\newcommand{\lcp}{\mathsf{lcp}}\)
\(\newcommand{\lcs}{\mathsf{lcs}}\)
\(\newcommand{\all}{\mathsf{all}}\)
\(\newcommand{\any}{\mathsf{any}}\)
\(\newcommand{\tails}{\mathsf{tails}}\)
\(\newcommand{\inits}{\mathsf{inits}}\)
\(\newcommand{\filter}{\mathsf{filter}}\)
\(\newcommand{\elt}{\mathsf{elt}}\)
\(\newcommand{\count}{\mathsf{count}}\)
\(\newcommand{\repeat}{\mathsf{repeat}}\)
\(\newcommand{\sublist}{\mathsf{sublist}}\)
\(\newcommand{\infix}{\mathsf{infix}}\)
\(\newcommand{\select}{\mathsf{select}}\)
\(\newcommand{\unique}{\mathsf{unique}}\)
\(\newcommand{\delete}{\mathsf{delete}}\)
\(\newcommand{\dedupeL}{\mathsf{dedupeL}}\)
\(\newcommand{\dedupeR}{\mathsf{dedupeR}}\)
\(\newcommand{\take}{\mathsf{take}}\)
\(\newcommand{\drop}{\mathsf{drop}}\)
</div>
<!-- End LaTeX Macros for Arithmetic Made Difficult -->

<p class="post-info">This page is part of a series on <a href="../../pages/amd.html">Arithmetic Made Difficult</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/arithmetic-made-difficult/Booleans.lhs">the source</a> into GHCi and play along.</p>

<hr />

<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Booleans</span>
<span class="ot">&gt;</span>   ( <span class="dt">Bool</span>(<span class="fu">..</span>), not, and, (<span class="fu">&amp;&amp;&amp;</span>), or, (<span class="fu">|||</span>), ifThenElse
<span class="ot">&gt;</span>   , <span class="dt">Equal</span>, eq, (<span class="fu">====</span>)
<span class="ot">&gt;</span>   , <span class="dt">Test</span>, runTest, testName, testLabel, withTypeOf, <span class="dt">TypeName</span>(<span class="fu">..</span>)
<span class="ot">&gt;</span>   , <span class="dt">Show</span>(<span class="fu">..</span>), <span class="dt">String</span>, (<span class="fu">++</span>), <span class="dt">Int</span>, <span class="dt">IO</span>, <span class="dt">Maybe</span>(<span class="fu">..</span>), (<span class="fu">.</span>), id, (<span class="fu">$</span>)
<span class="ot">&gt;</span>   , _test_boolean, main_boolean
<span class="ot">&gt;</span>   ) <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span>
<span class="ot">&gt;</span>   ( <span class="dt">Show</span>(show), <span class="dt">IO</span>, <span class="dt">Bool</span>(<span class="fu">..</span>), <span class="dt">Int</span>, <span class="dt">Maybe</span>(<span class="fu">..</span>), id
<span class="ot">&gt;</span>   , putStrLn, (<span class="fu">&gt;&gt;</span>), return, (<span class="fu">++</span>), <span class="dt">String</span>, (<span class="fu">.</span>), (<span class="fu">$</span>)
<span class="ot">&gt;</span>   )
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck.Test</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Text.Show.Functions</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Exit</span></code></pre></div>
<p>Before we think about numbers or writing programs, let’s start by nailing down some important functions about truth values. In math there can be a kind of other-worldness about True and False, since they live in the “metalanguage” of mathematical logic rather than the “object language” of whatever we are studying. But it will turn out to be useful to algebraify the truth values themselves.</p>
<div class="result">
<div class="defn">
<p>
We define a set <span class="math inline">\(\bool = \{\btrue,\bfalse\}\)</span>. The elements of <span class="math inline">\(\bool\)</span> are called <em>booleans</em> or <em>truth values</em>.
</p>
</div>
</div>
<p>We can model <span class="math inline">\(\bool\)</span> using the built in Haskell type <code>Bool</code>, which looks something like this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span></code></pre></div>
<p>We can define the usual logical operators <span class="math inline">\(\bnot\)</span>, <span class="math inline">\(\band\)</span>, and <span class="math inline">\(\bor\)</span> like so:</p>
<div class="result">
<div class="defn">
<p>
We define <span class="math inline">\(\bnot : \bool \rightarrow \bool\)</span> by <span class="math display">\[\begin{eqnarray*}
\bnot(\btrue)  &amp; = &amp; \bfalse \\
\bnot(\bfalse) &amp; = &amp; \btrue,
\end{eqnarray*}\]</span> <span class="math inline">\(\band : \bool \times \bool \rightarrow \bool\)</span> by <span class="math display">\[\begin{eqnarray*}
\band(\btrue,\btrue)   &amp; = &amp; \btrue \\
\band(\btrue,\bfalse)  &amp; = &amp; \bfalse \\
\band(\bfalse,\btrue)  &amp; = &amp; \bfalse \\
\band(\bfalse,\bfalse) &amp; = &amp; \bfalse,
\end{eqnarray*}\]</span> and <span class="math inline">\(\bor : \bool \times \bool \rightarrow \bool\)</span> by <span class="math display">\[\begin{eqnarray*}
\bor(\btrue,\btrue)   &amp; = &amp; \btrue \\
\bor(\btrue,\bfalse)  &amp; = &amp; \btrue \\
\bor(\bfalse,\btrue)  &amp; = &amp; \btrue \\
\bor(\bfalse,\bfalse) &amp; = &amp; \bfalse.
\end{eqnarray*}\]</span>
</p>
</div>
</div>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; not ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> not <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> not <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; and ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> and <span class="dt">True</span> <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> and _    _    <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> (<span class="fu">&amp;&amp;&amp;</span>) <span class="fu">=</span> and
<span class="ot">&gt;</span> 
<span class="ot">&gt; or ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> or _     _     <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> (<span class="fu">|||</span>) <span class="fu">=</span> or</code></pre></div>
<p>And <span class="math inline">\(\bnot\)</span>, <span class="math inline">\(\band\)</span>, and <span class="math inline">\(\bor\)</span> satisfy some nice properties.</p>
<div class="result">
<div class="thm">
<p>
<p>The following hold for all <span class="math inline">\(a,b,c \in \bool\)</span>.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\bnot(\bnot(a)) = a\)</span>.</li>
<li><span class="math inline">\(\band(\bfalse,a) = \band(a,\bfalse) = \bfalse\)</span>.</li>
<li><span class="math inline">\(\band(\btrue,a) = \band(a,\btrue) = a\)</span>.</li>
<li><span class="math inline">\(\band(a,a) = a\)</span>.</li>
<li><span class="math inline">\(\band(a,b) = \band(b,a)\)</span>.</li>
<li><span class="math inline">\(\band(\band(a,b),c) = \band(a,\band(b,c))\)</span>.</li>
<li><span class="math inline">\(\bor(\btrue,a) = \bor(a,\btrue) = \btrue\)</span>.</li>
<li><span class="math inline">\(\bor(\bfalse,a) = \bor(a,\bfalse) = a\)</span>.</li>
<li><span class="math inline">\(\bor(a,a) = a\)</span>.</li>
<li><span class="math inline">\(\bor(a,b) = \bor(b,a)\)</span>.</li>
<li><span class="math inline">\(\bor(\bor(a,b),c) = \bor(a,\bor(b,c))\)</span>.</li>
<li><span class="math inline">\(\bnot(\band(a,b)) = \bor(\bnot(a),\bnot(b))\)</span>.</li>
<li><span class="math inline">\(\bnot(\bor(a,b)) = \band(\bnot(a),\bnot(b))\)</span>.</li>
<li><span class="math inline">\(\band(a,\bor(b,c)) = \bor(\band(a,b),\band(a,c))\)</span>.</li>
<li><span class="math inline">\(\bor(a,\band(b,c)) = \band(\bor(a,b),\bor(a,c))\)</span>.</li>
</ol>
</p>
</div>
<div class="proof">
<p>
<ol style="list-style-type: decimal">
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\bnot(\bnot(\btrue)) = \bnot(\bfalse) = \btrue,\]</span> and if <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\bnot(\bnot(\bfalse)) = \bnot(\btrue) = \bfalse\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\band(\bfalse,\btrue) = \bfalse = \band(\btrue,\bfalse),\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\band(\bfalse,\bfalse) = \bfalse\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\band(\btrue,\btrue) = \btrue,\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\band(\btrue,\bfalse) = \bfalse = \band(\bfalse,\btrue)\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\band(\btrue,\btrue) = \btrue,\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\band(\bfalse,\bfalse) = \bfalse\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\band(\btrue,b) = b = \band(b,\btrue),\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\band(\bfalse,b) = \bfalse = \band(b,\bfalse)\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \band(\band(a,b),c) \\
 &amp; = &amp; \band(\band(\btrue,b),c) \\
 &amp; = &amp; \band(b,c) \\
 &amp; = &amp; \band(\btrue,\band(b,c)) \\
 &amp; = &amp; \band(a,\band(b,c))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \band(\band(a,b),c) \\
 &amp; = &amp; \band(\band(\bfalse,b),c) \\
 &amp; = &amp; \band(\bfalse,c) \\
 &amp; = &amp; \bfalse \\
 &amp; = &amp; \band(\bfalse,\band(b,c))
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\bor(\btrue,\btrue) = \btrue,\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\bor(\btrue,\bfalse) = \btrue = \bor(\bfalse,\btrue)\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\bor(\bfalse,\btrue) = \btrue = \bor(\btrue,\bfalse),\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\bor(\bfalse,\bfalse) = \bfalse\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\bor(\btrue,\btrue) = \btrue,\]</span> and if <span class="math inline">\(a = \bfalse\)</span> then <span class="math display">\[\bor(\bfalse,\bfalse) = \bfalse\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\bor(\btrue,b) = \btrue = \bor(b,\btrue),\]</span> and if <span class="math inline">\(a = \bfalse\)</span> we have <span class="math display">\[\bor(\bfalse,b) = b = \bor(b,\bfalse)\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bor(\bor(a,b),c) \\
 &amp; = &amp; \bor(\bor(\btrue,b),c) \\
 &amp; = &amp; \bor(\btrue,c) \\
 &amp; = &amp; \btrue \\
 &amp; = &amp; \bor(\btrue,\bor(b,c))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bor(\bor(a,b),c) \\
 &amp; = &amp; \bor(\bor(\bfalse,b),c) \\
 &amp; = &amp; \bor(b,c) \\
 &amp; = &amp; \bor(\bfalse,\bor(b,c))
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bnot(\band(a,b)) \\
 &amp; = &amp; \bnot(\band(\btrue,b)) \\
 &amp; = &amp; \bnot(b) \\
 &amp; = &amp; \bor(\bfalse,\bnot(b)) \\
 &amp; = &amp; \bor(\bnot(\btrue),\bnot(b)) \\
 &amp; = &amp; \bor(\bnot(a),\bnot(b))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bnot(\band(a,b)) \\
 &amp; = &amp; \bnot(\band(\bfalse,b)) \\
 &amp; = &amp; \bnot(\bfalse) \\
 &amp; = &amp; \btrue \\
 &amp; = &amp; \bor(\btrue,\bnot(b)) \\
 &amp; = &amp; \bor(\bnot(\bfalse),\bnot(b)) \\
 &amp; = &amp; \bor(\bnot(a),\bnot(b))
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bnot(\bor(a,b)) \\
 &amp; = &amp; \bnot(\bor(\btrue,b)) \\
 &amp; = &amp; \bnot(\btrue) \\
 &amp; = &amp; \bfalse \\
 &amp; = &amp; \band(\bfalse,\bnot(b)) \\
 &amp; = &amp; \band(\bnot(\btrue),\bnot(b)) \\
 &amp; = &amp; \band(\bnot(a),\bnot(b))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(b = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bnot(\bor(a,b)) \\
 &amp; = &amp; \bnot(\bor(\bfalse,b)) \\
 &amp; = &amp; \bnot(b) \\
 &amp; = &amp; \band(\btrue,\bnot(b)) \\
 &amp; = &amp; \band(\bnot(\bfalse),\bnot(b)) \\
 &amp; = &amp; \band(\bnot(a),\bnot(b))
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \band(a,\bor(b,c)) \\
 &amp; = &amp; \band(\btrue,\bor(b,c)) \\
 &amp; = &amp; \bor(b,c) \\
 &amp; = &amp; \bor(\band(\btrue,b),\band(\btrue,c)) \\
 &amp; = &amp; \bor(\band(a,b),\band(a,c))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \band(a,\bor(b,c)) \\
 &amp; = &amp; \band(\bfalse,\bor(b,c)) \\
 &amp; = &amp; \bfalse \\
 &amp; = &amp; \bor(\bfalse,\bfalse) \\
 &amp; = &amp; \bor(\band(\bfalse,b),\band(\bfalse,c)) \\
 &amp; = &amp; \bor(\band(a,b),\band(a,c))
\end{eqnarray*}\]</span> as claimed.</li>
<li>If <span class="math inline">\(a = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bor(a,\band(b,c)) \\
 &amp; = &amp; \bor(\btrue,\band(b,c)) \\
 &amp; = &amp; \btrue \\
 &amp; = &amp; \band(\btrue,\btrue) \\
 &amp; = &amp; \band(\bor(\btrue,b),\bor(\btrue,c)) \\
 &amp; = &amp; \band(\bor(a,b),\bor(a,c))
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(a = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bor(a,\band(b,c)) \\
 &amp; = &amp; \bor(\bfalse,\band(b,c)) \\
 &amp; = &amp; \band(b,c) \\
 &amp; = &amp; \band(\bor(\bfalse,b),\bor(\bfalse,c)) \\
 &amp; = &amp; \band(\bor(a,b),\bor(a,c))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</p>
</div>
</div>
<p>Wow, that was tedious! But we only have to do it once. :)</p>
<p>Next we nail down conditional expressions.</p>
<div class="result">
<div class="defn">
<p>
Let <span class="math inline">\(A\)</span> be a set. We define a map <span class="math inline">\(\bif : \bool \times A \times A \rightarrow A\)</span> by <span class="math display">\[\begin{eqnarray*}
\bif{\btrue}{u}{v}  &amp; = &amp; u \\
\bif{\bfalse}{u}{v} &amp; = &amp; v.
\end{eqnarray*}\]</span>
</p>
</div>
</div>
<p>In Haskell:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> ifThenElse <span class="dt">True</span>  x _ <span class="fu">=</span> x
<span class="ot">&gt;</span> ifThenElse <span class="dt">False</span> _ x <span class="fu">=</span> x</code></pre></div>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be sets with <span class="math inline">\(f : A \rightarrow B\)</span> a map. For all <span class="math inline">\(p \in \bool\)</span> and <span class="math inline">\(u,v \in A\)</span>, we have <span class="math display">\[f(\bif{p}{u}{v}) = \bif{p}{f(u)}{f(v)}.\]</span>
</p>
</div>
<div class="proof">
<p>
If <span class="math inline">\(p = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; f(\bif{p}{u}{v}) \\
 &amp; = &amp; f(\bif{\btrue}{u}{v}) \\
 &amp; = &amp; f(u) \\
 &amp; = &amp; \bif{\btrue}{f(u)}{f(v)} \\
 &amp; = &amp; \bif{p}{f(u)}{f(v)}
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(p = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; f(\bif{p}{u}{v}) \\
 &amp; = &amp; f(\bif{\bfalse}{u}{v}) \\
 &amp; = &amp; f(v) \\
 &amp; = &amp; \bif{\bfalse}{f(u)}{f(v)} \\
 &amp; = &amp; \bif{p}{f(u)}{f(v)}
\end{eqnarray*}\]</span> as claimed.
</p>
</div>
</div>
<p>Nested <span class="math inline">\(\bif{\ast}{\ast}{\ast}\)</span>s commute (sort of).</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(p,q \in \bool\)</span> and <span class="math inline">\(a,b,c,d \in A\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{q}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{q}{\bif{p}{a}{c}}{\bif{p}{b}{d}}.
\end{eqnarray*}\]</span>
</p>
</div>
<div class="proof">
<p>
We have four possibilities for <span class="math inline">\((p,q)\)</span>. If <span class="math inline">\(p = \btrue\)</span> and <span class="math inline">\(q = \btrue\)</span>, <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{q}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\btrue}{\bif{\btrue}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\btrue}{a}{b} \\
 &amp; = &amp; a \\
 &amp; = &amp; \bif{\btrue}{a}{c} \\
 &amp; = &amp; \bif{\btrue}{\bif{\btrue}{a}{c}}{\bif{p}{b}{d}} \\
 &amp; = &amp; \bif{q}{\bif{p}{a}{c}}{\bif{p}{b}{d}} \\
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(p = \btrue\)</span> and <span class="math inline">\(q = \bfalse\)</span>, <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{q}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\btrue}{\bif{\bfalse}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\bfalse}{a}{b} \\
 &amp; = &amp; b \\
 &amp; = &amp; \bif{\btrue}{b}{d} \\
 &amp; = &amp; \bif{\bfalse}{\bif{p}{a}{c}}{\bif{\btrue}{b}{d}} \\
 &amp; = &amp; \bif{q}{\bif{p}{a}{c}}{\bif{p}{b}{d}} \\
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(p = \bfalse\)</span> and <span class="math inline">\(q = \btrue\)</span>, <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{q}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\bfalse}{\bif{q}{a}{b}}{\bif{\btrue}{c}{d}} \\
 &amp; = &amp; \bif{\btrue}{c}{d} \\
 &amp; = &amp; c \\
 &amp; = &amp; \bif{\bfalse}{a}{c} \\
 &amp; = &amp; \bif{\btrue}{\bif{\bfalse}{a}{c}}{\bif{p}{b}{d}} \\
 &amp; = &amp; \bif{q}{\bif{p}{a}{c}}{\bif{p}{b}{d}} \\
\end{eqnarray*}\]</span> as claimed. If <span class="math inline">\(p = \bfalse\)</span> and <span class="math inline">\(q = \bfalse\)</span>, <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{q}{a}{b}}{\bif{q}{c}{d}} \\
 &amp; = &amp; \bif{\bfalse}{\bif{q}{a}{b}}{\bif{\bfalse}{c}{d}} \\
 &amp; = &amp; \bif{\bfalse}{c}{d} \\
 &amp; = &amp; d \\
 &amp; = &amp; \bif{\bfalse}{b}{d} \\
 &amp; = &amp; \bif{\bfalse}{\bif{p}{a}{c}}{\bif{\bfalse}{b}{d}} \\
 &amp; = &amp; \bif{q}{\bif{p}{a}{c}}{\bif{p}{b}{d}} \\
\end{eqnarray*}\]</span> as claimed.
</p>
</div>
</div>
<p>More stuff.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(p \in \bool\)</span> and <span class="math inline">\(a,b \in A\)</span>. We have <span class="math display">\[\bif{\bnot(p)}{a}{b} = \bif{p}{b}{a}.\]</span>
</p>
</div>
<div class="proof">
<p>
If <span class="math inline">\(p = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{\bnot(p)}{a}{b} \\
 &amp; = &amp; \bif{\bnot(\btrue)}{a}{b} \\
 &amp; = &amp; \bif{\bfalse}{a}{b} \\
 &amp; = &amp; b \\
 &amp; = &amp; \bif{\btrue}{b}{a} \\
 &amp; = &amp; \bif{p}{b}{a},
\end{eqnarray*}\]</span> and if <span class="math inline">\(p = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{\bnot(p)}{a}{b} \\
 &amp; = &amp; \bif{\bnot(\bfalse)}{a}{b} \\
 &amp; = &amp; \bif{\btrue}{a}{b} \\
 &amp; = &amp; a \\
 &amp; = &amp; \bif{\bfalse}{b}{a} \\
 &amp; = &amp; \bif{p}{b}{a},
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<p>More stuff.</p>
<div class="result">
<div class="thm">
<p>
Let <span class="math inline">\(A\)</span> be a set with <span class="math inline">\(p \in \bool\)</span> and <span class="math inline">\(a,b,c \in A\)</span>. We have <span class="math display">\[\bif{p}{\bif{p}{a}{b}}{c} = \bif{p}{a}{c}.\]</span>
</p>
</div>
<div class="proof">
<p>
If <span class="math inline">\(p = \btrue\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{p}{a}{b}}{c} \\
 &amp; = &amp; \bif{\btrue}{\bif{btrue}{a}{b}}{c} \\
 &amp; = &amp; \bif{\btrue}{a}{b} \\
 &amp; = &amp; a \\
 &amp; = &amp; \bif{\btrue}{a}{c} \\
 &amp; = &amp; \bif{p}{a}{c}
\end{eqnarray*}\]</span> as needed. If <span class="math inline">\(p = \bfalse\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \bif{p}{\bif{p}{a}{b}}{c} \\
 &amp; = &amp; \bif{\bfalse}{\bif{bfalse}{a}{b}}{c} \\
 &amp; = &amp; c \\
 &amp; = &amp; \bif{\bfalse}{a}{c} \\
 &amp; = &amp; \bif{p}{a}{c}
\end{eqnarray*}\]</span> as needed.
</p>
</div>
</div>
<h2 id="equality">Equality</h2>
<p>Now that we’ve algebraified truth values, we will also algebraify equality. Typically I think of equality (as in the <span class="math inline">\(=\)</span> symbol) as a metalanguage expression. Sure, we can define a relation that captures equality on a given set, but really equality is a “logical” thing, not a “mathematical” one. We’ll express this using a type class in Haskell like so.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Equal</span> a <span class="kw">where</span>
<span class="ot">&gt;   eq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- alias</span>
<span class="ot">&gt; (====) ::</span> (<span class="dt">Equal</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> (<span class="fu">====</span>) <span class="fu">=</span> eq
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">====</span></code></pre></div>
<p>(Why not use the built in <code>Eq</code> class? No good reason.) For example, here is the <code>Equal</code> instance for <code>Bool</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Equal</span> <span class="dt">Bool</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   eq <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>   eq <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   eq <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   eq <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Equal</span> a <span class="ot">=&gt;</span> <span class="dt">Equal</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   eq <span class="dt">Nothing</span>  <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>   eq <span class="dt">Nothing</span>  (<span class="dt">Just</span> _) <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   eq (<span class="dt">Just</span> _) <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   eq (<span class="dt">Just</span> x) (<span class="dt">Just</span> y) <span class="fu">=</span> eq x y
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">Equal</span> a, <span class="dt">Equal</span> b) <span class="ot">=&gt;</span> <span class="dt">Equal</span> (a,b) <span class="kw">where</span>
<span class="ot">&gt;</span>   eq (a1,b1) (a2,b2) <span class="fu">=</span> (a1 <span class="fu">====</span> a2) <span class="fu">&amp;&amp;&amp;</span> (b1 <span class="fu">====</span> b2)</code></pre></div>
<h2 id="testing">Testing</h2>
<p>Here are our property tests for <span class="math inline">\(\bnot\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _<span class="ot">test_not_involutive ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_not_involutive <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;not(not(p)) == p&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (not (not p)) <span class="fu">====</span> p</code></pre></div>
<p>Tests for <span class="math inline">\(\band\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _<span class="ot">test_and_false ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_false <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(false,p) == false&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (and <span class="dt">False</span> p) <span class="fu">====</span> <span class="dt">False</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_and_true ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_true <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(true,p) == p&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (and <span class="dt">True</span> p) <span class="fu">====</span> p
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_and_idempotent ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_idempotent <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(p,p) == p&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (and p p) <span class="fu">====</span> p
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_and_commutative ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_commutative <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(p,q) == and(q,p)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q <span class="ot">-&gt;</span> (and p q) <span class="fu">====</span> (and q p)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_and_associative ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_associative <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(and(p,q),r) == and(p,and(q,r))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q r <span class="ot">-&gt;</span> (and (and p q) r) <span class="fu">====</span> (and p (and q r))</code></pre></div>
<p>Tests for <span class="math inline">\(\bor\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _<span class="ot">test_or_true ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_true <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(true,p) == true&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (or <span class="dt">True</span> p) <span class="fu">====</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_or_false ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_false <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(false,p) == p&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (or <span class="dt">False</span> p) <span class="fu">====</span> p
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_or_idempotent ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_idempotent <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(p,p) == p&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p <span class="ot">-&gt;</span> (or p p) <span class="fu">====</span> p
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_or_commutative ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_commutative <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(p,q) == or(q,p)&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q <span class="ot">-&gt;</span> (or p q) <span class="fu">====</span> (or q p)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_or_associative ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_associative <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(or(p,q),r) == or(p,or(q,r))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q r <span class="ot">-&gt;</span> (or (or p q) r) <span class="fu">====</span> (or p (or q r))</code></pre></div>
<p>Tests for more than one function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _<span class="ot">test_not_and ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_not_and <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;not(and(p,q)) == or(not(p),not(q))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q <span class="ot">-&gt;</span> (not (and p q)) <span class="fu">====</span> (or (not p) (not q))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_not_or ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_not_or <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;not(or(p,q)) == and(not(p),not(q))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q <span class="ot">-&gt;</span> (not (or p q)) <span class="fu">====</span> (and (not p) (not q))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_and_or ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_and_or <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;and(p,or(q,r)) == or(and(p,q),and(p,r))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q r <span class="ot">-&gt;</span> (and p (or q r)) <span class="fu">====</span> (or (and p q) (and p r))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> _<span class="ot">test_or_and ::</span> <span class="dt">Test</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span> _test_or_and <span class="fu">=</span>
<span class="ot">&gt;</span>   testName <span class="st">&quot;or(p,and(q,r)) == and(or(p,q),or(p,r))&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   \p q r <span class="ot">-&gt;</span> (or p (and q r)) <span class="fu">====</span> (and (or p q) (or p r))</code></pre></div>
<p>One of our main uses for <code>Bool</code> will be checking the results of tests, so this is as good a place as any to introduce a couple of QuickCheck helper functions for this.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Test</span> prop <span class="fu">=</span> (<span class="dt">String</span>, prop)
<span class="ot">&gt;</span> 
<span class="ot">&gt; testName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">Test</span> prop
<span class="ot">&gt;</span> testName name prop <span class="fu">=</span> (name, prop)
<span class="ot">&gt;</span> 
<span class="ot">&gt; runTest ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Args</span> <span class="ot">-&gt;</span> <span class="dt">Test</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> runTest args (name, prop) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   putStrLn (<span class="st">&quot;\x1b[1;34m&quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)
<span class="ot">&gt;</span>   result <span class="ot">&lt;-</span> quickCheckWithResult args prop
<span class="ot">&gt;</span>   <span class="kw">if</span> isSuccess result
<span class="ot">&gt;</span>     <span class="kw">then</span> return ()
<span class="ot">&gt;</span>     <span class="kw">else</span> putStrLn (show result) <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span> 
<span class="ot">&gt; testLabel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> testLabel msg <span class="fu">=</span> putStrLn (<span class="st">&quot;\n\x1b[1;32m&quot;</span> <span class="fu">++</span> msg <span class="fu">++</span> <span class="st">&quot;\x1b[0;39;49m&quot;</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; withTypeOf ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> withTypeOf x _ <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">TypeName</span> t <span class="kw">where</span>
<span class="ot">&gt;   typeName ::</span> t <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">TypeName</span> <span class="dt">Bool</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   typeName _ <span class="fu">=</span> <span class="st">&quot;Bool&quot;</span></code></pre></div>
<p>And the suite:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- run all tests for booleans</span>
<span class="ot">&gt;</span> _<span class="ot">test_boolean ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> _test_boolean size num <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   testLabel <span class="st">&quot;Bool&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     args <span class="fu">=</span> stdArgs
<span class="ot">&gt;</span>       { maxSuccess <span class="fu">=</span> num
<span class="ot">&gt;</span>       , maxSize <span class="fu">=</span> size
<span class="ot">&gt;</span>       }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args _test_not_involutive
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args _test_and_false
<span class="ot">&gt;</span>   runTest args _test_and_true
<span class="ot">&gt;</span>   runTest args _test_and_idempotent
<span class="ot">&gt;</span>   runTest args _test_and_commutative
<span class="ot">&gt;</span>   runTest args _test_and_associative
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args _test_or_true
<span class="ot">&gt;</span>   runTest args _test_or_false
<span class="ot">&gt;</span>   runTest args _test_or_idempotent
<span class="ot">&gt;</span>   runTest args _test_or_commutative
<span class="ot">&gt;</span>   runTest args _test_or_associative
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   runTest args _test_not_and
<span class="ot">&gt;</span>   runTest args _test_not_or
<span class="ot">&gt;</span>   runTest args _test_and_or
<span class="ot">&gt;</span>   runTest args _test_or_and</code></pre></div>
<p>And <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main_boolean ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main_boolean <span class="fu">=</span> _test_boolean <span class="dv">20</span> <span class="dv">100</span></code></pre></div>



<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
