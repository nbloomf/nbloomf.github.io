<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../about.html">About</a>
    <a href="../contact.html">Contact</a>
    <a href="../archive.html">Posts</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell</h1>
<!-- BEGIN BODY -->
<div class="info">
Posted on 2016-02-10 by nbloomf
</div>

<!-- LaTeX Macros -->
<div class="invisible">
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\primrec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)

\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{t}}\)
\(\newcommand{\bfalse}{\mathsf{f}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathsf{and}}\)
\(\newcommand{\bor}{\mathsf{or}}\)
</div>
<!-- End LaTeX Macros -->

<p><em>Software Tools</em> is a little book about tool building by Brian Kernighan and P. J. Plauger. It’s a classic, and people far more qualified than me have written very positive reviews of it. The book includes several example programs, which are designed individually to solve simple problems and collectively to work together readily to solve larger problems.</p>
<p>I’ve written some small tools for my own use, the largest of which (by far) is the feivel templating language. But I’m not particularly good at it, and would like to improve. So I will be reading through <em>Software Tools</em> and porting the examples to Haskell. Along the way, I expect to supplement the text’s examples with my own tools.</p>
<p>Because I enjoy pain, all of this will be done publicly, with code hosted at <a href="http://github.com/nbloomf/st-haskell">GitHub</a> and narrative documentation posted here.</p>
<h2 id="ground-rules">Ground Rules</h2>
<blockquote>
<p>Okay, let’s party. But first, let’s go over the rules, because what is fun without the rules? <cite>Gru in <em>Despicable Me 2</em></cite></p>
</blockquote>
<p>The purpose of this project is to learn, and so there are some self-imposed rules.</p>
<ol style="list-style-type: decimal">
<li>Reproduce the behavior of the original tools. (Maybe with extensions.) (Note: it turns out that this is more complicated than I thought thanks to unicode.)</li>
<li>Write code which is idiomatic Haskell, but follows the spirit of the originals and doesn’t try to be too clever.</li>
<li>Produce executable programs which interact with my own working environment.</li>
<li>Follow established conventions regarding things like command-line arguments and return codes.</li>
<li>Use standard library functions where possible, unless doing so makes the program a one-liner, thus removing all the fun.</li>
<li>Don’t hesitate to move common code to a library, especially if doing so makes the main program logic more clear. But library functions should be appropriately general to justify this.</li>
<li>Include tests.</li>
</ol>
<p>I will prefix the names of these ports with <code>sth-</code>, to avoid clashing with existing real programs. And of course all should be considered works-in-progress.</p>
<h2 id="the-posts-chrono-order">The Posts (Chrono Order)</h2>
<ul>
<li><a href="../posts/2016-02-11-software-tools-in-haskell-copy-charcount-linecount.html"><code>copy</code>, <code>charcount</code>, <code>linecount</code></a></li>
<li><a href="../posts/2016-02-22-software-tools-in-haskell-glyphcount-wordcount-sentcount.html"><code>glyphcount</code>, <code>wordcount</code>, <code>sentcount</code></a></li>
<li><a href="../posts/2016-02-25-software-tools-in-haskell-detab-charcombine-charfullwidth.html"><code>detab</code>, <code>charcombine</code>, <code>charfullwidth</code></a></li>
<li><a href="../posts/2016-02-27-software-tools-in-haskell-entab-echo-overstrike.html"><code>entab</code>, <code>echo</code>, <code>overstrike</code></a></li>
<li><a href="../posts/2016-02-29-software-tools-in-haskell-unescape-charecho.html"><code>unescape</code>, <code>charecho</code></a></li>
</ul>
<h2 id="the-tools-alpha-order">The Tools (Alpha Order)</h2>
<ul>
<li><a href="../posts/2016-02-25-software-tools-in-haskell-detab-charcombine-charfullwidth.html#charcombine"><code>charcombine</code></a>: replace combining unicode characters with precomposed characters (char filter)</li>
<li><a href="../posts/2016-02-11-software-tools-in-haskell-copy-charcount-linecount.html#charcount"><code>charcount</code></a>: count characters on stdin (char to line)</li>
<li><a href="../posts/2016-02-29-software-tools-in-haskell-unescape-charecho.html#charecho"><code>charecho</code></a>: write arguments to stdout, without trailing newline (char source)</li>
<li><a href="../posts/2016-02-25-software-tools-in-haskell-detab-charcombine-charfullwidth.html#charfullwidth"><code>charfullwidth</code></a>: replace characters with fullwidth equivalents (char filter)</li>
<li><a href="../posts/2016-02-11-software-tools-in-haskell-copy-charcount-linecount.html#copy"><code>copy</code></a>: copy characters from stdin to stdout (char filter)</li>
<li><a href="../posts/2016-02-25-software-tools-in-haskell-detab-charcombine-charfullwidth.html#detab"><code>detab</code></a>: replace tabs on stdin with spaces (line filter)</li>
<li><a href="../posts/2016-02-27-software-tools-in-haskell-entab-echo-overstrike.html#echo"><code>echo</code></a>: write arguments to stdout (line source)</li>
<li><a href="../posts/2016-02-27-software-tools-in-haskell-entab-echo-overstrike.html#entab"><code>entab</code></a>: replace spaces on stdin with tabs (line filter)</li>
<li><a href="../posts/2016-02-22-software-tools-in-haskell-glyphcount-wordcount-sentcount.html#glyphcount"><code>glyphcount</code></a>: count glyphs on stdin (char to line)</li>
<li><a href="../posts/2016-02-11-software-tools-in-haskell-copy-charcount-linecount.html#linecount"><code>linecount</code></a>: count lines on stdin (line filter)</li>
<li><a href="../posts/2016-02-27-software-tools-in-haskell-entab-echo-overstrike.html#overstrike"><code>overstrike</code></a>: interpret backspaces using line printer control codes (line filter)</li>
<li><a href="../posts/2016-02-22-software-tools-in-haskell-glyphcount-wordcount-sentcount.html#sentcount"><code>sentcount</code></a>: count sentences on stdin (char to line)</li>
<li><a href="../posts/2016-02-29-software-tools-in-haskell-unescape-charecho.html#unescape"><code>unescape</code></a>: interpret C and ASCII backslash escape codes on stdin (char filter)</li>
<li><a href="../posts/2016-02-22-software-tools-in-haskell-glyphcount-wordcount-sentcount.html#wordcount"><code>wordcount</code></a>: count words on stdin (char to line)</li>
</ul>
<h2 id="why-haskell">Why Haskell?</h2>
<p>The programs in <em>Software Tools</em> are written in <a href="https://en.wikipedia.org/wiki/Ratfor">Ratfor</a>, a purpose-built extension of Fortran with control-flow statements. (At the time, control flow in Fortran was done by hand with GOTO.) Kernighan and Plauger explain that this was a pragmatic choice, as no language at the time had the right mix of ubiquity and expressiveness. With 40 years(!) of hindsight, though, I’d say that this was an inspired choice. Books written in real languages quickly become hopelessly outdated. But books written in toy languages can focus on timeless principles. <em>TAOCP</em> by Knuth (which I’ve never read) and <em>Functional Programming: Practice and Theory</em> by MacLennan (which I have) are positive examples of this, and I have a shelf full of nameless algebra books written in APL and Pascal to serve as negative examples.</p>
<p>So why Haskell. I work in academia – in math, not in CS – and producing software doesn’t even show up on the list of things I am supposed to do. That means I can use whatever tools and languages I want to. Well, I’ve been using Haskell for several years as a “<a href="www.jsoftware.com/papers/tot.htm">tool of thought</a>”, to paraphrase Ken Iverson, mostly for one-off experiments. Haskell is good for that, and I find that it fits my problem-solving style very well. (Programs are arrows in a category? Of course!) But I want to improve my ability to write “real” programs in the language. So here we are.</p>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
