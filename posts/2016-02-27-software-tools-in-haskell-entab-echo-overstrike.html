<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell: entab, echo, overstrike</title>
<link rel="stylesheet" type="text/css" href="../css/default.css" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../index.html">Home</a>
    <a href="../about.html">About</a>
    <a href="../contact.html">Contact</a>
    <a href="../archive.html">Posts</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: entab, echo, overstrike</h1>
<!-- BEGIN BODY -->
<div class="info">
Posted on 2016-02-27 by nbloomf
</div>

<!-- LaTeX Macros -->
<div class="invisible">
\(\newcommand{\id}{\mathsf{id}}\)
\(\newcommand{\const}{\mathsf{const}}\)

\(\newcommand{\nats}{\mathbb{N}}\)
\(\newcommand{\zero}{\mathsf{0}}\)
\(\newcommand{\next}{\mathsf{next}}\)
\(\newcommand{\natrec}[2]{\left\langle\!\left\vert #1, #2 \right\vert\!\right\rangle}\)
\(\newcommand{\primrec}[2]{\left[\!\left[ #1, #2 \right]\!\right]}\)

\(\newcommand{\nplus}{\mathsf{plus}}\)
\(\newcommand{\ntimes}{\mathsf{times}}\)
\(\newcommand{\npower}{\mathsf{power}}\)

\(\newcommand{\bool}{\mathbb{B}}\)
\(\newcommand{\btrue}{\mathsf{t}}\)
\(\newcommand{\bfalse}{\mathsf{f}}\)
\(\newcommand{\bnot}{\mathsf{not}}\)
\(\newcommand{\band}{\mathsf{and}}\)
\(\newcommand{\bor}{\mathsf{or}}\)
</div>
<!-- End LaTeX Macros -->

<p>This post is part of the <a href="../posts/2016-02-10-software-tools-in-haskell.html">Software Tools in Haskell</a> series.</p>
<p><a name="entab"></a></p>
<h2 id="entab-replace-spaces-on-stdin-with-tabs"><code>entab</code>: replace spaces on stdin with tabs</h2>
<p>The <code>detab</code> program replaced tab characters with spaces, taking arguments at the command line to let the user specify the width of the tab stops. The <code>entab</code> program reverses this process. It takes input which we assume represents some tabular data where different columns start on specific character columns, chops the input lines into columns, and replaces any trailing spaces in a given column by a single <code>\t</code> character. Just like <code>detab</code>, the default tab stop width is 8, and we allow the user to specify a list of tab stop widths at the command line with the convention that the <em>last</em> user-specified width is assumed to repeat indefinitely.</p>
<p>The basic structure of this program is nearly identical to that of <code>detab</code> (which is not surprising).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs, getProgName)
<span class="kw">import </span><span class="dt">System.Exit</span> (exitFailure, exitSuccess)
<span class="kw">import </span><span class="dt">System.IO</span> (hPutStrLn, stderr)
<span class="kw">import </span><span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))
<span class="kw">import </span><span class="dt">SoftwareTools.FunctionLibrary</span>
  (getLines, insertTabStops, readPosIntList)


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  <span class="co">-- Read positive integer tabstop arguments.</span>
  <span class="co">-- Default is [8].</span>
  ts <span class="ot">&lt;-</span> <span class="kw">case</span> readPosIntList args <span class="kw">of</span>
    <span class="dt">Just</span> [] <span class="ot">-&gt;</span> return [<span class="dv">8</span>]
    <span class="dt">Just</span> ks <span class="ot">-&gt;</span> return ks
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> errorParsingArgs

  <span class="co">-- Entab a single line ln with tabstops ts.</span>
  <span class="kw">let</span> entab ln <span class="fu">=</span> <span class="kw">case</span> insertTabStops ts ln <span class="kw">of</span>
                   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> errorDeTabbing ts ln
                   <span class="dt">Just</span> cs <span class="ot">-&gt;</span> putStrLn cs

  <span class="co">-- Do it!</span>
  getContents
    <span class="fu">&gt;&gt;=</span> (getLines <span class="fu">&gt;&gt;&gt;</span> map entab <span class="fu">&gt;&gt;&gt;</span> sequence_)
    <span class="fu">&gt;&gt;</span> exitSuccess</code></pre></div>
<p>We reuse the functions for reading lists of nonnegative integers that we wrote for <code>detab</code>. The heavly lifting is done by <code>insertTabStops</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertTabStops ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
insertTabStops [] xs <span class="fu">=</span> <span class="dt">Just</span> xs
insertTabStops ks xs <span class="fu">=</span> accum [] ks xs
  <span class="kw">where</span>
    accum zs _ <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> concat <span class="fu">$</span> reverse zs
    accum zs [t] ys <span class="fu">=</span> <span class="kw">do</span>
      (as,bs) <span class="ot">&lt;-</span> splitColumn t ys
      accum (as<span class="fu">:</span>zs) [t] bs
    accum zs (t<span class="fu">:</span>ts) ys <span class="fu">=</span> <span class="kw">do</span>
      (as,bs) <span class="ot">&lt;-</span> splitColumn t ys
      accum (as<span class="fu">:</span>zs) ts bs

<span class="ot">    splitColumn ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">String</span>, <span class="dt">String</span>)
    splitColumn k xs
      <span class="fu">|</span> k  <span class="fu">&lt;=</span> <span class="dv">0</span>   <span class="fu">=</span> <span class="dt">Nothing</span>
      <span class="fu">|</span> xs <span class="fu">==</span> <span class="st">&quot;&quot;</span>  <span class="fu">=</span> <span class="dt">Nothing</span>
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
          <span class="kw">let</span> (as,bs) <span class="fu">=</span> splitAt k xs
          <span class="kw">let</span> munch <span class="fu">=</span> dropWhile (<span class="fu">==</span> <span class="ch">' '</span>)
          <span class="kw">let</span> cs <span class="fu">=</span> reverse as
          <span class="kw">let</span> ds <span class="fu">=</span> <span class="kw">if</span> bs <span class="fu">==</span> <span class="st">&quot;&quot;</span>
                     <span class="kw">then</span> <span class="kw">let</span> es <span class="fu">=</span> reverse <span class="fu">$</span> munch cs <span class="kw">in</span>
                       <span class="kw">if</span> es <span class="fu">==</span> <span class="st">&quot;&quot;</span> <span class="kw">then</span> <span class="st">&quot;\t&quot;</span> <span class="kw">else</span> es
                     <span class="kw">else</span> <span class="kw">case</span> cs <span class="kw">of</span>
                       <span class="ch">' '</span><span class="fu">:</span>_ <span class="ot">-&gt;</span> reverse (<span class="ch">'\t'</span><span class="fu">:</span>(munch cs))
                       otherwise <span class="ot">-&gt;</span> as
          <span class="dt">Just</span> (ds,bs)</code></pre></div>
<p>Even the shape of this function on the page resembles that of its counterpart from <code>detab</code>. Note the use of an accumulating parameter helper function.</p>
<p>In Exercise 2-2, Kernighan and Plauger ask us to make the simplest change to <code>entab</code> to make it handle tabs correctly. After thinking about this, I’ve decided the right thing to do is <strong>nothing</strong>. Let’s imagine what it means if the user is trying to use <code>entab</code> on data that contains tabs. I can think of two possible situations.</p>
<ol style="list-style-type: decimal">
<li>The tabs are “semantic tabs”, used to delimit data. That is, the input either is already tab-delimited, or contains a mixture of tab-delimited and column-delimited data. In this case the user has other problems. The right thing to do in the first case is nothing, and in the second case depends on the user’s intent. We could assume that a semantic tab means “advance to the next tab stop”, but this now changes the column indices of the characters in the remainder of the line unpredictably, so the intent of any tab stop width input is unclear. It would be better here to run the data through <code>detab</code> first to remove the tabs, then run through <code>entab</code> to put them back.</li>
<li>The tabs are “literal tabs”, as in the data itself involves tab characters for some reason, and they have a different meaning in whatever context the user cares about. This is, after all, a valid reason to use a column-delimited format. Of course in this case the right thing to do is leave the tabs alone.</li>
</ol>
<p>If we ignore tabs altogether, then at best this is the Right Thing and at worst the user has to use <code>detab</code> first (or has other problems). On the other hand, trying to make <code>entab</code> do something useful with tabs would make the program more complicated (and probably clutter the interface) with little benefit.</p>
<p><a name="echo"></a></p>
<h2 id="echo-write-arguments-to-stdout"><code>echo</code>: write arguments to stdout</h2>
<p>All the programs we’ve written so far are strictly <em>filters</em>: they read data from stdin and write data to stdout. The metaphor here is that small programs are chained together in a larger “pipeline”, and data flows from one end to the other; along the way, each filter changes the data in some way. By reading and writing from stdin and stdout, individual programs do not need to worry about where their data comes from and goes.</p>
<p><code>echo</code> is the first program we’ve written that <em>produces</em> data without needing to take any from stdin; it is a <em>source</em>. (The converse, a program which consumes data without producing any, is a <em>sink</em>). <code>echo</code> simply takes a list of arguments at the command line and writes them to stdout.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">Data.List</span> (unwords)
<span class="kw">import </span><span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> getArgs <span class="fu">&gt;&gt;=</span> (unwords <span class="fu">&gt;&gt;&gt;</span> putStrLn)</code></pre></div>
<p>We can now use <code>echo</code> to test our other programs. For instance, using the shell to run</p>
<pre><code>sth-echo &quot;hello&quot; | sth-charcount</code></pre>
<p>prints <code>6</code> to the terminal. Woo!</p>
<p><a name="overstrike"></a></p>
<h2 id="overstrike-interpret-backspaces-using-line-printer-control-codes"><code>overstrike</code>: interpret backspaces using line printer control codes</h2>
<p>At first I was going to skip this program, because I cannot imagine myself having a use for it. But I started thinking about the problem and before I knew it the program was written, so I might as well write about it. :)</p>
<p>In ASCII (and unicode) there is a backspace control character. This character is only kind of related to the backspace key on a modern keyboard. On a typewriter, the backspace key physically moves the carriage “back” one “space”, without erasing any characters that might already be printed there. This allowed the typist to physically print one character on top of another, called <em>overstriking</em>. Doing so allowed for things like underlining words (overstrike with underscore), striking out words (overstrike with hyphen), creating new characters (overstrike hyphen and colon to get a division sign, maybe), and elaborate typewriter art (a precursor of ASCII art). For example, the literal sequence of key strokes</p>
<pre><code>Hello world!\b\b\b\b\b\b\b\b\b\b\b\b____________</code></pre>
<p>would appear on the page as underlined text.</p>
<p>According to Kernighan and Plauger, line printers (I’ve unfortunately never used one, so I’ll take their word for it) can achieve overstriking by not advancing the paper between lines. On some machines this was done by prepending each line to be printed with a control code: either a space or a plus sign. For instance, the lines</p>
<pre><code> Hello world!
+____________</code></pre>
<p>would be printed one on top of the other, effectively underlining “Hello world!”. A space at the beginning of the line means “advance the paper to the next line”, and a plus sign means “don’t”.</p>
<p>The <code>overstrike</code> program turns a sequence of typewriter-style keystrokes into a sequence of line printer-style print commands. Our strategy is this: every character to be printed has an associated <em>column index</em>; this is the column where that character belongs. For instance, in the line</p>
<pre><code>abcde</code></pre>
<p>The character <code>a</code> has column index 1, <code>b</code> has column index 2, and so on. (That’s right, I think of strings as 1-indexed. What’s it to ya?) Anyway, normally the next character in the string has column index one more than the one before it. Except for those pesky backspace characters! They decrement (by two, really) the column index of everything that comes after them (unless the index is 1, since we cannot print to the left of the left edge of a line). So in the line</p>
<pre><code>abcde\b\b\bfg</code></pre>
<p>the character <code>a</code> has index 1, <code>b</code> is 2, <code>c</code> is 3, <code>d</code> is 4, <code>e</code> is 5, <code>f</code> is <strong>3</strong>, and <code>g</code> is <strong>4</strong>.</p>
<p>The trick is this: we can march down a string and determine the column index of every non-backspace character. This results in a big list of char-int pairs. Now in principle each one of these can be turned into an overstrike line. For instance, the last example could be expressed as</p>
<pre><code> a
+ b
+  c
+   d
+    e
+  f
+   g</code></pre>
<p>But there is a problem here: while correct, having only one printed character per line is extremely inefficient! If two lines do not “overlap”, they can be merged. So a more efficient way to achieve the same effect is with</p>
<pre><code> abcde
+  fg</code></pre>
<p>In fact this is a <em>most</em> efficient set of overstrike lines, since 2 is the minimal number of lines required. It isn’t too hard to see that if a given line has at most <span class="math inline">\(k\)</span> characters with the same column index, then <span class="math inline">\(k\)</span> is the minimum number of overstrike lines required to render that line (and there is always a set of <span class="math inline">\(k\)</span> overstrike lines that works). Why? We can think of this as a graph coloring problem. The char-int pairs are vertices (ignoring those where the character is a blank), and two vertices are adjacent if they have the same column index. Colorings of this graph correspond to valid sets of overstrike lines. But this graph is a disjoint union of complete graphs, with one component for each column index. The minimum number of colors required is the size of the largest component.</p>
<p>To identify a coloring of the char-int graph, we (1) drop all the blanks, (2) sort the list by column index, and (3) split the list into maximal subsequences by column index. (What?) Finally, (4) thinking of these char-int pairs as sparse lists, convert to real actual lists, using space characters for any missing indices.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">overstrikeLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
overstrikeLines <span class="fu">=</span>
  columnIndices
    <span class="fu">&gt;&gt;&gt;</span> filter (\(c,_) <span class="ot">-&gt;</span> c <span class="fu">/=</span> <span class="ch">' '</span>)          <span class="co">-- try omitting</span>
    <span class="fu">&gt;&gt;&gt;</span> sortBy (\(_,a) (_,b) <span class="ot">-&gt;</span> compare a b) <span class="co">-- these lines</span>
    <span class="fu">&gt;&gt;&gt;</span> maxMonoSubseqsBy p
    <span class="fu">&gt;&gt;&gt;</span> map (fromSparseList <span class="ch">' '</span>)
  <span class="kw">where</span>
    p u v <span class="fu">=</span> <span class="kw">if</span> snd u <span class="fu">&lt;</span> snd v
              <span class="kw">then</span> <span class="dt">True</span> <span class="kw">else</span> <span class="dt">False</span>

    <span class="co">-- Assign a column index </span>
<span class="ot">    columnIndices ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">Char</span>,<span class="dt">Int</span>)]
    columnIndices <span class="fu">=</span> accum [] <span class="dv">1</span>
      <span class="kw">where</span>
        accum zs _ <span class="st">&quot;&quot;</span>     <span class="fu">=</span> reverse zs
        accum zs k (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="kw">case</span> c <span class="kw">of</span>
          <span class="ch">'\b'</span>      <span class="ot">-&gt;</span> accum zs (max <span class="dv">1</span> (k<span class="fu">-</span><span class="dv">1</span>)) cs
          otherwise <span class="ot">-&gt;</span> accum ((c,k)<span class="fu">:</span>zs) (k<span class="fu">+</span><span class="dv">1</span>) cs

<span class="ot">maxMonoSubseqsBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
maxMonoSubseqsBy p <span class="fu">=</span> unfoldr maxMonoSubseq
  <span class="kw">where</span>
    maxMonoSubseq [] <span class="fu">=</span> <span class="dt">Nothing</span>
    maxMonoSubseq xs <span class="fu">=</span> accum [] [] xs

    accum as bs [] <span class="fu">=</span> <span class="dt">Just</span> (reverse as, reverse bs)
    accum [] bs (z<span class="fu">:</span>zs) <span class="fu">=</span> accum [z] bs zs
    accum (a<span class="fu">:</span>as) bs (z<span class="fu">:</span>zs) <span class="fu">=</span> <span class="kw">if</span> p a z
      <span class="kw">then</span> accum (z<span class="fu">:</span>a<span class="fu">:</span>as) bs zs
      <span class="kw">else</span> accum (a<span class="fu">:</span>as) (z<span class="fu">:</span>bs) zs

<span class="ot">fromSparseList ::</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Int</span>)] <span class="ot">-&gt;</span> [a]
fromSparseList x [] <span class="fu">=</span> []
fromSparseList x ys <span class="fu">=</span> accum <span class="dv">1</span> [] ys
  <span class="kw">where</span>
    accum _ as [] <span class="fu">=</span> reverse as
    accum t as ((z,h)<span class="fu">:</span>zs) <span class="fu">=</span> <span class="kw">case</span> compare t h <span class="kw">of</span>
      <span class="dt">EQ</span> <span class="ot">-&gt;</span> accum (t<span class="fu">+</span><span class="dv">1</span>) (z<span class="fu">:</span>as) zs
      <span class="dt">LT</span> <span class="ot">-&gt;</span> accum (t<span class="fu">+</span><span class="dv">1</span>) (x<span class="fu">:</span>as) ((z,h)<span class="fu">:</span>zs)
      <span class="dt">GT</span> <span class="ot">-&gt;</span> accum (t<span class="fu">+</span><span class="dv">1</span>) as zs</code></pre></div>
<p>As an aside: I pulled out <code>maxMonoSubseqsBy</code> and <code>fromSparseList</code> as abstractly as possible. When writing Haskell (this is probably true in other languages as well) writing code with the most general possible type usually makes it <strong>easier</strong> to write. Working with a less specific type means there are fewer meaningful things to say, and when there are fewer paths to choose from the correct one is easier to find. This code, for instance, was nearly written in one pass with no substantial editing needed. Not because I am particularly good but because <strong>there’s essentially only one way to do it</strong>. Pick a type signature and a recursion pattern (here, either <code>unfoldr</code> or accumulating parameter) and the rest practically writes itself.</p>
<p>After all that, the main program is pretty straightforward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))
<span class="kw">import </span><span class="dt">SoftwareTools.FunctionLibrary</span> (getLines, overstrikeLines)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> overstrike <span class="fu">=</span> overstrikeLines
                     <span class="fu">&gt;&gt;&gt;</span> zipWith (<span class="fu">:</span>) (<span class="ch">' '</span> <span class="fu">:</span> (repeat <span class="ch">'+'</span>))
                     <span class="fu">&gt;&gt;&gt;</span> map putStrLn
                     <span class="fu">&gt;&gt;&gt;</span> sequence_

  getContents
    <span class="fu">&gt;&gt;=</span> (getLines <span class="fu">&gt;&gt;&gt;</span> map overstrike <span class="fu">&gt;&gt;&gt;</span> sequence_)</code></pre></div>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
