<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>nbloomf.blog - Tensors</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Tensors</h1>
<!-- BEGIN BODY -->


<div class="info">
Posted on 2017-10-14 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/ml.html">ml</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<p class="post-info">This post is part of a series of notes on <a href="../../pages/ml.html">machine learning</a>.</p>

<p class="post-info">This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/ml/Tensors.lhs">the source</a> into GHCi and play along.</p>

<hr />

<p>First some boilerplate.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Tensors</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Array</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.PrettyPrint</span> <span class="kw">as</span> <span class="dt">PP</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Indices</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">IndexIsos</span></a></code></pre></div>
<p><a href="../../posts/ml/Indices.html">Earlier</a>, we defined two algebras whose elements represent the possible sizes of multidimensional arrays and possible indices into multidimensional arrays, respectively. We did this in such a way that the possible indices into an array with (vector space) dimension <span class="math inline">\(k\)</span> can be mapped to <span class="math inline">\(\{0,1, \ldots, k-1\}\)</span> in a canonical way. With this in hand, we can define a <em>tensor</em> of size <span class="math inline">\(s \in \mathbb{S}\)</span> as a mapping from the indices of <span class="math inline">\(s\)</span> to <span class="math inline">\(\mathbb{R}\)</span>. And thanks to the canonical mapping to integers, we can implement our tensors in memory using a linear array. In math notation, we will identify each <span class="math inline">\(s \in \mathbb{S}\)</span> with its indices, and think of tensors as elements of <span class="math inline">\(\mathbb{R}^s\)</span> (that is, functions from indices to real numbers).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tensor</span> r <span class="fu">=</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> size ::</span> <span class="dt">Size</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> elts ::</span> (<span class="dt">Array</span> <span class="dt">Integer</span> r)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  }</a></code></pre></div>
<p>We’ll say that two tensors are <em>strictly equal</em>, denoted <code>$==</code>, if they have the same sizes and the same entries at each index.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">($==) ::</span> (<span class="dt">Eq</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">a<span class="fu">@</span>(<span class="dt">T</span> u x) <span class="fu">$==</span> b<span class="fu">@</span>(<span class="dt">T</span> v y) <span class="fu">=</span> (u <span class="fu">==</span> v) <span class="fu">&amp;&amp;</span> (x <span class="fu">==</span> y)</a></code></pre></div>
<p>(Strict equality is too, well, <em>strict</em>. We’ll nail down the real equality on tensors in a moment.)</p>
<p>A tensor “is” a map from indices to <span class="math inline">\(\mathbb{R}\)</span>s. The <code>tensor</code> function lets us build a tensor by supplying this map.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">tensor ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">tensor s f <span class="fu">=</span> <span class="dt">T</span> s (array (<span class="dv">0</span>,(dimOf s)<span class="fu">-</span><span class="dv">1</span>) entries)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    entries <span class="fu">=</span> [(flatten s t, f t) <span class="fu">|</span> t <span class="ot">&lt;-</span> indicesOf s]</a></code></pre></div>
<p>To retrieve the entry of a tensor at a given index, we evaluate the tensor as a function. We’ll call this <code>at</code>. So in math notation, we’d write <span class="math inline">\(\mathsf{at}(A,i) = A(i)\)</span> or <span class="math inline">\(A_i\)</span>.</p>
<p>We’re actually going to define two slightly different versions of <code>at</code>. The first works only on nonzero sizes, but for all entry types. The second treats the size zero vector as if it has entry 0 at every possible index, but of course only makes sense for numeric entry types. (Looking ahead, there’s a good reason for doing this, having to do with dual numbers and automatic differentiation.)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">at' ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">at' (<span class="dt">T</span> s a) t <span class="fu">=</span> <span class="kw">if</span> t <span class="ot">`isIndexOf`</span> s</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">then</span> a <span class="fu">!</span> (flatten s t)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">else</span> error <span class="fu">$</span> <span class="st">&quot;at: incompatible index &quot;</span> <span class="fu">++</span> show t</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="fu">++</span> <span class="st">&quot; for size &quot;</span> <span class="fu">++</span> show s</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">at ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">at a t <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="kw">if</span> (size a) <span class="fu">~=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="kw">then</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="kw">else</span> a <span class="ot">`at'`</span> t</a></code></pre></div>
<p>So <code>tensor</code> and <code>at</code> obey the following identities:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">==</span> tensor u (\i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">(tensor u f) <span class="ot">`at`</span> i <span class="fu">==</span> f i</a></code></pre></div>
<p>We’ll also define some helper functions to make building tensors more convenient. For instance, a <em>uniform</em> tensor has the same value at each index.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">uniform ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">uniform s x <span class="fu">=</span> tensor s (\_ <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">ones,<span class="ot"> zeros ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">ones s <span class="fu">=</span> uniform s <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">zeros s <span class="fu">=</span> uniform s <span class="dv">0</span></a></code></pre></div>
<p>We’ll use the notation <span class="math inline">\(\mathsf{Zero}_s\)</span> to denote the zero tensor of size <span class="math inline">\(s\)</span>.</p>
<p>We can use <code>at</code> and the canonical isomorphism on index sets to define equality for tensors.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Eq</span> r) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Tensor</span> r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">==</span> b<span class="fu">@</span>(<span class="dt">T</span> v _) <span class="fu">=</span> <span class="kw">if</span> u <span class="fu">~=</span> v</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="kw">then</span> all (\i <span class="ot">-&gt;</span> (a<span class="ot">`at'`</span>i) <span class="fu">==</span> (b<span class="ot">`at'`</span>(mapIndex u v i))) (indicesOf u)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">else</span> <span class="dt">False</span></a></code></pre></div>
<p>We’ll see the reason for this weak equality in a bit. But for now, note that the following two tensors are <em>equal</em>, but not <em>strictly equal</em>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">x <span class="fu">=</span> ones (<span class="dv">2</span><span class="fu">*</span>(<span class="dv">2</span><span class="fu">*</span><span class="dv">2</span>))<span class="ot"> ::</span> <span class="dt">Tensor</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">y <span class="fu">=</span> ones ((<span class="dv">2</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Tensor</span> <span class="dt">Int</span></a></code></pre></div>
<p>More generally, strict equality implies equality, but not vice versa.</p>
<p>The simplest possible (nontrivial) tensor has size 1; we will call these <em>cells</em>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">cell ::</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">cell r <span class="fu">=</span> tensor <span class="dv">1</span> (\_ <span class="ot">-&gt;</span> r)</a></code></pre></div>
<p>We’ll also provide a simple way to construct vectors and matrices with natural number size.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">vec ::</span> [r] <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">vec xs <span class="fu">=</span> tensor k (\(<span class="dt">Index</span> i) <span class="ot">-&gt;</span> xs <span class="fu">!!</span> (fromIntegral i))</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    k <span class="fu">=</span> <span class="dt">Size</span> <span class="fu">$</span> fromIntegral <span class="fu">$</span> length xs</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">mat ::</span> [[r]] <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">mat []   <span class="fu">=</span> tensor <span class="dv">0</span> (const undefined)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">mat [[]] <span class="fu">=</span> tensor <span class="dv">0</span> (const undefined)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">mat xss  <span class="fu">=</span> tensor (r <span class="fu">:*</span> c) <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  \((<span class="dt">Index</span> i) <span class="fu">:&amp;</span> (<span class="dt">Index</span> j))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    <span class="ot">-&gt;</span> (xss <span class="fu">!!</span> (fromIntegral i)) <span class="fu">!!</span> (fromIntegral j)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    r <span class="fu">=</span> <span class="dt">Size</span> <span class="fu">$</span> fromIntegral <span class="fu">$</span> length xss</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    c <span class="fu">=</span> <span class="dt">Size</span> <span class="fu">$</span> fromIntegral <span class="fu">$</span> length <span class="fu">$</span> head xss</a></code></pre></div>
<p>The downside of defining our tensors recursively is that it’s less clear what the index of a given entry is. To help out with this, we’ll define two helpers: <code>indexOf</code>, that defines a tensor of a given size whose entries are equal to their indices, and <code>orderOf</code>, that shows how the entries of a tensor are linearized internally.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">indexOf ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Tensor</span> <span class="dt">Index</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">indexOf s <span class="fu">=</span> tensor s id</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">orderOf ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Tensor</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">orderOf s <span class="fu">=</span> tensor s (flatten s)</a></code></pre></div>
<p>This works because we can pass <code>tensor</code> <em>any</em> function on indices. For example, here are three different views of a size <span class="math inline">\(3 \otimes 3\)</span> tensor.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">$&gt;</span> ones (<span class="dv">3</span><span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="fu">$&gt;</span> indexOf (<span class="dv">3</span><span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">(<span class="dv">0</span>,<span class="dv">0</span>) (<span class="dv">0</span>,<span class="dv">1</span>) (<span class="dv">0</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">(<span class="dv">1</span>,<span class="dv">0</span>) (<span class="dv">1</span>,<span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">(<span class="dv">2</span>,<span class="dv">0</span>) (<span class="dv">2</span>,<span class="dv">1</span>) (<span class="dv">2</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="fu">$&gt;</span> orderOf (<span class="dv">3</span><span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="dv">0</span> <span class="dv">3</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="dv">1</span> <span class="dv">4</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"><span class="dv">2</span> <span class="dv">5</span> <span class="dv">8</span></a></code></pre></div>
<p>Try using <code>indexOf</code> on more complicated sizes.</p>
<h2 id="tensor-as-a-functor">Tensor as a Functor</h2>
<p>One of the first questions we ask about type constructors is whether they are naturally members of any interesting classes. It’s not too surprising that <code>Tensor</code> is a functor, where <code>fmap</code> is “pointwise” function application.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tensor</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  fmap f a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">=</span> tensor u (\i <span class="ot">-&gt;</span> f (a<span class="ot">`at'`</span>i))</a></code></pre></div>
<p>To verify the functor laws, we make sure that <code>fmap id == id</code>. (Remember that <code>$==</code> means strict equality.)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">    fmap id a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="fu">$==</span> fmap id a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="fu">$==</span> tensor u (\i <span class="ot">-&gt;</span> id (a<span class="ot">`at`</span>i))</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="fu">$==</span> tensor u (\i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="fu">$==</span> a</a></code></pre></div>
<p>and that <code>fmap (g . f) == fmap g . fmap f</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">    fmap g (fmap f a)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="fu">$==</span> fmap g (fmap f a<span class="fu">@</span>(<span class="dt">T</span> u _))</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="fu">$==</span> fmap g (tensor u (\i <span class="ot">-&gt;</span> f (a<span class="ot">`at`</span>i)))</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="fu">$==</span> tensor u (\i <span class="ot">-&gt;</span> g ((tensor u (\j <span class="ot">-&gt;</span> f (a<span class="ot">`at`</span>j))) <span class="ot">`at`</span> i))</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="fu">$==</span> tensor u (\i <span class="ot">-&gt;</span> g (f (a<span class="ot">`at`</span>i)))</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="fu">$==</span> tensor u (\i <span class="ot">-&gt;</span> (g <span class="fu">.</span> f) (a<span class="ot">`at`</span>i))</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="fu">$==</span> fmap (g <span class="fu">.</span> f) a</a></code></pre></div>
<p>We can also define a <code>Foldable</code> instance for tensors, using the canonical order on indices.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tensor</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  foldMap f a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="fu">=</span> foldMap f [ a<span class="ot">`at'`</span>i <span class="fu">|</span> i <span class="ot">&lt;-</span> indicesOf u ]</a></code></pre></div>
<p>From here we can immediately take the <code>sum</code> and <code>maximum</code> of a tensor. We’ll also define a kind of <code>zip</code> for tensors of equivalent size; I had trouble finding a good general class for zippable functors in the libraries.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">tzip ::</span> <span class="dt">Tensor</span> a <span class="ot">-&gt;</span> <span class="dt">Tensor</span> b <span class="ot">-&gt;</span> <span class="dt">Tensor</span> (a,b)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">tzip a<span class="fu">@</span>(<span class="dt">T</span> u _) b<span class="fu">@</span>(<span class="dt">T</span> v _) <span class="fu">=</span> <span class="kw">if</span> u <span class="fu">~=</span> v</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">then</span> tensor u (\i <span class="ot">-&gt;</span> (a<span class="ot">`at'`</span>i, b<span class="ot">`at'`</span>(mapIndex u v i)))</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">else</span> error <span class="st">&quot;zip: tensors must have equivalent size&quot;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">tzipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Tensor</span> a <span class="ot">-&gt;</span> <span class="dt">Tensor</span> b <span class="ot">-&gt;</span> <span class="dt">Tensor</span> c</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">tzipWith f a b <span class="fu">=</span> fmap (uncurry f) <span class="fu">$</span> tzip a b</a></code></pre></div>
<p><code>Tensor</code> is also applicative. (Making this work is the main motivation for defining equality the way we did.)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Tensor</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  pure <span class="fu">=</span> cell</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;*&gt;</span> b<span class="fu">@</span>(<span class="dt">T</span> v _) <span class="fu">=</span> tensor (u <span class="fu">:*</span> v) <span class="fu">$</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    \(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> (a <span class="ot">`at'`</span> i) (b <span class="ot">`at'`</span> j)</a></code></pre></div>
<p>We need to see that this implementation satisfies the applicative laws. First the identity law:</p>
<p><code>pure id &lt;*&gt; a == a</code> for all <code>a</code></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">    pure id <span class="fu">&lt;*&gt;</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="fu">$==</span> cell id <span class="fu">&lt;*&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="fu">$==</span> (tensor <span class="dv">1</span> (const id)) <span class="fu">&lt;*&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="fu">$==</span> tensor (<span class="dv">1</span> <span class="fu">:*</span> u) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> id (a<span class="ot">`at`</span>j))</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="fu">$==</span> tensor (<span class="dv">1</span> <span class="fu">:*</span> u) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> a<span class="ot">`at`</span>j)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"> <span class="fu">==</span> tensor u (\j <span class="ot">-&gt;</span> a<span class="ot">`at`</span>j)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fu">$==</span> a</a></code></pre></div>
<p>Next we establish the composition law:</p>
<p><code>pure (.) &lt;*&gt; a &lt;*&gt; b &lt;*&gt; c == a &lt;*&gt; (b &lt;*&gt; c)</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">    pure (<span class="fu">.</span>) <span class="fu">&lt;*&gt;</span> a <span class="fu">&lt;*&gt;</span> b <span class="fu">&lt;*&gt;</span> c</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="fu">$==</span> tensor <span class="dv">1</span> (const (<span class="fu">.</span>)) <span class="fu">&lt;*&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;*&gt;</span> b <span class="fu">&lt;*&gt;</span> c</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="fu">$==</span> tensor (<span class="dv">1</span> <span class="fu">:*</span> u) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> (<span class="fu">.</span>) (a<span class="ot">`at`</span>j))</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">      <span class="fu">&lt;*&gt;</span> b<span class="fu">@</span>(<span class="dt">T</span> v _) <span class="fu">&lt;*&gt;</span> c</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="fu">$==</span> tensor ((<span class="dv">1</span> <span class="fu">:*</span> u) <span class="fu">:*</span> v)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      (\((i <span class="fu">:&amp;</span> j) <span class="fu">:&amp;</span> k) <span class="ot">-&gt;</span> (a<span class="ot">`at`</span>j) <span class="fu">.</span> (b<span class="ot">`at`</span>k))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      <span class="fu">&lt;*&gt;</span> c<span class="fu">@</span>(<span class="dt">T</span> w _)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="fu">$==</span> tensor (((<span class="dv">1</span> <span class="fu">:*</span> u) <span class="fu">:*</span> v) <span class="fu">:*</span> w)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      (\(((i <span class="fu">:&amp;</span> j) <span class="fu">:&amp;</span> k) <span class="fu">:&amp;</span> l) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">        (a<span class="ot">`at`</span>j) <span class="fu">.</span> (b<span class="ot">`at`</span>k) <span class="fu">$</span> (c<span class="ot">`at`</span>l))</a>
<a class="sourceLine" id="cb21-11" data-line-number="11"> <span class="fu">==</span> tensor (u <span class="fu">:*</span> (v <span class="fu">:*</span> w))</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">      (\(j <span class="fu">:&amp;</span> (k <span class="fu">:&amp;</span> l)) <span class="ot">-&gt;</span> (a<span class="ot">`at`</span>j) <span class="fu">$</span> (b<span class="ot">`at`</span>k) (c<span class="ot">`at`</span>l))</a>
<a class="sourceLine" id="cb21-13" data-line-number="13"><span class="fu">$==</span> a <span class="fu">&lt;*&gt;</span> tensor (v <span class="fu">:*</span> w) (\(k <span class="fu">:&amp;</span> l) <span class="ot">-&gt;</span> (b<span class="ot">`at`</span>k) (c<span class="ot">`at`</span>l))</a>
<a class="sourceLine" id="cb21-14" data-line-number="14"><span class="fu">$==</span> a <span class="fu">&lt;*&gt;</span> (b <span class="fu">&lt;*&gt;</span> c)</a></code></pre></div>
<p>The homomorphism law:</p>
<p><code>pure f &lt;*&gt; pure x == pure (f x)</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">    pure f <span class="fu">&lt;*&gt;</span> pure x</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="fu">$==</span> tensor <span class="dv">1</span> (const f) <span class="fu">&lt;*&gt;</span> tensor <span class="dv">1</span> (const x)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="fu">$==</span> tensor (<span class="dv">1</span> <span class="fu">:*</span> <span class="dv">1</span>) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> f x)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"> <span class="fu">==</span> tensor <span class="dv">1</span> (\_ <span class="ot">-&gt;</span> f x)</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="fu">$==</span> pure (f x)</a></code></pre></div>
<p>And the interchange law:</p>
<p><code>a &lt;*&gt; pure x = pure ($ x) &lt;*&gt; a</code></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">    a <span class="fu">&lt;*&gt;</span> pure x</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="fu">$==</span> a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;*&gt;</span> tensor <span class="dv">1</span> (const x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="fu">$==</span> tensor (u <span class="fu">:*</span> <span class="dv">1</span>) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> (a<span class="ot">`at`</span>i) x)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"> <span class="fu">==</span> tensor (<span class="dv">1</span> <span class="fu">:*</span> u) (\(j <span class="fu">:&amp;</span> i) <span class="ot">-&gt;</span> (<span class="fu">$</span> x) (a<span class="ot">`at`</span>i))</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="fu">$==</span> tensor <span class="dv">1</span> (const (<span class="fu">$</span> x)) <span class="fu">&lt;*&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="fu">$==</span> pure (<span class="fu">$</span> x) <span class="fu">&lt;*&gt;</span> a</a></code></pre></div>
<p>It may seem like overkill to go to the trouble of defining equality the way we did just to make <code>Tensor</code> an applicative functor, and it is – we won’t need the applicativeness much. But there’s a payoff: the outer product of tensors is defined in terms of <code>&lt;*&gt;</code>.</p>
<p>While we’re at it, <code>Tensor</code> is also <code>Alternative</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Tensor</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  empty <span class="fu">=</span> tensor <span class="dv">0</span> (\_ <span class="ot">-&gt;</span> undefined)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;|&gt;</span> b<span class="fu">@</span>(<span class="dt">T</span> v _) <span class="fu">=</span> tensor (u <span class="fu">:+</span> v) <span class="fu">$</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    \<span class="kw">case</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">      <span class="dt">L</span> i <span class="ot">-&gt;</span> a <span class="ot">`at'`</span> i</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">      <span class="dt">R</span> j <span class="ot">-&gt;</span> b <span class="ot">`at'`</span> j</a></code></pre></div>
<p>We should also verify the <code>Alternative</code> laws. First the monoid laws that everyone agrees <code>Alternatives</code> should satisfy. Left identity:</p>
<p><code>empty &lt;|&gt; a == a</code></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">    empty <span class="fu">&lt;|&gt;</span> a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="fu">$==</span> tensor <span class="dv">0</span> (const undefined) <span class="fu">&lt;|&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="fu">$==</span> tensor (<span class="dv">0</span> <span class="fu">:+</span> u) (\<span class="kw">case</span> <span class="dt">L</span> i <span class="ot">-&gt;</span> undefined; <span class="dt">R</span> j <span class="ot">-&gt;</span> a<span class="ot">`at`</span>j)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"> <span class="fu">==</span> tensor u (\j <span class="ot">-&gt;</span> a<span class="ot">`at`</span>j)</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="fu">$==</span> a</a></code></pre></div>
<p>Right identity:</p>
<p><code>a &lt;|&gt; empty == a</code></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">    a <span class="fu">&lt;|&gt;</span> empty</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="fu">$==</span> a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;|&gt;</span> tensor <span class="dv">0</span> (const undefined)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="fu">$==</span> tensor (u <span class="fu">:+</span> <span class="dv">0</span>) (\<span class="kw">case</span> <span class="dt">L</span> i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i; <span class="dt">R</span> j <span class="ot">-&gt;</span> undefined)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"> <span class="fu">==</span> tensor u (\i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="fu">$==</span> a</a></code></pre></div>
<p>Associativity:</p>
<p><code>(a &lt;|&gt; b) &lt;|&gt; c == a &lt;|&gt; (b &lt;|&gt; c)</code></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">    (a <span class="fu">&lt;|&gt;</span> b) <span class="fu">&lt;|&gt;</span> c</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="fu">$==</span> (a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;|&gt;</span> b<span class="fu">@</span>(<span class="dt">T</span> v _)) <span class="fu">&lt;|&gt;</span> c</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="fu">$==</span> (tensor (u <span class="fu">:+</span> v)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">        <span class="dt">L</span> i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">        <span class="dt">R</span> j <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      )) <span class="fu">&lt;|&gt;</span> c<span class="fu">@</span>(<span class="dt">T</span> w _)</a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="fu">$==</span> tensor ((u <span class="fu">:+</span> v) <span class="fu">:+</span> w)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">        <span class="dt">L</span> l <span class="ot">-&gt;</span> <span class="kw">case</span> l <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11">          <span class="dt">L</span> i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">          <span class="dt">R</span> j <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">        <span class="dt">R</span> k <span class="ot">-&gt;</span> c<span class="ot">`at`</span>k)</a>
<a class="sourceLine" id="cb27-14" data-line-number="14"><span class="fu">$==</span> tensor ((u <span class="fu">:+</span> v) <span class="fu">:+</span> w)</a>
<a class="sourceLine" id="cb27-15" data-line-number="15">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-16" data-line-number="16">        <span class="dt">L</span> (<span class="dt">L</span> i) <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">        <span class="dt">L</span> (<span class="dt">R</span> j) <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-18" data-line-number="18">        <span class="dt">R</span> k <span class="ot">-&gt;</span> c<span class="ot">`at`</span>k)</a>
<a class="sourceLine" id="cb27-19" data-line-number="19"> <span class="fu">==</span> tensor (u <span class="fu">:+</span> (v <span class="fu">:+</span> w))</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-21" data-line-number="21">        <span class="dt">L</span> i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">        <span class="dt">R</span> (<span class="dt">L</span> j) <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-23" data-line-number="23">        <span class="dt">R</span> (<span class="dt">R</span> k) <span class="ot">-&gt;</span> c<span class="ot">`at`</span>k)</a>
<a class="sourceLine" id="cb27-24" data-line-number="24"><span class="fu">$==</span> tensor (u <span class="fu">:+</span> (v <span class="fu">:+</span> w))</a>
<a class="sourceLine" id="cb27-25" data-line-number="25">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-26" data-line-number="26">        <span class="dt">L</span> i <span class="ot">-&gt;</span> a<span class="ot">`at`</span>i</a>
<a class="sourceLine" id="cb27-27" data-line-number="27">        <span class="dt">R</span> l <span class="ot">-&gt;</span> <span class="kw">case</span> l <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-28" data-line-number="28">          <span class="dt">L</span> j <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-29" data-line-number="29">          <span class="dt">R</span> k <span class="ot">-&gt;</span> c<span class="ot">`at`</span>k))</a>
<a class="sourceLine" id="cb27-30" data-line-number="30"><span class="fu">$==</span> a <span class="fu">&lt;|&gt;</span> tensor (v <span class="fu">:+</span> w)</a>
<a class="sourceLine" id="cb27-31" data-line-number="31">      (\<span class="kw">case</span></a>
<a class="sourceLine" id="cb27-32" data-line-number="32">        <span class="dt">L</span> j <span class="ot">-&gt;</span> b<span class="ot">`at`</span>j</a>
<a class="sourceLine" id="cb27-33" data-line-number="33">        <span class="dt">R</span> m <span class="ot">-&gt;</span> c<span class="ot">`at`</span>m)</a>
<a class="sourceLine" id="cb27-34" data-line-number="34"><span class="fu">$==</span> a <span class="fu">&lt;|&gt;</span> (b <span class="fu">&lt;|&gt;</span> c)</a></code></pre></div>
<p>And some of the laws that only hold for some <code>Applicative</code> instances (including this one). Left zero:</p>
<p><code>empty &lt;*&gt; a == empty</code></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">    empty <span class="fu">&lt;*&gt;</span> a</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="fu">$==</span> tensor <span class="dv">0</span> (const undefined) <span class="fu">&lt;*&gt;</span> a<span class="fu">@</span>(<span class="dt">T</span> u _)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="fu">$==</span> tensor (<span class="dv">0</span> <span class="fu">:*</span> u) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> undefined (a <span class="ot">`at`</span> j))</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"> <span class="fu">==</span> tensor <span class="dv">0</span> (\_ <span class="ot">-&gt;</span> undefined)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5"><span class="fu">$==</span> empty</a></code></pre></div>
<p>Right zero:</p>
<p><code>a &lt;*&gt; empty == empty</code></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">    a <span class="fu">&lt;*&gt;</span> empty</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="fu">$==</span> a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;*&gt;</span> tensor <span class="dv">0</span> (const undefined)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="fu">$==</span> tensor (u <span class="fu">:*</span> <span class="dv">0</span>) (\(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> (a<span class="ot">`at`</span>i) undefined)</a>
<a class="sourceLine" id="cb29-4" data-line-number="4"> <span class="fu">==</span> tensor <span class="dv">0</span> (\_ <span class="ot">-&gt;</span> undefined)</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="fu">$==</span> empty</a></code></pre></div>
<h2 id="vector-arithmetic">Vector Arithmetic</h2>
<p>Tensors are vectors, so they should have the usual vector operations of plus, negate, and scale. Other vector spaces will show up later, so we’ll define these operations with a class.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Vector</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">  (.@) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> t r <span class="ot">-&gt;</span> t r</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="ot">  (.+) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> t r <span class="ot">-&gt;</span> t r <span class="ot">-&gt;</span> t r</a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="ot">  neg ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> t r <span class="ot">-&gt;</span> t r</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="ot">  (.-) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> t r <span class="ot">-&gt;</span> t r <span class="ot">-&gt;</span> t r</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  a <span class="fu">.-</span> b <span class="fu">=</span> a <span class="fu">.+</span> (neg b)</a>
<a class="sourceLine" id="cb30-8" data-line-number="8"></a>
<a class="sourceLine" id="cb30-9" data-line-number="9"><span class="ot">  vsum ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> [t r] <span class="ot">-&gt;</span> t r</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">  vsum <span class="fu">=</span> foldr1 (<span class="fu">.+</span>)</a>
<a class="sourceLine" id="cb30-11" data-line-number="11"></a>
<a class="sourceLine" id="cb30-12" data-line-number="12"></a>
<a class="sourceLine" id="cb30-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">Vector</span> <span class="dt">Tensor</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-14" data-line-number="14">  r <span class="fu">.@</span> a <span class="fu">=</span> fmap (r<span class="fu">*</span>) a</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16">  a <span class="fu">.+</span> b</a>
<a class="sourceLine" id="cb30-17" data-line-number="17">    <span class="fu">|</span> size a <span class="fu">~=</span> <span class="dv">0</span> <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">    <span class="fu">|</span> size b <span class="fu">~=</span> <span class="dv">0</span> <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    <span class="fu">|</span> otherwise   <span class="fu">=</span> tzipWith (<span class="fu">+</span>) a b</a>
<a class="sourceLine" id="cb30-20" data-line-number="20"></a>
<a class="sourceLine" id="cb30-21" data-line-number="21">  neg <span class="fu">=</span> fmap negate</a></code></pre></div>
<p>The Hadamard or entrywise product is also handy. While we’re at it, entrywise quotients.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">(.*) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">(<span class="fu">.*</span>) <span class="fu">=</span> tzipWith (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3"></a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="ot">(./) ::</span> (<span class="dt">Num</span> r, <span class="dt">Fractional</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">(<span class="fu">./</span>) <span class="fu">=</span> tzipWith (<span class="fu">/</span>)</a></code></pre></div>
<p>Thinking of tensors as vectors, we can dot them together in the usual way.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">dot ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">dot a b <span class="fu">=</span> sum <span class="fu">$</span> a <span class="fu">.*</span> b</a></code></pre></div>
<p>In math notation, if <span class="math inline">\(A,B \in \mathbb{R}^s\)</span>, <span class="math display">\[\mathsf{dot}(A,B) = \sum_{i \in s} A_i B_i.\]</span> The ‘dot square’ of a tensor will also be handy later.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">normSquared ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">normSquared a <span class="fu">=</span> dot a a</a></code></pre></div>
<p>We also have some tensor-centric operations. First is <code>oplus</code>, which constructs a tensor with sum shape.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">oplus, (⊕)<span class="ot"> ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">oplus <span class="fu">=</span> (<span class="fu">&lt;|&gt;</span>)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3"></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">(⊕) <span class="fu">=</span> oplus</a></code></pre></div>
<p>In a rough and handwavy way, if <span class="math inline">\(a \in \mathbb{R}^u\)</span> and <span class="math inline">\(b \in \mathbb{R}^v\)</span>, then <span class="math display">\[a \oplus b \in \mathbb{R}^u \oplus \mathbb{R}^v \cong \mathbb{R}^{u \oplus v},\]</span> and <span class="math inline">\(\oplus\)</span> is the operator that achieves this isomorphism.</p>
<p>This function <code>otimes</code> is called the <em>dyadic</em> or <em>outer product</em>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">otimes, (⊗)<span class="ot"> ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">otimes <span class="fu">=</span> liftA2 (<span class="fu">*</span>) <span class="co">-- omg</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">(⊗) <span class="fu">=</span> otimes</a></code></pre></div>
<h2 id="structural-arithmetic">Structural Arithmetic</h2>
<p>Now we’ll define some structural operators on tensors; these are functions that manipulate the size of a tensor, or combine tensors into more complicated ones, or extract subparts. These are mostly based on <code>extract</code>, which defines a new tensor in terms of an existing one.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">extract ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Index</span>) <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">extract u f a <span class="fu">=</span> tensor u (\i <span class="ot">-&gt;</span> a <span class="ot">`at'`</span> (f i))</a></code></pre></div>
<p>For example, we can extract “terms” from a summand tensor using <code>extract</code> like so.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1">termL,<span class="ot"> termR ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">termL a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:+</span> _) _) <span class="fu">=</span> extract u <span class="dt">L</span> a</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">termL _ <span class="fu">=</span> error <span class="st">&quot;termL: argument must have sum shape&quot;</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5"></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">termR a<span class="fu">@</span>(<span class="dt">T</span> (_ <span class="fu">:+</span> v) _) <span class="fu">=</span> extract v <span class="dt">R</span> a</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">termR _ <span class="fu">=</span> error <span class="st">&quot;termR: argument must have sum shape&quot;</span></a></code></pre></div>
<p>In math notation we have <span class="math inline">\(\mathsf{termL} : \mathbb{R}^{s \oplus t} \rightarrow \mathbb{R}^s\)</span> given by <span class="math inline">\(\mathsf{termL}(A)_i = A_{\mathsf{l}(i)}\)</span>, and <span class="math inline">\(\mathsf{termR}\)</span> is similar.</p>
<p>Next we have projection operators, which take a tensor in <span class="math inline">\(\mathbb{R}^{s \otimes t}\)</span> and fix one of the index components. In the usual matrix language, projection would extract one row or one column of a matrix. There are two of these, with the following signature.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">projR,<span class="ot"> projL ::</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">projR i a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> v) _) <span class="fu">=</span> <span class="kw">if</span> (i <span class="ot">`isIndexOf`</span> u)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">  <span class="kw">then</span> extract v (i <span class="fu">:&amp;</span>) a</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="kw">else</span> error <span class="st">&quot;projR: index and size not compatible.&quot;</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6">projR _ _ <span class="fu">=</span> error <span class="st">&quot;projR: tensor argument must have product shape&quot;</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8">projL j a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> v) _) <span class="fu">=</span> <span class="kw">if</span> (j <span class="ot">`isIndexOf`</span> v)</a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="kw">then</span> extract u (<span class="fu">:&amp;</span> j) a</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">  <span class="kw">else</span> error <span class="st">&quot;projL: index and size not compatible.&quot;</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">projL _ _ <span class="fu">=</span> error <span class="st">&quot;projL: tensor argument must have product shape&quot;</span></a></code></pre></div>
<p>In math notation we have <span class="math inline">\(\mathsf{projR} : s \rightarrow \mathbb{R}^{t \otimes s} \rightarrow \mathbb{R}^t\)</span> given by <span class="math inline">\(\mathsf{projL}(i,A)_j = A_{i \&amp; j}\)</span>, and <span class="math inline">\(\mathsf{projL}\)</span> is similar.</p>
<p>Now <span class="math inline">\(\mathbb{R}^{u \otimes v}\)</span> and <span class="math inline">\(\mathbb{R}^{v \otimes u}\)</span> are not equal, but they are canonically isomorphic; likewise <span class="math inline">\(\mathbb{R}^{u \oplus v}\)</span> and <span class="math inline">\(\mathbb{R}^{v \oplus u}\)</span>. <code>comm</code> achieves this.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">comm ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">comm a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> v) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  extract (v <span class="fu">:*</span> u) f a</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">    f (j <span class="fu">:&amp;</span> i) <span class="fu">=</span> (i <span class="fu">:&amp;</span> j)</a>
<a class="sourceLine" id="cb39-7" data-line-number="7"></a>
<a class="sourceLine" id="cb39-8" data-line-number="8">comm a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:+</span> v) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-9" data-line-number="9">  extract (v <span class="fu">:+</span> u) (opIndex <span class="dt">PlusComm</span>) a</a>
<a class="sourceLine" id="cb39-10" data-line-number="10"></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">comm _ <span class="fu">=</span> error <span class="st">&quot;comm: wrong shape&quot;</span></a></code></pre></div>
<p>Similarly, <span class="math inline">\(\mathbb{R}^{u \otimes (v \otimes w)}\)</span> and <span class="math inline">\(\mathbb{R}^{(u \otimes v) \otimes w}\)</span> are canonically isomorphic, and likewise for <span class="math inline">\(\oplus\)</span>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">assocL,<span class="ot"> assocR ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">assocL a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> (v <span class="fu">:*</span> w)) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">  extract ((u <span class="fu">:*</span> v) <span class="fu">:*</span> w) (opIndex <span class="dt">TimesAssocR</span>) a</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6">assocL a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:+</span> (v <span class="fu">:+</span> w)) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">  extract ((u <span class="fu">:+</span> v) <span class="fu">:+</span> w) (opIndex <span class="dt">PlusAssocR</span>) a</a>
<a class="sourceLine" id="cb40-8" data-line-number="8"></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">assocL _ <span class="fu">=</span> error <span class="st">&quot;assocL: argument has wrong shape&quot;</span></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"></a>
<a class="sourceLine" id="cb40-12" data-line-number="12">assocR a<span class="fu">@</span>(<span class="dt">T</span> ((u <span class="fu">:*</span> v) <span class="fu">:*</span> w) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-13" data-line-number="13">  extract (u <span class="fu">:*</span> (v <span class="fu">:*</span> w)) (opIndex <span class="dt">TimesAssocL</span>) a</a>
<a class="sourceLine" id="cb40-14" data-line-number="14"></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">assocR a<span class="fu">@</span>(<span class="dt">T</span> ((u <span class="fu">:+</span> v) <span class="fu">:+</span> w) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">  extract (u <span class="fu">:+</span> (v <span class="fu">:+</span> w)) (opIndex <span class="dt">PlusAssocL</span>) a</a>
<a class="sourceLine" id="cb40-17" data-line-number="17"></a>
<a class="sourceLine" id="cb40-18" data-line-number="18">assocR _ <span class="fu">=</span> error <span class="st">&quot;assocR: argument has wrong shape&quot;</span></a></code></pre></div>
<p>We also have <span class="math display">\[\mathbb{R}^{(a \otimes b) \oplus (a \otimes c)} \cong \mathbb{R}^{a \otimes b} \times \mathbb{R}^{a \otimes c}.\]</span> We’ll define a couple of operators to canonically “undistribute” <span class="math inline">\(\otimes\)</span> over <span class="math inline">\(\oplus\)</span>.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1">vcat,<span class="ot"> (~-~) ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">vcat a<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> h) _) b<span class="fu">@</span>(<span class="dt">T</span> (v <span class="fu">:*</span> k) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">  <span class="kw">if</span> h <span class="fu">==</span> k</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">    <span class="kw">then</span> extract ((u <span class="fu">:+</span> v) <span class="fu">:*</span> k) (opIndex <span class="dt">DistR</span>) (oplus a b)</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">    <span class="kw">else</span> error <span class="st">&quot;vcat: size mismatch&quot;</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">vcat a b <span class="fu">=</span> error <span class="fu">$</span> <span class="st">&quot;vcat: sizes with wrong shape: &quot;</span> <span class="fu">++</span> show (size a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  <span class="fu">++</span> <span class="st">&quot; and &quot;</span> <span class="fu">++</span> show (size b)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">(<span class="fu">~-~</span>) <span class="fu">=</span> vcat</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"></a>
<a class="sourceLine" id="cb41-12" data-line-number="12">hcat,<span class="ot"> (~|~) ::</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">hcat a<span class="fu">@</span>(<span class="dt">T</span> (h <span class="fu">:*</span> u) _) b<span class="fu">@</span>(<span class="dt">T</span> (k <span class="fu">:*</span> v) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">  <span class="kw">if</span> h <span class="fu">==</span> k</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">    <span class="kw">then</span> extract (k <span class="fu">:*</span> (u <span class="fu">:+</span> v)) (opIndex <span class="dt">DistL</span>) (oplus a b)</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">    <span class="kw">else</span> error <span class="st">&quot;hcat: size mismatch&quot;</span></a>
<a class="sourceLine" id="cb41-17" data-line-number="17"></a>
<a class="sourceLine" id="cb41-18" data-line-number="18">(<span class="fu">~|~</span>) <span class="fu">=</span> hcat</a></code></pre></div>
<p>We give <code>vcat</code> and <code>hcat</code> symbolic synonyms, meant to evoke what they do on matrices. <code>vcat</code> concatenates matrices vertically, and <code>hcat</code> concatenates them horizontally.</p>
<h2 id="matrix-operations">Matrix Operations</h2>
<p>Now for a couple of matrix-specific operations. First the identity matrix.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">idMat ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">idMat n <span class="fu">=</span> tensor (n <span class="fu">:*</span> n) (\ (i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> kronecker i j)</a></code></pre></div>
<p>where <code>kronecker</code> representes the Kronecker delta function <span class="math display">\[\delta_{i,j} = \left\{ \begin{array}{ll} 1 &amp; \mathrm{if}\ i = j \\ 0 &amp; \mathrm{otherwise}. \end{array} \right.\]</span></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">kronecker ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> r) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">kronecker x y <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> y <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a></code></pre></div>
<p>And we can “diagonalize” any tensor.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">diag ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">diag a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">=</span> tensor (u <span class="fu">:*</span> u) <span class="fu">$</span></a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  \(i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> (kronecker i j) <span class="fu">*</span> (a<span class="ot">`at`</span>i)</a></code></pre></div>
<p>The tensor generalization of matrix multiplication is sometimes called <em>contraction</em>. We’ll mostly be interested in plain matrix multiplication. We’ll define it as a matrix-matrix operation, a matrix-vector operation, and a vector-matrix operation using slightly different symbols. Surely this won’t come back to haunt us.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="ot">(***) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb45-2" data-line-number="2">a<span class="fu">@</span>(<span class="dt">T</span> (m <span class="fu">:*</span> n) _) <span class="fu">***</span> b<span class="fu">@</span>(<span class="dt">T</span> (u <span class="fu">:*</span> v) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">  <span class="kw">if</span> u <span class="fu">==</span> n</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">    <span class="kw">then</span> tensor (m<span class="fu">*</span>v)</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">      (\ (i <span class="fu">:&amp;</span> j) <span class="ot">-&gt;</span> sum</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">        [ (a<span class="ot">`at`</span>(i <span class="fu">:&amp;</span> k))<span class="fu">*</span>(b<span class="ot">`at`</span>(k <span class="fu">:&amp;</span> j)) <span class="fu">|</span> k <span class="ot">&lt;-</span> indicesOf n ])</a>
<a class="sourceLine" id="cb45-7" data-line-number="7">    <span class="kw">else</span> error <span class="st">&quot;(***): inner sizes must match.&quot;</span></a>
<a class="sourceLine" id="cb45-8" data-line-number="8">_ <span class="fu">***</span> _ <span class="fu">=</span> error <span class="st">&quot;(***): expected mat/mat.&quot;</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9"></a>
<a class="sourceLine" id="cb45-10" data-line-number="10"><span class="ot">(**&gt;) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb45-11" data-line-number="11">a<span class="fu">@</span>(<span class="dt">T</span> (m <span class="fu">:*</span> n) _) <span class="fu">**&gt;</span> b<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-12" data-line-number="12">  <span class="kw">if</span> u <span class="fu">==</span> n</a>
<a class="sourceLine" id="cb45-13" data-line-number="13">    <span class="kw">then</span> tensor m</a>
<a class="sourceLine" id="cb45-14" data-line-number="14">      (\i <span class="ot">-&gt;</span> sum</a>
<a class="sourceLine" id="cb45-15" data-line-number="15">        [ (a<span class="ot">`at`</span>(i <span class="fu">:&amp;</span> k))<span class="fu">*</span>(b<span class="ot">`at`</span>k) <span class="fu">|</span> k <span class="ot">&lt;-</span> indicesOf n ])</a>
<a class="sourceLine" id="cb45-16" data-line-number="16">    <span class="kw">else</span> error <span class="st">&quot;(**&gt;): inner sizes must match.&quot;</span></a>
<a class="sourceLine" id="cb45-17" data-line-number="17">_ <span class="fu">**&gt;</span> _ <span class="fu">=</span> error <span class="st">&quot;(**&gt;): expected mat/vec.&quot;</span></a>
<a class="sourceLine" id="cb45-18" data-line-number="18"></a>
<a class="sourceLine" id="cb45-19" data-line-number="19"><span class="ot">(&lt;**) ::</span> (<span class="dt">Num</span> r) <span class="ot">=&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r <span class="ot">-&gt;</span> <span class="dt">Tensor</span> r</a>
<a class="sourceLine" id="cb45-20" data-line-number="20">a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">&lt;**</span> b<span class="fu">@</span>(<span class="dt">T</span> (n <span class="fu">:*</span> m) _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-21" data-line-number="21">  <span class="kw">if</span> u <span class="fu">==</span> n</a>
<a class="sourceLine" id="cb45-22" data-line-number="22">    <span class="kw">then</span> tensor m</a>
<a class="sourceLine" id="cb45-23" data-line-number="23">      (\i <span class="ot">-&gt;</span> sum</a>
<a class="sourceLine" id="cb45-24" data-line-number="24">        [ (a<span class="ot">`at`</span>k)<span class="fu">*</span>(b<span class="ot">`at`</span>(k <span class="fu">:&amp;</span> i)) <span class="fu">|</span> k <span class="ot">&lt;-</span> indicesOf n ])</a>
<a class="sourceLine" id="cb45-25" data-line-number="25">    <span class="kw">else</span> error <span class="st">&quot;(&lt;**): inner sizes must match.&quot;</span></a>
<a class="sourceLine" id="cb45-26" data-line-number="26">_ <span class="fu">&lt;**</span> _ <span class="fu">=</span> error <span class="st">&quot;(&lt;**): expected vec/mat.&quot;</span></a></code></pre></div>
<h2 id="pretty-printing">Pretty Printing</h2>
<p>We’ll end this post with the <code>Show</code> instance for tensors; we’ll build it on top of the pretty printing <a href="https://hackage.haskell.org/package/pretty-1.1.3.5">combinator library</a> by John Hughes and Simon Peyton Jones. (The original <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777">paper</a> on that library is a nice case study in DSL design.)</p>
<p>First we convert a tensor of strings to a <code>Doc</code> (in the pretty printer parlance), doing more or less the obvious thing.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">toDoc ::</span> <span class="dt">Tensor</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">toDoc a<span class="fu">@</span>(<span class="dt">T</span> s _) <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">    <span class="dt">Size</span> k <span class="ot">-&gt;</span> PP.hsep <span class="fu">$</span> map PP.text [ a<span class="ot">`at'`</span>i <span class="fu">|</span> i <span class="ot">&lt;-</span> indicesOf s ]</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">    u <span class="fu">:+</span> v <span class="ot">-&gt;</span> (toDoc <span class="fu">$</span> termL a) <span class="fu">PP.$$</span> (toDoc <span class="fu">$</span> termR a)</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">    u <span class="fu">:*</span> v <span class="ot">-&gt;</span> PP.vcat [</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">                PP.hsep [</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">                  PP.text <span class="fu">$</span> a <span class="ot">`at'`</span> (i <span class="fu">:&amp;</span> j)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">                <span class="fu">|</span> j <span class="ot">&lt;-</span> indicesOf v ]</a>
<a class="sourceLine" id="cb46-10" data-line-number="10">              <span class="fu">|</span> i <span class="ot">&lt;-</span> indicesOf u ]</a></code></pre></div>
<p>To actually show the tensor, we show the entries (pointwise) and pad to the maximum entry width (so the cells line up), then show the corresponding <code>Doc</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Show</span> r) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Tensor</span> r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">  show a <span class="fu">=</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb47-4" data-line-number="4">      cellWidth <span class="fu">=</span> maximum <span class="fu">$</span> fmap (length <span class="fu">.</span> show) a</a>
<a class="sourceLine" id="cb47-5" data-line-number="5">      m <span class="fu">=</span> fmap (padLeft cellWidth <span class="fu">.</span> show) a</a>
<a class="sourceLine" id="cb47-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">      PP.render <span class="fu">$</span> toDoc m</a>
<a class="sourceLine" id="cb47-8" data-line-number="8">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">      <span class="co">-- left-pad a string with spaces to a given length</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="ot">      padLeft ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11">      padLeft k <span class="fu">=</span> reverse <span class="fu">.</span> take k <span class="fu">.</span> (<span class="fu">++</span> (repeat <span class="ch">' '</span>)) <span class="fu">.</span> reverse</a></code></pre></div>
<p>This method for displaying tensors is not perfect, but it has the advantage of being simple and doing mostly the right thing in the most common cases of <span class="math inline">\(k\)</span> and <span class="math inline">\(m \otimes n\)</span> tensors (i.e. vectors and matrices). Apropos of nothing: further support for this method is that tensors with shape <span class="math inline">\(k_1 \oplus k_2 \oplus \cdots \oplus k_n\)</span> look like <a href="https://en.wikipedia.org/wiki/Young_tableau">Young tableaux</a>.</p>
<h2 id="tests">Tests</h2>
<p>In future posts we’ll be writing tests involving tensors, so I’ll put an <code>Arbitrary</code> instance here.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Arbitrary</span> r) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tensor</span> r) <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2">  arbitrary <span class="fu">=</span> arbitrary <span class="fu">&gt;&gt;=</span> (arbTensorOf undefined)</a>
<a class="sourceLine" id="cb48-3" data-line-number="3"></a>
<a class="sourceLine" id="cb48-4" data-line-number="4">  shrink a<span class="fu">@</span>(<span class="dt">T</span> u _) <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">    <span class="dt">Size</span> k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-6" data-line-number="6">      <span class="kw">if</span> k <span class="fu">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">        <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb48-8" data-line-number="8">        <span class="kw">else</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9">          [ tensor (<span class="dt">Size</span> <span class="fu">$</span> k<span class="fu">-</span><span class="dv">1</span>) (\i <span class="ot">-&gt;</span> a<span class="ot">`at'`</span>i)</a>
<a class="sourceLine" id="cb48-10" data-line-number="10">          , uniform (<span class="dt">Size</span> <span class="fu">$</span> k<span class="fu">-</span><span class="dv">1</span>) (a<span class="ot">`at'`</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb48-11" data-line-number="11">          ]</a>
<a class="sourceLine" id="cb48-12" data-line-number="12"></a>
<a class="sourceLine" id="cb48-13" data-line-number="13">    _ <span class="fu">:+</span> _ <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb48-14" data-line-number="14">      [ [ h <span class="fu">&lt;|&gt;</span> k <span class="fu">|</span> h <span class="ot">&lt;-</span> shrink <span class="fu">$</span> termL a, k <span class="ot">&lt;-</span> shrink <span class="fu">$</span> termR a ]</a>
<a class="sourceLine" id="cb48-15" data-line-number="15">      , [ termL a, termR a ]</a>
<a class="sourceLine" id="cb48-16" data-line-number="16">      ]</a>
<a class="sourceLine" id="cb48-17" data-line-number="17"></a>
<a class="sourceLine" id="cb48-18" data-line-number="18">    _ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb48-19" data-line-number="19"></a>
<a class="sourceLine" id="cb48-20" data-line-number="20"><span class="ot">arbTensorOf ::</span> (<span class="dt">Arbitrary</span> r) <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Tensor</span> r)</a>
<a class="sourceLine" id="cb48-21" data-line-number="21">arbTensorOf _ s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb48-22" data-line-number="22">  as <span class="ot">&lt;-</span> vectorOf (fromIntegral <span class="fu">$</span> dimOf s) arbitrary</a>
<a class="sourceLine" id="cb48-23" data-line-number="23">  return <span class="fu">$</span> tensor s (\i <span class="ot">-&gt;</span> as <span class="fu">!!</span> (fromIntegral <span class="fu">$</span> flatten s i))</a>
<a class="sourceLine" id="cb48-24" data-line-number="24"></a>
<a class="sourceLine" id="cb48-25" data-line-number="25"><span class="ot">arbBinaryTensorOf ::</span> (<span class="dt">Arbitrary</span> r, <span class="dt">Num</span> r) <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Tensor</span> r)</a>
<a class="sourceLine" id="cb48-26" data-line-number="26">arbBinaryTensorOf _ s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb48-27" data-line-number="27">  as <span class="ot">&lt;-</span> vectorOf (fromIntegral <span class="fu">$</span> dimOf s) <span class="fu">$</span> elements [<span class="dv">0</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb48-28" data-line-number="28">  return <span class="fu">$</span> tensor s (\i <span class="ot">-&gt;</span> as <span class="fu">!!</span> (fromIntegral <span class="fu">$</span> flatten s i))</a></code></pre></div>



<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
