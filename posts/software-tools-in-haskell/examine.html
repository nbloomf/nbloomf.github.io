<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.blog - Software Tools in Haskell: examine</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../pages/contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: examine</h1>
<!-- BEGIN BODY -->
<h2>interactively view a file</h2>

<div class="info">
Posted on 2016-03-07 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/software-tools-in-haskell.html">software-tools-in-haskell</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<p>This page is part of a series on <a href="../../pages/sth/index.html">Software Tools in Haskell</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/software-tools-in-haskell/examine.lhs">the source</a> into GHCi and play along.</p>

<p>As usual, we start with some imports.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- examine: interactively view a file</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span> (getArgs, getProgName)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO</span> (hPutStrLn, stderr)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (unfoldr)</code></pre></div>
<p>This is not one of the examples in <em>Software Tools</em>, but is a program I’ve found myself wishing I had in the past. It’s a simple interactive file viewer. <code>examine</code> takes a file and presents it to the user a little bit at a time, and accepts some simple commands: pressing <code>n</code> advances to the next chunk of the file, <code>v</code> the previous chunk, <code>x</code> exits the program, and <code>w</code> writes the current chunk to <code>stdout</code>. That last command, <code>w</code>, can be used to make <code>examine</code> act like a human-powered filter. To avoid cluttering up <code>stdout</code>, the interaction happens on <code>stderr</code>. (This is a minor abuse of <code>stderr</code>.) I’d prefer to use the arrow keys for navigation, but doing this in a platform-independent way is not so simple.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- interpret arguments</span>
<span class="ot">&gt;</span>   (num, name) <span class="ot">&lt;-</span> <span class="kw">case</span> args <span class="kw">of</span>
<span class="ot">&gt;</span>     [str]   <span class="ot">-&gt;</span> return (<span class="dv">10</span>, str)
<span class="ot">&gt;</span>     [k,str] <span class="ot">-&gt;</span> <span class="kw">case</span> readDecimalNat k <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>       <span class="dt">Just</span> m  <span class="ot">-&gt;</span> return (m, str)
<span class="ot">&gt;</span>     otherwise <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   lns <span class="ot">&lt;-</span> fmap getLines <span class="fu">$</span> readFile name
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   zipper <span class="ot">&lt;-</span> <span class="kw">case</span> chunksOf num lns <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>     <span class="dt">Just</span> xs <span class="ot">-&gt;</span> <span class="kw">case</span> makeZipperList xs <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>       <span class="dt">Just</span> ys <span class="ot">-&gt;</span> return ys
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     showInstructions
<span class="ot">&gt;</span>       <span class="fu">=</span> putOutOfBand [<span class="st">&quot;&quot;</span>, <span class="st">&quot;[n]ext pre[v] e[x]it [w]rite?&quot;</span>]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     prompt z <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       putOutOfBand <span class="fu">$</span> zlFocus z
<span class="ot">&gt;</span>       showInstructions
<span class="ot">&gt;</span>       input <span class="ot">&lt;-</span> getLine
<span class="ot">&gt;</span>       putOutOfBand [<span class="st">&quot;&quot;</span>]
<span class="ot">&gt;</span>       <span class="kw">case</span> input <span class="kw">of</span>
<span class="ot">&gt;</span>         <span class="st">&quot;x&quot;</span> <span class="ot">-&gt;</span> return ()
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>         <span class="st">&quot;n&quot;</span> <span class="ot">-&gt;</span> <span class="kw">case</span> zlNext z <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="dt">Just</span> w  <span class="ot">-&gt;</span> prompt w
<span class="ot">&gt;</span>           <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             putOutOfBand [<span class="st">&quot;end of file. (press any key)&quot;</span>]
<span class="ot">&gt;</span>             prompt z
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>         <span class="st">&quot;v&quot;</span> <span class="ot">-&gt;</span> <span class="kw">case</span> zlPrev z <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="dt">Just</span> w  <span class="ot">-&gt;</span> prompt w
<span class="ot">&gt;</span>           <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             putOutOfBand [<span class="st">&quot;start of file. (press any key)&quot;</span>]
<span class="ot">&gt;</span>             prompt z
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>         <span class="st">&quot;w&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>           sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> zlFocus z
<span class="ot">&gt;</span>           prompt z
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>         _ <span class="ot">-&gt;</span> prompt z
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   prompt zipper
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   exitSuccess
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; argErr ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> argErr <span class="fu">=</span> reportErrorMsgs
<span class="ot">&gt;</span>   [ <span class="st">&quot;usage:&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;  examine FILE     -- interactively view FILE 10 lines at a time&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;  examine INT FILE -- interactively view FILE INT lines at a time&quot;</span>
<span class="ot">&gt;</span>   ]</code></pre></div>
<p>One idea of interest is the way we represent our file internally. The file being examined can be thought of as a list of chunks, but we’d like one of these, the “current chunk”, to be special. Using a straight list to represent the chunks, we could use the list index to keep track of the current chunk. Updating the reference to the current chunk takes constant time (add or subtract 1), but retrieving the current chunk takes linear time. In a large file this could be a problem. Can we do better? In other languages we might use pointers to randomly access parts of a file, but in Haskell this strategy is less straightforward.</p>
<p>Note, though, that our design doesn’t really want <em>random</em> access to the parts of a file. We just want one part to be singled out as the “current” chunk and to have efficient ways to move to the “next” and “previous” chunk. We can represent this as a triple: the current chunk, a list of all the next chunks, and a list of all the previous chunks.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ZipperList</span> a <span class="fu">=</span> <span class="dt">ZL</span> a [a] [a]
<span class="ot">&gt;</span> 
<span class="ot">&gt; zlFocus ::</span> <span class="dt">ZipperList</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> zlFocus (<span class="dt">ZL</span> x _ _) <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt; makeZipperList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ZipperList</span> a)
<span class="ot">&gt;</span> makeZipperList []     <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> makeZipperList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">ZL</span> x [] xs
<span class="ot">&gt;</span> 
<span class="ot">&gt; zlNext ::</span> <span class="dt">ZipperList</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ZipperList</span> a)
<span class="ot">&gt;</span> zlNext (<span class="dt">ZL</span> _ _  [])     <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> zlNext (<span class="dt">ZL</span> x ys (z<span class="fu">:</span>zs)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">ZL</span> z (x<span class="fu">:</span>ys) zs
<span class="ot">&gt;</span> 
<span class="ot">&gt; zlPrev ::</span> <span class="dt">ZipperList</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ZipperList</span> a)
<span class="ot">&gt;</span> zlPrev (<span class="dt">ZL</span> _ []     _)  <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> zlPrev (<span class="dt">ZL</span> x (y<span class="fu">:</span>ys) zs) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">ZL</span> y ys (x<span class="fu">:</span>zs)</code></pre></div>
<p>I’ve called this a “zipper list” because it is related to the well-studied type theoretic concept of <a href="https://en.wikibooks.org/wiki/Haskell/Zippers">zippers</a>.</p>
<p>Zippers are <strong>wild</strong>, and one of the reasons I got turned on to Haskell in the first place. So Haskell types are objects in a category, right? And this category (among other properties) has all binary products and coproducts: tuples <code>(a,b)</code> and eithers <code>Either a b</code>. With a slight change in notation we can use ordinary multiplication and addition symbols to represent products and coproducts, so that a type like <code>(Either a b, c)</code> is denoted <code>(a+b)c</code>. A similar convention applies to algebraic data types. A type like</p>
<pre><code>data Foo a b c = A a | BC b c</code></pre>
<p>can be denoted <code>Foo(a,b,c) = a + bc</code>. The <code>data</code> keyword signals that we are naming a type-level synonym, or “function” of sorts, and this function looks an awful lot like a polynomial.</p>
<p>This is where zippers come in: any algebraic type has an associated “zipper” type, which represents the type of “one-hole contexts” over that type. And the zipper type is found by symbolically <strong>differentiating</strong> the original type function.</p>
<p>Here’s an extremely hand-wavy example. Recursive types can also play this game; so the type of lists, which we might denote</p>
<pre><code>data L a = Nil | Cons a (L a)</code></pre>
<p>can be represented as <span class="math inline">\(L(a) = 1 + a L(a)\)</span>. Blurring the line for a moment between functions and types we can “solve the equation” for <span class="math inline">\(L(a)\)</span> as <span class="math display">\[L(a) = \frac{1}{1-a}.\]</span> What does this even mean, though? Addition and multiplication of types is meaningful, but I’m not sure about subtraction and division. But if we convert this to its power series representation, we have <span class="math display">\[L(a) = 1 + a + a^2 + a^3 + \cdots.\]</span> This makes a little more sense. A list is either empty, or contains one element, or contains two elements, or three, and so on. (This singles out the unique “smallest” solution of the defining equation of <span class="math inline">\(L(a)\)</span>, excluding infinite lists. Hand wave!) Implicitly differentiating <span class="math inline">\(L(a) = 1 + aL(a)\)</span> with respect to <span class="math inline">\(a\)</span>, we get <span class="math display">\[L^\prime(a) = \frac{L(a)}{1-a},\]</span> which (using the power series hand wave) is <span class="math display">\[L^\prime(a) = L(a)L(a).\]</span> That is, the type of one-hole contexts of a list is a <em>pair</em> of lists, representing the part before and the part after the hole. With one element to fill the hole, this is the type of our <code>ZipperList</code>.</p>
<p>There is some deep magic here which I do not completely understand. For instance, the differentiation of types can be done automatically, and higher derivatives give us contexts with more than one hole. And does the analogy between types and calculus hold for codata (potentially infinite data)?</p>
<h2 id="old-stuff">Old Stuff</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- write list of messages to stderr</span>
<span class="ot">&gt; reportErrorMsgs ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> reportErrorMsgs errs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   name <span class="ot">&lt;-</span> getProgName
<span class="ot">&gt;</span>   sequence_ <span class="fu">$</span> map (hPutStrLn stderr) <span class="fu">$</span> ((name <span class="fu">++</span> <span class="st">&quot; error&quot;</span>)<span class="fu">:</span>errs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; chunksOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[a]]
<span class="ot">&gt;</span> chunksOf k xs
<span class="ot">&gt;</span>   <span class="fu">|</span> k <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> chunk xs
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     chunk [] <span class="fu">=</span> []
<span class="ot">&gt;</span>     chunk ys <span class="fu">=</span> <span class="kw">let</span> (as,bs) <span class="fu">=</span> splitAt k ys <span class="kw">in</span> as <span class="fu">:</span> chunk bs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; putOutOfBand ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> putOutOfBand xs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   sequence_ <span class="fu">$</span> map (hPutStrLn stderr) xs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- parse a natural number base 10</span>
<span class="ot">&gt; readDecimalNat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> readDecimalNat xs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   ys <span class="ot">&lt;-</span> sequence <span class="fu">$</span> map decToInt <span class="fu">$</span> reverse xs
<span class="ot">&gt;</span>   return <span class="fu">$</span> sum <span class="fu">$</span> zipWith (<span class="fu">*</span>) ys [<span class="dv">10</span><span class="fu">^</span>t <span class="fu">|</span> t <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>]]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     decToInt ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     decToInt x <span class="fu">=</span> lookup x
<span class="ot">&gt;</span>       [ (<span class="ch">'0'</span>,<span class="dv">0</span>), (<span class="ch">'1'</span>,<span class="dv">1</span>), (<span class="ch">'2'</span>,<span class="dv">2</span>), (<span class="ch">'3'</span>,<span class="dv">3</span>), (<span class="ch">'4'</span>,<span class="dv">4</span>)
<span class="ot">&gt;</span>       , (<span class="ch">'5'</span>,<span class="dv">5</span>), (<span class="ch">'6'</span>,<span class="dv">6</span>), (<span class="ch">'7'</span>,<span class="dv">7</span>), (<span class="ch">'8'</span>,<span class="dv">8</span>), (<span class="ch">'9'</span>,<span class="dv">9</span>)
<span class="ot">&gt;</span>       ]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- split on \n</span>
<span class="ot">&gt; getLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span> getLines <span class="fu">=</span> unfoldr firstLine
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     firstLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">String</span>, <span class="dt">String</span>)
<span class="ot">&gt;</span>     firstLine xs <span class="fu">=</span> <span class="kw">case</span> break (<span class="fu">==</span> <span class="ch">'\n'</span>) xs <span class="kw">of</span>
<span class="ot">&gt;</span>       (<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>       (as,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,<span class="st">&quot;&quot;</span>)
<span class="ot">&gt;</span>       (as,b<span class="fu">:</span>bs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,bs)</code></pre></div>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
