<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.blog - Software Tools in Haskell: paginate</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../raw/gfx/icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../raw/gfx/icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../raw/gfx/icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../raw/gfx/icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../pages/about.html">About</a>
    <a href="../../pages/projects.html">Projects</a>
    <a href="../../pages/contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: paginate</h1>
<!-- BEGIN BODY -->
<h2>format lines with page numbers and headers</h2>

<div class="info">
Posted on 2016-03-06 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/software-tools-in-haskell.html">software-tools-in-haskell</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<p>This page is part of a series on <a href="../../pages/sth/index.html">Software Tools in Haskell</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/software-tools-in-haskell/paginate.lhs">the source</a> into GHCi and play along.</p>

<p>As usual, we start with some imports.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="co">-- paginate: format lines with page numbers and headers</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Console.GetOpt</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span> (getArgs, getProgName)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO</span> (hPutStrLn, stderr)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (unfoldr, inits, isPrefixOf, intercalate)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Foldable</span> (foldl')</code></pre></div>
<p>Our virtual line printer <a href="../../posts/2016-03-05-software-tools-in-haskell-pslineprint.html"><code>pslineprint</code></a> is nice enough, but extremely simple; it does nothing at all to prettify the documents it prints. Our first attempt at this is <code>paginate</code>. This program will split a sequence of lines into “pages”, giving each page a header and page number. It will also be able to print more than one file sequentially, making each file start on its own page and ensuring that page numbers are correct across files. If any file name happens to be <code>-</code>, we read lines from <code>stdin</code>. Finally, it will optionally print a table of contents page in case we are printing a large number of long files.</p>
<p>I think this is the ugliest tool in our kit so far, and that part of the reason for this is that <code>paginate</code> depends on several arbitrary choices; frequently if there is a single “natural” or “obvious” choice, the resulting code is simple, but if we are making an arbitrary choice among several options our code feels complicated.</p>
<p>First lets look at the main program. Like <code>pslineprint</code>, there are enough options to make it worth our while to use <code>GetOpt</code> to process them. For now lets suppose we have functions <code>paginateLines</code> and <code>tableOfContents</code> that handle all the heavy lifting; the main program logic is mostly straightforward.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     argErr  <span class="fu">=</span> reportErrorMsgs [usageInfo <span class="st">&quot;options&quot;</span> options]
<span class="ot">&gt;</span>     corrErr <span class="fu">=</span> reportErrorMsgs [<span class="st">&quot;corrupt asacc input&quot;</span>]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- read options</span>
<span class="ot">&gt;</span>   (flags, filenames) <span class="ot">&lt;-</span> <span class="kw">case</span> getOpt <span class="dt">Permute</span> options args <span class="kw">of</span>
<span class="ot">&gt;</span>     (opts, rest, []) <span class="ot">-&gt;</span> <span class="kw">case</span> foldl (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Just</span> defaultFlags) opts <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>       <span class="dt">Just</span> fs <span class="ot">-&gt;</span> return (fs, rest)
<span class="ot">&gt;</span>     otherwise <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- process options</span>
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     pageOpts <span class="fu">=</span> <span class="dt">PO</span>
<span class="ot">&gt;</span>       { linesPerPage <span class="fu">=</span> fLinesPerPage flags
<span class="ot">&gt;</span>       , lineLength   <span class="fu">=</span> fLineLength flags
<span class="ot">&gt;</span>       }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="co">-- paginate files</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> fMode flags <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Lines</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span>
<span class="ot">&gt;</span>         readLines name <span class="fu">=</span> <span class="kw">case</span> name <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="st">&quot;-&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             lns <span class="ot">&lt;-</span> fmap getLines getContents
<span class="ot">&gt;</span>             return (<span class="st">&quot;-&quot;</span>, lns)
<span class="ot">&gt;</span>           otherwise <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             lns <span class="ot">&lt;-</span> fmap getLines <span class="fu">$</span> readFile name
<span class="ot">&gt;</span>             return (name, lns)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       docs <span class="ot">&lt;-</span> sequence <span class="fu">$</span> map readLines filenames
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       <span class="kw">if</span> fPrintTOC flags <span class="fu">==</span> <span class="dt">False</span>
<span class="ot">&gt;</span>         <span class="kw">then</span> return ()
<span class="ot">&gt;</span>         <span class="kw">else</span> sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> tableOfContents pageOpts docs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> paginateLines pageOpts docs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="dt">ASACC</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span>
<span class="ot">&gt;</span>         readLines name <span class="fu">=</span> <span class="kw">case</span> name <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="st">&quot;-&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             lns <span class="ot">&lt;-</span> fmap readCCLines getContents
<span class="ot">&gt;</span>             <span class="kw">case</span> lns <span class="kw">of</span>
<span class="ot">&gt;</span>               <span class="dt">Nothing</span> <span class="ot">-&gt;</span> corrErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>               <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (<span class="st">&quot;-&quot;</span>, xs)
<span class="ot">&gt;</span>           otherwise <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             lns <span class="ot">&lt;-</span> fmap readCCLines <span class="fu">$</span> readFile name
<span class="ot">&gt;</span>             <span class="kw">case</span> lns <span class="kw">of</span>
<span class="ot">&gt;</span>               <span class="dt">Nothing</span> <span class="ot">-&gt;</span> corrErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>               <span class="dt">Just</span> xs <span class="ot">-&gt;</span> return (name, xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       docs <span class="ot">&lt;-</span> sequence <span class="fu">$</span> map readLines filenames
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       <span class="kw">if</span> fPrintTOC flags <span class="fu">==</span> <span class="dt">False</span>
<span class="ot">&gt;</span>         <span class="kw">then</span> return ()
<span class="ot">&gt;</span>         <span class="kw">else</span> sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> map renderCCLine <span class="fu">$</span> tableOfContents pageOpts docs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> map renderCCLine <span class="fu">$</span> paginateCCLines pageOpts docs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   exitSuccess
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Mode</span> <span class="fu">=</span> <span class="dt">Lines</span> <span class="fu">|</span> <span class="dt">ASACC</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Flags</span> <span class="fu">=</span> <span class="dt">Flags</span>
<span class="ot">&gt;</span>   {<span class="ot"> fLinesPerPage ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   ,<span class="ot"> fLineLength   ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   ,<span class="ot"> fPrintTOC     ::</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>   ,<span class="ot"> fMode         ::</span> <span class="dt">Mode</span>
<span class="ot">&gt;</span>   }
<span class="ot">&gt;</span> 
<span class="ot">&gt; defaultFlags ::</span> <span class="dt">Flags</span>
<span class="ot">&gt;</span> defaultFlags <span class="fu">=</span> <span class="dt">Flags</span>
<span class="ot">&gt;</span>   { fLinesPerPage <span class="fu">=</span> <span class="dv">52</span>
<span class="ot">&gt;</span>   , fLineLength   <span class="fu">=</span> <span class="dv">75</span>
<span class="ot">&gt;</span>   , fPrintTOC     <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   , fMode         <span class="fu">=</span> <span class="dt">Lines</span>
<span class="ot">&gt;</span>   }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; options ::</span> [<span class="dt">OptDescr</span> (<span class="dt">Flags</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Flags</span>)]
<span class="ot">&gt;</span> options <span class="fu">=</span>
<span class="ot">&gt;</span>   [ <span class="dt">Option</span> [] [<span class="st">&quot;lines-per-page&quot;</span>]
<span class="ot">&gt;</span>       (<span class="dt">ReqArg</span> readLinesPerPage <span class="st">&quot;INT&quot;</span>)
<span class="ot">&gt;</span>       <span class="st">&quot;number of lines per page (including header)&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   , <span class="dt">Option</span> [] [<span class="st">&quot;line-length&quot;</span>]
<span class="ot">&gt;</span>       (<span class="dt">ReqArg</span> readLineLength <span class="st">&quot;INT&quot;</span>)
<span class="ot">&gt;</span>       <span class="st">&quot;length of header lines&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   , <span class="dt">Option</span> [] [<span class="st">&quot;toc&quot;</span>]
<span class="ot">&gt;</span>       (<span class="dt">NoArg</span> (\opts <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> opts { fPrintTOC <span class="fu">=</span> <span class="dt">True</span> }))
<span class="ot">&gt;</span>       <span class="st">&quot;print table of contents page&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   , <span class="dt">Option</span> [] [<span class="st">&quot;asacc&quot;</span>]
<span class="ot">&gt;</span>       (<span class="dt">NoArg</span> (\opts <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> opts { fMode <span class="fu">=</span> <span class="dt">ASACC</span> }))
<span class="ot">&gt;</span>       <span class="st">&quot;interpret basic ASA carriage control codes&quot;</span>
<span class="ot">&gt;</span>   ]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     readLinesPerPage str opts <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       k <span class="ot">&lt;-</span> readDecimalNat str
<span class="ot">&gt;</span>       return <span class="fu">$</span> opts { fLinesPerPage <span class="fu">=</span> k }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     readLineLength str opts <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       k <span class="ot">&lt;-</span> readDecimalNat str
<span class="ot">&gt;</span>       return <span class="fu">$</span> opts { fLineLength <span class="fu">=</span> k }</code></pre></div>
<p>Now for the actual pagination. Generally speaking, <code>paginate</code> takes a list of lines and inserts new lines – the headers – as well as some blank lines in appropriate places, so that the lines can then be taken in chunks of <span class="math inline">\(n\)</span> at a time (called “pages”). But exactly what a “line” is is already ambiguous; of course the usual “text separated by newlines” consists of lines, but so also does a file formatted using ASA carriage control codes. Both kinds of “line” are handled properly by <code>pslineprint</code>, and we already have at least one program, <code>overstrike</code>, which produces carriage control formatted text. So it seems worth our while to make <code>paginate</code> handle carriage controls as well.</p>
<p>An initial version of this program handled both kinds of line separately, which led to lots of duplicated code. To avoid this, we introduce an abstract <code>Line</code> type class.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Line</span> t <span class="kw">where</span>
<span class="ot">&gt;   fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> t
<span class="ot">&gt;</span> 
<span class="ot">&gt;   blankLine ::</span> t
<span class="ot">&gt;</span>   blankLine <span class="fu">=</span> fromString <span class="st">&quot;&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Line</span> <span class="dt">String</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   fromString x <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Line</span> <span class="dt">CCLine</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   fromString x <span class="fu">=</span> <span class="dt">CCLine</span> [x]</code></pre></div>
<p>Also, there are a few tweakable parameters we’d like to be able to adjust: the number of “lines” to appear on each page, and the width (in characters) of the header lines. We wrap these into a type, <code>PaginateOpts</code>, that can be more easily (and meaningfully) be passed around.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">PaginateOpts</span> <span class="fu">=</span> <span class="dt">PO</span>
<span class="ot">&gt;</span>   {<span class="ot"> linesPerPage ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   ,<span class="ot"> lineLength   ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   } <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; pageCount ::</span> (<span class="dt">Line</span> t) <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [t] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> pageCount opts xs <span class="fu">=</span> <span class="kw">if</span> r <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> q <span class="kw">else</span> q<span class="fu">+</span><span class="dv">1</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     slpp <span class="fu">=</span> (linesPerPage opts) <span class="fu">-</span> <span class="dv">2</span>
<span class="ot">&gt;</span>     (q,r) <span class="fu">=</span> ((count xs) <span class="ot">`div`</span> slpp, (count xs) <span class="ot">`rem`</span> slpp)
<span class="ot">&gt;</span> 
<span class="ot">&gt; startPages ::</span> (<span class="dt">Line</span> t) <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [[t]] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span> startPages opts lnss
<span class="ot">&gt;</span>   <span class="fu">=</span> map (\ks <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> sum ks)
<span class="ot">&gt;</span>       <span class="fu">$</span> inits
<span class="ot">&gt;</span>       <span class="fu">$</span> map (pageCount opts) lnss
<span class="ot">&gt;</span> 
<span class="ot">&gt; totalPages ::</span> (<span class="dt">Line</span> t) <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [[t]] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> totalPages opts lnss <span class="fu">=</span> sum <span class="fu">$</span> map (pageCount opts) lnss</code></pre></div>
<p>Note that from a <code>PaginateOpts</code> and a list of (abstract) documents we can compute the total number of pages used and the starting page numbers of each document. These will be used later.</p>
<p>Next we define an abstract page header. Our headers will include three pieces of information: the name of the file being paginated, the current page number, and the total number of pages. We also need a way to convert an abstract header to a list of lines; this is done with <code>renderHeader</code>. We define this function as part of a type class so that we can have different implementations for each kind of line.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Header</span> <span class="fu">=</span> <span class="dt">Header</span>
<span class="ot">&gt;</span>   {<span class="ot"> title      ::</span> <span class="dt">String</span>
<span class="ot">&gt;</span>   ,<span class="ot"> pageNumber ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   ,<span class="ot"> pageTotal  ::</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>   } <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">RenderHeader</span> t <span class="kw">where</span>
<span class="ot">&gt;   renderHeader ::</span> (<span class="dt">Line</span> t) <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> <span class="dt">Header</span> <span class="ot">-&gt;</span> [t]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">RenderHeader</span> <span class="dt">String</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   renderHeader opts h <span class="fu">=</span> [fn <span class="fu">++</span> (replicate (ll <span class="fu">-</span> nfn <span class="fu">-</span> npg) <span class="ch">' '</span>) <span class="fu">++</span> pg, <span class="st">&quot;&quot;</span>]
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>       pg  <span class="fu">=</span> show (pageNumber h) <span class="fu">++</span> <span class="st">&quot;/&quot;</span> <span class="fu">++</span> show (pageTotal h)
<span class="ot">&gt;</span>       npg <span class="fu">=</span> count pg
<span class="ot">&gt;</span>       ll  <span class="fu">=</span> lineLength opts
<span class="ot">&gt;</span>       fn  <span class="fu">=</span> <span class="kw">if</span> (count <span class="fu">$</span> title h) <span class="fu">+</span> npg <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> ll
<span class="ot">&gt;</span>         <span class="kw">then</span> abbr
<span class="ot">&gt;</span>         <span class="kw">else</span> title h
<span class="ot">&gt;</span>       abbr <span class="fu">=</span> <span class="st">&quot;...&quot;</span> <span class="fu">++</span> (reverse <span class="fu">$</span> take (ll <span class="fu">-</span> npg <span class="fu">-</span> <span class="dv">4</span>) <span class="fu">$</span> reverse <span class="fu">$</span> title h)
<span class="ot">&gt;</span>       nfn <span class="fu">=</span> count fn
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">RenderHeader</span> <span class="dt">CCLine</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   renderHeader opts h <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> <span class="dt">CCLine</span> [x]) <span class="fu">$</span> renderHeader opts h</code></pre></div>
<p>The actual pagination is handled by a few different functions:</p>
<ul>
<li><code>splitPages</code> divides a document into abstract pages, without proper page numbers.</li>
<li><code>numberPagesFromOf</code> fixes the page numbers of a list of abstract pages, with parameters allowing us to specify where to begin counting from and the total number of pages.</li>
<li><code>renderPage</code> converts an abstract page to a list of lines.</li>
<li><code>paginateOfFrom</code> combines <code>splitPages</code>, <code>numberPagesOfFrom</code>, and <code>renderPage</code> to paginate a single document.</li>
<li><code>paginateDocs</code> paginates a list of named documents.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; splitPages ::</span> (<span class="dt">Line</span> t) <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [t] <span class="ot">-&gt;</span> [(<span class="dt">Header</span>, [t])]
<span class="ot">&gt;</span> splitPages opts name <span class="fu">=</span> unfoldr firstPage
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     slpp <span class="fu">=</span> (linesPerPage opts) <span class="fu">-</span> <span class="dv">2</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;     firstPage ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ((<span class="dt">Header</span>,[a]),[a])
<span class="ot">&gt;</span>     firstPage [] <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     firstPage ys <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span>
<span class="ot">&gt;</span>         (zs,rest) <span class="fu">=</span> splitAt slpp ys
<span class="ot">&gt;</span>         hdr <span class="fu">=</span> <span class="dt">Header</span>
<span class="ot">&gt;</span>           { title      <span class="fu">=</span> name
<span class="ot">&gt;</span>           , pageNumber <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span>           , pageTotal  <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span>           }
<span class="ot">&gt;</span>       return ((hdr, zs), rest)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; numberPagesFromOf ::</span> (<span class="dt">Line</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Header</span>, [t])] <span class="ot">-&gt;</span> [(<span class="dt">Header</span>, [t])]
<span class="ot">&gt;</span> numberPagesFromOf m n xs <span class="fu">=</span> zipWith fix xs [m<span class="fu">..</span>]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     fix (h,y) k <span class="fu">=</span> (h {pageNumber <span class="fu">=</span> k, pageTotal <span class="fu">=</span> n}, y)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; renderPage ::</span> (<span class="dt">Line</span> t, <span class="dt">RenderHeader</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> (<span class="dt">Header</span>, [t]) <span class="ot">-&gt;</span> [t]
<span class="ot">&gt;</span> renderPage opts (hdr,lns)
<span class="ot">&gt;</span>   <span class="fu">=</span> take k ((renderHeader opts hdr) <span class="fu">++</span> lns <span class="fu">++</span> repeat blankLine)
<span class="ot">&gt;</span>   <span class="kw">where</span> k <span class="fu">=</span> linesPerPage opts
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; paginateOfFrom ::</span> (<span class="dt">Line</span> t, <span class="dt">RenderHeader</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, [t]) <span class="ot">-&gt;</span> [t]
<span class="ot">&gt;</span> paginateOfFrom opts n m (name, lns)
<span class="ot">&gt;</span>   <span class="fu">=</span> concatMap (renderPage opts)
<span class="ot">&gt;</span>       <span class="fu">$</span> numberPagesFromOf m n
<span class="ot">&gt;</span>       <span class="fu">$</span> splitPages opts name lns
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; paginateDocs ::</span> (<span class="dt">Line</span> t, <span class="dt">RenderHeader</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, [t])] <span class="ot">-&gt;</span> [t]
<span class="ot">&gt;</span> paginateDocs opts docs
<span class="ot">&gt;</span>   <span class="fu">=</span> concat <span class="fu">$</span> zipWith (paginateOfFrom opts tot) starts docs
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     starts <span class="fu">=</span> startPages opts <span class="fu">$</span> map snd docs
<span class="ot">&gt;</span>     tot    <span class="fu">=</span> totalPages opts <span class="fu">$</span> map snd docs</code></pre></div>
<p>The actual functions we expose from this module are <code>paginateLines</code> and <code>paginateCCLines</code>, which are just monomorphic synonyms of <code>paginateDocs</code> for ordinary lines and carriage control formatted lines, and the constructor for <code>PaginateOpts</code>. As far as consumers of this module are concerned, these two black-boxes are implemented separately. Since (as of this writing) the <code>Line</code> class has only two instances there is no reason to expose the guts of pagination. But by writing our code against an abstract <code>Line</code> class, it will be easier to extend in the future if needed.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; paginateLines ::</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, [<span class="dt">String</span>])] <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span> paginateLines <span class="fu">=</span> paginateDocs
<span class="ot">&gt;</span> 
<span class="ot">&gt; paginateCCLines ::</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, [<span class="dt">CCLine</span>])] <span class="ot">-&gt;</span> [<span class="dt">CCLine</span>]
<span class="ot">&gt;</span> paginateCCLines <span class="fu">=</span> paginateDocs</code></pre></div>
<p>All that remains is to provide a function for building the table of contents. This part is kind of gross.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tableOfContents ::</span> (<span class="dt">Line</span> t, <span class="dt">RenderHeader</span> t)
<span class="ot">&gt;</span>   <span class="ot">=&gt;</span> <span class="dt">PaginateOpts</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, [t])] <span class="ot">-&gt;</span> [t]
<span class="ot">&gt;</span> tableOfContents opts docs <span class="fu">=</span> concat <span class="fu">$</span> pad <span class="fu">$</span>
<span class="ot">&gt;</span>   (fromString <span class="st">&quot;Contents&quot;</span>) <span class="fu">:</span> blankLine <span class="fu">:</span> tocLines
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     ks <span class="fu">=</span> startPages opts <span class="fu">$</span> map snd docs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     tocLines <span class="fu">=</span> zipWith tocLine (map fst docs) ks
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     tocLine name pg <span class="fu">=</span> fromString <span class="fu">$</span> padNum pg <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> abbr name
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     ll  <span class="fu">=</span> lineLength opts
<span class="ot">&gt;</span>     abbr str <span class="fu">=</span> <span class="kw">if</span> (count str) <span class="fu">+</span> <span class="dv">5</span> <span class="fu">&gt;</span> ll
<span class="ot">&gt;</span>       <span class="kw">then</span> <span class="st">&quot;...&quot;</span> <span class="fu">++</span> (reverse <span class="fu">$</span> take (ll <span class="fu">-</span> <span class="dv">9</span>) <span class="fu">$</span> reverse <span class="fu">$</span> str)
<span class="ot">&gt;</span>       <span class="kw">else</span> str 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     padNum k <span class="fu">=</span> reverse <span class="fu">$</span> take <span class="dv">5</span> <span class="fu">$</span> (reverse <span class="fu">$</span> show k) <span class="fu">++</span> repeat <span class="ch">' '</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     pad <span class="fu">=</span> unfoldr padFirst
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     padFirst [] <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     padFirst xs <span class="fu">=</span> <span class="dt">Just</span> (take (linesPerPage opts) (ys <span class="fu">++</span> repeat blankLine), rest)
<span class="ot">&gt;</span>       <span class="kw">where</span> (ys, rest) <span class="fu">=</span> splitAt (linesPerPage opts) xs</code></pre></div>
<p>A few comments about the default options. I expect that the main use of <code>paginate</code> will be to prepare documents for <code>pslineprint</code>, and the default settings of that program produce pages with 52 lines per page and about 75 characters per line. Using these as the defaults for <code>paginate</code> means we can say things like</p>
<pre><code>paginate foo.txt | pslineprint</code></pre>
<p>and get reasonable results.</p>
<h2 id="old-stuff">Old Stuff</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; count ::</span> (<span class="dt">Num</span> t) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> t
<span class="ot">&gt;</span> count <span class="fu">=</span> foldl' inc <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span> inc n _ <span class="fu">=</span> n<span class="fu">+</span><span class="dv">1</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- split on \n</span>
<span class="ot">&gt; getLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span> getLines <span class="fu">=</span> unfoldr firstLine
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     firstLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">String</span>, <span class="dt">String</span>)
<span class="ot">&gt;</span>     firstLine xs <span class="fu">=</span> <span class="kw">case</span> break (<span class="fu">==</span> <span class="ch">'\n'</span>) xs <span class="kw">of</span>
<span class="ot">&gt;</span>       (<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>       (as,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,<span class="st">&quot;&quot;</span>)
<span class="ot">&gt;</span>       (as,b<span class="fu">:</span>bs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,bs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; unfoldrMaybe ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (a,b))) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]
<span class="ot">&gt;</span> unfoldrMaybe f x <span class="fu">=</span> <span class="kw">case</span> f x <span class="kw">of</span>
<span class="ot">&gt;</span>   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>   <span class="dt">Just</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> []
<span class="ot">&gt;</span>   <span class="dt">Just</span> (<span class="dt">Just</span> (a,b)) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     as <span class="ot">&lt;-</span> unfoldrMaybe f b
<span class="ot">&gt;</span>     <span class="dt">Just</span> (a<span class="fu">:</span>as)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- write list of messages to stderr</span>
<span class="ot">&gt; reportErrorMsgs ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> reportErrorMsgs errs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   name <span class="ot">&lt;-</span> getProgName
<span class="ot">&gt;</span>   sequence_ <span class="fu">$</span> map (hPutStrLn stderr) <span class="fu">$</span> ((name <span class="fu">++</span> <span class="st">&quot; error&quot;</span>)<span class="fu">:</span>errs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- parse a natural number base 10</span>
<span class="ot">&gt; readDecimalNat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> readDecimalNat xs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   ys <span class="ot">&lt;-</span> sequence <span class="fu">$</span> map decToInt <span class="fu">$</span> reverse xs
<span class="ot">&gt;</span>   return <span class="fu">$</span> sum <span class="fu">$</span> zipWith (<span class="fu">*</span>) ys [<span class="dv">10</span><span class="fu">^</span>t <span class="fu">|</span> t <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>]]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     decToInt ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     decToInt x <span class="fu">=</span> lookup x
<span class="ot">&gt;</span>       [ (<span class="ch">'0'</span>,<span class="dv">0</span>), (<span class="ch">'1'</span>,<span class="dv">1</span>), (<span class="ch">'2'</span>,<span class="dv">2</span>), (<span class="ch">'3'</span>,<span class="dv">3</span>), (<span class="ch">'4'</span>,<span class="dv">4</span>)
<span class="ot">&gt;</span>       , (<span class="ch">'5'</span>,<span class="dv">5</span>), (<span class="ch">'6'</span>,<span class="dv">6</span>), (<span class="ch">'7'</span>,<span class="dv">7</span>), (<span class="ch">'8'</span>,<span class="dv">8</span>), (<span class="ch">'9'</span>,<span class="dv">9</span>)
<span class="ot">&gt;</span>       ]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">CCLine</span>
<span class="ot">&gt;</span>   <span class="fu">=</span> <span class="dt">CCLine</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; fromCCLine ::</span> <span class="dt">CCLine</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span> fromCCLine (<span class="dt">CCLine</span> xs) <span class="fu">=</span> xs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; renderCCLine ::</span> <span class="dt">CCLine</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> renderCCLine (<span class="dt">CCLine</span> xs)
<span class="ot">&gt;</span>   <span class="fu">=</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> zipWith (<span class="fu">:</span>) (<span class="ch">' '</span> <span class="fu">:</span> (repeat <span class="ch">'+'</span>)) xs
<span class="ot">&gt;</span> 
<span class="ot">&gt; readCCLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">CCLine</span>]
<span class="ot">&gt;</span> readCCLines <span class="fu">=</span> unfoldrMaybe readFirstCCLine <span class="fu">.</span> getLines
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     readFirstCCLine ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">CCLine</span>, [<span class="dt">String</span>]))
<span class="ot">&gt;</span>     readFirstCCLine [] <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     readFirstCCLine ((<span class="ch">' '</span><span class="fu">:</span>cs)<span class="fu">:</span>ds) <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span>
<span class="ot">&gt;</span>         (us,vs) <span class="fu">=</span> span (isPrefixOf <span class="st">&quot;+&quot;</span>) ds
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>         stripPlus xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="ch">'+'</span><span class="fu">:</span>ys    <span class="ot">-&gt;</span> <span class="dt">Just</span> ys
<span class="ot">&gt;</span>           otherwise <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       <span class="kw">case</span> sequence <span class="fu">$</span> map stripPlus us <span class="kw">of</span>
<span class="ot">&gt;</span>         <span class="dt">Just</span> ws <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Just</span> (<span class="dt">CCLine</span> <span class="fu">$</span> cs<span class="fu">:</span>ws, vs))
<span class="ot">&gt;</span>         <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     readFirstCCLine _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
