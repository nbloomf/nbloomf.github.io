<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>nbloomf.github.io - Software Tools in Haskell: line number</title>
<link rel="stylesheet" type="text/css" href="../../css/default.css" />
<link rel="icon" href="../../icon/favicon-32.png" />
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../icon/favicon-57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../icon/favicon-114.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../icon/favicon-152.png" />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
<div id="header">
  <div id="logo">
    <a href="../../index.html">nbloomf</a>
  </div>
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../about.html">About</a>
    <a href="../../projects.html">Projects</a>
    <a href="../../contact.html">Contact</a>
    <a href="../../archive.html">Blog</a>
  </div>
</div>

<div id="content">
<h1>Software Tools in Haskell: line number</h1>
<!-- BEGIN BODY -->
<h2>number lines on stdin</h2>

<div class="info">
Posted on 2016-03-09 by nbloomf
</div>


<div class="info tags">Tags: <a href="../../tag/software-tools-in-haskell.html">software-tools-in-haskell</a>, <a href="../../tag/literate-haskell.html">literate-haskell</a></div>


<p>This page is part of a series on <a href="../../pages/sth/index.html">Software Tools in Haskell</a>.</p>

<p>This post is literate Haskell; you can load <a href="https://raw.githubusercontent.com/nbloomf/nbloomf.md/master/posts/software-tools-in-haskell/linenumber.lhs">the source</a> into GHCi and play along.</p>

<p>As usual, we start with some imports.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- linenumber: number lines on stdin</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess, exitFailure)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span> (getArgs, getProgName)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO</span> (hPutStrLn, stderr)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (unfoldr)</code></pre></div>
<p>This is another utility intended for use with <code>pslineprint</code>: it prepends lines on <code>stdin</code> with line numbers.</p>
<p>By default, this program separates the line number from the line contents by a tab; the output is tab-delimited text. This reflects the fact that the line number is semantically distinct from the line contents. The <code>--pad</code> option instead separates the numbers from the contents by a space, and also left-pads the numbers so that they are vertically aligned and right-justified. Finally, the <code>--from</code> option allows the user to specify the number of the first line (natural numbers only).</p>
<p>We made tab-separated output the default because it is the simplest; we can march down the list of lines on <code>stdin</code> and send them to <code>stdout</code> with the numer prefixed. We only need to keep track of the current line number. Nicely padded line numbers with spaces, however, require us to know in advance the total number of lines required before we can begin producing output.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Mode</span> <span class="fu">=</span> <span class="dt">Tab</span> <span class="fu">|</span> <span class="dt">Pad</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   (mode,from) <span class="ot">&lt;-</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     <span class="kw">let</span>
<span class="ot">&gt;</span>       (m,rest) <span class="fu">=</span> <span class="kw">case</span> args <span class="kw">of</span>
<span class="ot">&gt;</span>         (<span class="st">&quot;--pad&quot;</span><span class="fu">:</span>xs) <span class="ot">-&gt;</span> (<span class="dt">Pad</span>, xs)
<span class="ot">&gt;</span>         xs           <span class="ot">-&gt;</span> (<span class="dt">Tab</span>, xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="kw">case</span> rest <span class="kw">of</span>
<span class="ot">&gt;</span>       [<span class="st">&quot;--from&quot;</span>,k] <span class="ot">-&gt;</span> <span class="kw">case</span> readDecimalNat k <span class="kw">of</span>
<span class="ot">&gt;</span>         <span class="dt">Nothing</span> <span class="ot">-&gt;</span> argErr <span class="fu">&gt;&gt;</span> exitFailure
<span class="ot">&gt;</span>         <span class="dt">Just</span> t  <span class="ot">-&gt;</span> return (m,t)
<span class="ot">&gt;</span>       otherwise <span class="ot">-&gt;</span> return (m,<span class="dv">1</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   lns <span class="ot">&lt;-</span> fmap ((zip [from<span class="fu">..</span>]) <span class="fu">.</span> getLines) getContents
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   <span class="kw">case</span> mode <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Tab</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span> wr (a,str) <span class="fu">=</span> show a <span class="fu">++</span> <span class="st">&quot;\t&quot;</span> <span class="fu">++</span> str
<span class="ot">&gt;</span>       sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> map wr lns
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="dt">Pad</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>       <span class="kw">let</span>
<span class="ot">&gt;</span>         len <span class="fu">=</span> <span class="kw">case</span> lns <span class="kw">of</span>
<span class="ot">&gt;</span>           [] <span class="ot">-&gt;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>           zs <span class="ot">-&gt;</span> length <span class="fu">$</span> show <span class="fu">$</span> fst <span class="fu">$</span> last zs
<span class="ot">&gt;</span>         pad n <span class="fu">=</span> padToByBefore len <span class="ch">' '</span> (show n)
<span class="ot">&gt;</span>         wr (a,str) <span class="fu">=</span> pad a <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> str
<span class="ot">&gt;</span>       sequence_ <span class="fu">$</span> map putStrLn <span class="fu">$</span> map wr lns
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   exitSuccess
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; argErr ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> argErr <span class="fu">=</span> reportErrorMsgs
<span class="ot">&gt;</span>   [ <span class="st">&quot;usage:&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;  linenumber       : prepend line numbers (tab separated)&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;  linenumber --pad : prepend line numbers (padded with spaces)&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;options:&quot;</span>
<span class="ot">&gt;</span>   , <span class="st">&quot;  --from NAT : start numbering at NAT; default is 1&quot;</span>
<span class="ot">&gt;</span>   ]</code></pre></div>
<p>This program uses one new library function: <code>padToByBefore</code>, the companion of <code>padToByAfter</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; padToByBefore ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> padToByBefore k z xs <span class="fu">=</span> reverse <span class="fu">$</span> padToByAfter k z (reverse xs)</code></pre></div>
<h2 id="old-stuff">Old Stuff</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- split on \n</span>
<span class="ot">&gt; getLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">&gt;</span> getLines <span class="fu">=</span> unfoldr firstLine
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     firstLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">String</span>, <span class="dt">String</span>)
<span class="ot">&gt;</span>     firstLine xs <span class="fu">=</span> <span class="kw">case</span> break (<span class="fu">==</span> <span class="ch">'\n'</span>) xs <span class="kw">of</span>
<span class="ot">&gt;</span>       (<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>       (as,<span class="st">&quot;&quot;</span>)   <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,<span class="st">&quot;&quot;</span>)
<span class="ot">&gt;</span>       (as,b<span class="fu">:</span>bs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (as,bs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- write list of messages to stderr</span>
<span class="ot">&gt; reportErrorMsgs ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> reportErrorMsgs errs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   name <span class="ot">&lt;-</span> getProgName
<span class="ot">&gt;</span>   sequence_ <span class="fu">$</span> map (hPutStrLn stderr) <span class="fu">$</span> ((name <span class="fu">++</span> <span class="st">&quot; error&quot;</span>)<span class="fu">:</span>errs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- parse a natural number base 10</span>
<span class="ot">&gt; readDecimalNat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> readDecimalNat xs <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   ys <span class="ot">&lt;-</span> sequence <span class="fu">$</span> map decToInt <span class="fu">$</span> reverse xs
<span class="ot">&gt;</span>   return <span class="fu">$</span> sum <span class="fu">$</span> zipWith (<span class="fu">*</span>) ys [<span class="dv">10</span><span class="fu">^</span>t <span class="fu">|</span> t <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>]]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     decToInt ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     decToInt x <span class="fu">=</span> lookup x
<span class="ot">&gt;</span>       [ (<span class="ch">'0'</span>,<span class="dv">0</span>), (<span class="ch">'1'</span>,<span class="dv">1</span>), (<span class="ch">'2'</span>,<span class="dv">2</span>), (<span class="ch">'3'</span>,<span class="dv">3</span>), (<span class="ch">'4'</span>,<span class="dv">4</span>)
<span class="ot">&gt;</span>       , (<span class="ch">'5'</span>,<span class="dv">5</span>), (<span class="ch">'6'</span>,<span class="dv">6</span>), (<span class="ch">'7'</span>,<span class="dv">7</span>), (<span class="ch">'8'</span>,<span class="dv">8</span>), (<span class="ch">'9'</span>,<span class="dv">9</span>)
<span class="ot">&gt;</span>       ]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">--  'padToByAfter' takes an integer k, a thing</span>
<span class="ot">&gt;</span> <span class="co">--  z, and a list xs, and returns a list of length</span>
<span class="ot">&gt;</span> <span class="co">--  k consisting of the elements of xs pads xs to length k</span>
<span class="ot">&gt;</span> <span class="co">--  by postpending copies of z. If xs is longer</span>
<span class="ot">&gt;</span> <span class="co">--  than k there is an error. (We take &quot;pad&quot; very</span>
<span class="ot">&gt;</span> <span class="co">--  seriously.)</span>
<span class="ot">&gt; padToByAfter ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> padToByAfter k z xs <span class="fu">=</span> take k (xs <span class="fu">++</span> repeat z)</code></pre></div>

<!-- END BODY -->
</div>

<div id="footer">
  Site generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</body>
</html>
